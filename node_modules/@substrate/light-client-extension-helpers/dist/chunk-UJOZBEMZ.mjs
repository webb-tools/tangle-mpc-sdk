// src/shared/constants.ts
var extensionPrefix = "@substrate/light-client-extension-helper";
var contextPrefix = `${extensionPrefix}-context`;
var CONTEXT = {
  CONTENT_SCRIPT: `${contextPrefix}-content-script`,
  BACKGROUND: `${contextPrefix}-background`,
  EXTENSION_PAGE: `${contextPrefix}-extension-page`,
  WEB_PAGE: `${contextPrefix}-web-page`
};
var portPrefix = `${extensionPrefix}-port`;
var PORT = {
  CONTENT_SCRIPT: `${portPrefix}-content-script`,
  EXTENSION_PAGE: `${portPrefix}-extension-page`,
  WEB_PAGE: `${portPrefix}-web-page`
};
var STORAGE_PREFIX = extensionPrefix;
var alarmPrefix = `${extensionPrefix}-alarm`;
var ALARM = {
  DATABASE_UPDATE: `${alarmPrefix}-database-update`
};
var KEEP_ALIVE_INTERVAL = 2e4;

// src/shared/createBackgroundClientConnectProvider.ts
import { getSyncProvider } from "@polkadot-api/json-rpc-provider-proxy";

// src/shared/getRandomChainId.ts
var getRandomChainId = () => {
  const arr = new BigUint64Array(2);
  crypto.getRandomValues(arr);
  const result = arr[1] << BigInt(64) | arr[0];
  return result.toString(36);
};

// src/shared/createBackgroundClientConnectProvider.ts
var createBackgroundClientConnectProvider = ({
  genesisHash,
  chainSpec,
  relayChainGenesisHash,
  postMessage,
  addOnMessageListener,
  addOnDisconnectListener
}) => getSyncProvider(async () => {
  const chainId = getRandomChainId();
  await new Promise((resolve, reject) => {
    const removeOnMessageListener = addOnMessageListener((msg) => {
      if (msg?.chainId !== chainId)
        return;
      switch (msg.type) {
        case "chain-ready": {
          resolve();
          break;
        }
        case "error": {
          reject(new Error(msg.errorMessage));
          break;
        }
        default:
          reject(new Error(`Unrecognized message ${JSON.stringify(msg)}`));
          break;
      }
      removeOnMessageListener();
    });
    postMessage(
      chainSpec ? {
        origin: "substrate-connect-client",
        type: "add-chain",
        chainId,
        chainSpec,
        potentialRelayChainIds: relayChainGenesisHash ? [relayChainGenesisHash] : []
      } : {
        origin: "substrate-connect-client",
        type: "add-well-known-chain",
        chainId,
        chainName: genesisHash
      }
    );
  });
  return (onMessage, onHalt) => {
    const removeOnMessageListener = addOnMessageListener((msg) => {
      if (msg.chainId !== chainId)
        return;
      switch (msg.type) {
        case "rpc": {
          onMessage(msg.jsonRpcMessage);
          break;
        }
        case "error": {
          console.error(msg.errorMessage);
          removeListeners();
          onHalt();
          break;
        }
        default:
          console.warn(`Unrecognized message ${JSON.stringify(msg)}`);
          break;
      }
    });
    const removeOnDisconnectListener = addOnDisconnectListener?.(onHalt);
    const removeListeners = () => {
      removeOnMessageListener();
      removeOnDisconnectListener?.();
    };
    return {
      send(jsonRpcMessage) {
        postMessage({
          origin: "substrate-connect-client",
          type: "rpc",
          chainId,
          jsonRpcMessage
        });
      },
      disconnect() {
        removeListeners();
        postMessage({
          origin: "substrate-connect-client",
          type: "remove-chain",
          chainId
        });
      }
    };
  };
});

// src/shared/createRpc.ts
var createRpc = (sendMessage, handlers, middlewares) => {
  let nextId = 0;
  const pending = /* @__PURE__ */ new Map();
  middlewares ?? (middlewares = []);
  middlewares.unshift(
    createResponseMiddleware(sendMessage),
    createIsValidMethodMiddleware(Object.keys(handlers ?? {}))
  );
  const applyMiddleware = middlewares.reduce(
    (prevMiddleware, nextMiddleware) => (next, message, context) => prevMiddleware(
      (request2, context2) => nextMiddleware(next, request2, context2),
      message,
      context
    )
  );
  const innerMethodHandler = ({ method, params }, context) => handlers?.[method](params ?? [], context);
  const methodHandler = (message, context) => applyMiddleware(innerMethodHandler, message, context);
  const request = (method, params) => {
    const id = `${nextId++}`;
    sendMessage({ id, method, params });
    return new Promise(
      (resolve, reject) => pending.set(id, { resolve, reject })
    );
  };
  const notify = (method, params) => {
    sendMessage({ method, params });
  };
  const handle = async (message, context) => {
    if (!isRpcMessage(message))
      return;
    if ("method" in message) {
      try {
        await methodHandler(message, context);
      } catch (error) {
        console.error("error hanlding message:", message, error);
      }
    } else if ("id" in message) {
      const { id } = message;
      if (!pending.has(id))
        return console.assert(false, "Unknown message", message);
      const { resolve, reject } = pending.get(id);
      pending.delete(id);
      if ("error" in message)
        return reject(message.error);
      resolve(message.result);
    } else {
      console.assert(false, "Unhandled message", message);
    }
  };
  return {
    request,
    notify,
    handle,
    withClient() {
      const cache = /* @__PURE__ */ new Map();
      const client = new Proxy({}, {
        get(_, prop) {
          if (!cache.has(prop))
            cache.set(prop, (...args) => request(prop, args));
          return cache.get(prop);
        }
      });
      return {
        request(method, params) {
          return request(method, params);
        },
        notify(method, params) {
          notify(method, params);
        },
        handle,
        client
      };
    }
  };
};
var isRpcMessage = (message) => typeof message === "object" && ("method" in message || "id" in message);
var createIsValidMethodMiddleware = (methods) => (next, request, context) => {
  if (!methods.includes(request.method))
    throw new RpcError("Method not found", -32601);
  return next(request, context);
};
var createResponseMiddleware = (sendMessage) => async (next, request, context) => {
  const { id } = request;
  try {
    const result = await next(request, context);
    if (!id)
      return;
    sendMessage({ id, result });
  } catch (error) {
    if (!id)
      return;
    if (error instanceof RpcError)
      sendMessage({
        id,
        error: {
          code: error.code,
          message: error.message,
          data: error.data
        }
      });
    sendMessage({
      id,
      error: {
        code: -32603,
        message: error instanceof Error ? error.toString() : typeof error === "string" ? error : "Unknown error"
      }
    });
  }
};
var RpcError = class extends Error {
  constructor(message, code, data) {
    super();
    this.message = message;
    this.code = code;
    this.data = data;
  }
};

// src/shared/message-utils.ts
var isSubstrateConnectToExtensionMessage = (msg) => {
  if (typeof msg !== "object")
    return false;
  if (msg.origin !== "substrate-connect-client")
    return false;
  return true;
};
var isSubstrateConnectToApplicationMessage = (msg) => {
  if (typeof msg !== "object")
    return false;
  if (msg.origin !== "substrate-connect-extension")
    return false;
  return true;
};
var isRpcMessageWithOrigin = (msg, origin) => {
  if (!isRpcMessage(msg))
    return false;
  if ("origin" in msg && msg.origin !== origin)
    return false;
  return true;
};

export {
  CONTEXT,
  PORT,
  STORAGE_PREFIX,
  ALARM,
  KEEP_ALIVE_INTERVAL,
  createBackgroundClientConnectProvider,
  isSubstrateConnectToExtensionMessage,
  isSubstrateConnectToApplicationMessage,
  isRpcMessageWithOrigin,
  createRpc,
  isRpcMessage,
  RpcError
};
//# sourceMappingURL=chunk-UJOZBEMZ.mjs.map