/**
 * Copyright (c) 2015-present, Waysact Pty Ltd
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { computeIntegrity } from "./util";
export class AssetIntegrity {
    hashFuncNames;
    constructor(hashFuncNames) {
        this.hashFuncNames = hashFuncNames;
    }
    /**
     * @internal
     */
    assetIntegrity = new Map();
    /**
     * @internal
     */
    inverseAssetIntegrity = new Map();
    update(assetKey, integrity) {
        if (!this.assetIntegrity.has(assetKey)) {
            this.assetIntegrity.set(assetKey, integrity);
            this.inverseAssetIntegrity.set(integrity, assetKey);
        }
        return integrity;
    }
    updateHash(input, oldHash) {
        const assetKey = this.inverseAssetIntegrity.get(oldHash);
        if (assetKey && input[0]) {
            const newIntegrity = computeIntegrity(this.hashFuncNames, input[0]);
            this.inverseAssetIntegrity.delete(oldHash);
            this.assetIntegrity.delete(assetKey);
            this.update(assetKey, newIntegrity);
            return newIntegrity;
        }
        return undefined;
    }
    updateFromSource(assetKey, source) {
        return this.update(assetKey, computeIntegrity(this.hashFuncNames, source));
    }
    has(assetKey) {
        return this.assetIntegrity.has(assetKey);
    }
    get(assetKey) {
        return this.assetIntegrity.get(assetKey);
    }
}
//# sourceMappingURL=integrity.js.map