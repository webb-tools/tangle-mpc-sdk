/**
 * Copyright (c) 2015-present, Waysact Pty Ltd
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { thisPluginName } from "./globals";
import { hasOwnProperty } from "./util";
function sriStatsFactory(statsFactory) {
    statsFactory.hooks.extract
        .for("asset")
        .tap(thisPluginName, (object, asset) => {
        const contenthash = asset.info?.contenthash;
        if (contenthash) {
            const shaHashes = (Array.isArray(contenthash) ? contenthash : [contenthash]).filter((hash) => String(hash).match(/^sha[0-9]+-/));
            if (shaHashes.length > 0) {
                object.integrity =
                    shaHashes.join(" ");
            }
        }
    });
}
function installStatsFactoryPlugin(compiler) {
    compiler.hooks.compilation.tap(thisPluginName, (compilation) => {
        compilation.hooks.statsFactory.tap(thisPluginName, sriStatsFactory);
    });
}
function isErrorWithCode(obj) {
    return (obj instanceof Error &&
        hasOwnProperty(obj, "code") &&
        ["string", "undefined"].includes(typeof obj.code));
}
export function install(compiler, callback) {
    let getHtmlWebpackPluginHooks = null;
    compiler.hooks.beforeCompile.tapPromise(thisPluginName, async () => {
        try {
            getHtmlWebpackPluginHooks = (await import("html-webpack-plugin")).default
                .getHooks;
        }
        catch (e) {
            if (!isErrorWithCode(e) || e.code !== "MODULE_NOT_FOUND") {
                throw e;
            }
        }
    });
    compiler.hooks.afterPlugins.tap(thisPluginName, (compiler) => {
        compiler.hooks.thisCompilation.tap({
            name: thisPluginName,
            stage: -10000,
        }, (compilation) => {
            callback(compilation, getHtmlWebpackPluginHooks?.(compilation) || null);
        });
        installStatsFactoryPlugin(compiler);
    });
}
//# sourceMappingURL=hooks.js.map