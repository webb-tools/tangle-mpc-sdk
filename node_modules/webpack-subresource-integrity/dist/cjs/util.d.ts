/**
 * Copyright (c) 2015-present, Waysact Pty Ltd
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/// <reference types="node" />
import type { AssetInfo, Chunk, Compilation, Compiler, sources } from "webpack";
import type { HtmlTagObject } from "./types";
export type ChunkGroup = ReturnType<Compilation["addChunkInGroup"]>;
export declare const sriHashVariableReference = "__webpack_require__.sriHashes";
export declare function assert(value: unknown, message: string): asserts value;
export declare function getTagSrc(tag: HtmlTagObject): string | undefined;
export declare const normalizePath: (p: string) => string;
export declare const placeholderPrefix = "*-*-*-CHUNK-SRI-HASH-";
export declare const placeholderRegex: RegExp;
export declare const computeIntegrity: (hashFuncNames: string[], source: string | Buffer) => string;
export declare const makePlaceholder: (hashFuncNames: string[], id: string | number) => string;
export declare function addIfNotExist<T>(set: Set<T>, item: T): boolean;
export declare function findChunks(chunk: Chunk): Set<Chunk>;
export declare function notNil<TValue>(value: TValue | null | undefined): value is TValue;
export declare function generateSriHashPlaceholders(chunks: Iterable<Chunk>, hashFuncNames: [string, ...string[]]): Record<string, string>;
export declare function intersect<T>(sets: Iterable<Set<T>>): Generator<T>;
export declare function intersectSets<T>(setsToIntersect: Iterable<Set<T>>): Set<T>;
export declare function unionSet<T>(...sets: Iterable<T>[]): Set<T>;
export declare function map<T, TResult>(items: Iterable<T>, fn: (item: T) => TResult): Generator<TResult>;
export declare function flatMap<T, TResult>(collections: Iterable<T>, fn: (item: T) => Iterable<TResult>): Generator<TResult>;
export declare function allChunksInGroupIterable(chunkGroup: ChunkGroup): Generator<Chunk>;
export declare function allChunksInChunkIterable(chunk: Chunk): Generator<Chunk>;
export declare function allChunksInPrimaryChunkIterable(chunk: Chunk): Generator<Chunk>;
export declare function updateAsset(compilation: Compilation, assetPath: string, source: sources.Source, integrity: string, onUpdate: (assetInfo: AssetInfo) => void): void;
export declare function tryGetSource(source: sources.Source): string | Buffer | undefined;
export declare function replaceInSource(compiler: Compiler, source: sources.Source, path: string, replacements: Map<string, string>): sources.Source;
export declare function usesAnyHash(assetInfo: AssetInfo): boolean;
export declare function hasOwnProperty<X extends object, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown>;
//# sourceMappingURL=util.d.ts.map