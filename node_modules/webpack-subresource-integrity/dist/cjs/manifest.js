"use strict";
/**
 * Copyright (c) 2015-present, Waysact Pty Ltd
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddLazySriRuntimeModule = exports.getChunkToManifestMap = void 0;
const util_1 = require("./util");
const scc_1 = require("./scc");
const webpack_1 = require("webpack");
// This implementation assumes a directed acyclic graph (such as one produced by createDAGfromGraph),
// and does not attempt to detect cycles
function topologicalSort({ vertices, edges }) {
    const sortedItems = [];
    const seenNodes = new Set();
    function visit(node) {
        var _a;
        if ((0, util_1.addIfNotExist)(seenNodes, node)) {
            return;
        }
        ((_a = edges.get(node)) !== null && _a !== void 0 ? _a : []).forEach(visit);
        sortedItems.push(node);
    }
    vertices.forEach(visit);
    return sortedItems;
}
function buildTopologicallySortedChunkGraph(chunks) {
    var _a;
    const vertices = new Set();
    const edges = new Map();
    // Chunks should have *all* chunks, not simply entry chunks
    for (const vertex of chunks) {
        if ((0, util_1.addIfNotExist)(vertices, vertex)) {
            continue;
        }
        edges.set(vertex, new Set());
        for (const childChunk of (0, util_1.allChunksInChunkIterable)(vertex)) {
            (_a = edges.get(vertex)) === null || _a === void 0 ? void 0 : _a.add(childChunk);
        }
    }
    const dag = (0, scc_1.createDAGfromGraph)({ vertices, edges });
    const sortedVertices = topologicalSort(dag);
    const chunkToSccMap = new Map((0, util_1.flatMap)(dag.vertices, (scc) => (0, util_1.map)(scc.nodes, (chunk) => [chunk, scc])));
    return [sortedVertices, dag, chunkToSccMap];
}
class ChunkToManifestMapBuilder {
    constructor(chunks) {
        // This map tracks which hashes a chunk group has in its manifest and the intersection
        // of all its parents (and intersection of all their parents, etc.)
        // This is meant as a guarantee that the hash for a given chunk is handled by a chunk group
        // or its parents regardless of the tree traversal used from the roots
        this.hashesByChunkGroupAndParents = new Map();
        const [sortedVertices, , chunkToSccMap] = buildTopologicallySortedChunkGraph(chunks);
        this.sortedVertices = sortedVertices;
        this.chunkToSccMap = chunkToSccMap;
        this.manifest = this.createManifest();
    }
    build() {
        return [this.sortedVertices, this.manifest];
    }
    createManifest() {
        // A map of what child chunks a given chunk should contain hashes for
        // We want to walk from the root nodes down to the leaves
        return this.sortedVertices.reduceRight((manifest, vertex) => {
            for (const chunk of vertex.nodes) {
                manifest.set(chunk, this.createChunkManifest(chunk));
            }
            return manifest;
        }, new Map());
    }
    createChunkManifest(chunk) {
        const manifest = this.getChildChunksToAddToChunkManifest(chunk);
        for (const manifestEntry of this.findIntersectionOfParentSets(chunk)) {
            manifest.delete(manifestEntry);
        }
        const combinedParentManifest = this.findIntersectionOfParentSets(chunk);
        for (const chunk of manifest) {
            if (combinedParentManifest.has(chunk)) {
                manifest.delete(chunk);
            }
            else {
                combinedParentManifest.add(chunk);
            }
        }
        this.addGroupCombinedManifest(chunk, manifest);
        return manifest;
    }
    addGroupCombinedManifest(chunk, manifest) {
        var _a;
        for (const group of chunk.groupsIterable) {
            this.hashesByChunkGroupAndParents.set(group, (0, util_1.unionSet)(
            // Intersection of all parent manifests
            (0, util_1.intersect)((0, util_1.map)(group.parentsIterable, (parent) => {
                var _a;
                return (_a = this.hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set();
            })), 
            // Add this chunk's manifest
            manifest, 
            // Add any existing manifests part of the group
            (_a = this.hashesByChunkGroupAndParents.get(group)) !== null && _a !== void 0 ? _a : new Set()));
        }
    }
    findIntersectionOfParentSets(chunk) {
        var _a;
        const setsToIntersect = [];
        for (const group of chunk.groupsIterable) {
            for (const parent of group.parentsIterable) {
                setsToIntersect.push((_a = this.hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set());
            }
        }
        return (0, util_1.intersectSets)(setsToIntersect);
    }
    getChildChunksToAddToChunkManifest(chunk) {
        var _a;
        const childChunks = new Set();
        const chunkSCC = this.chunkToSccMap.get(chunk);
        for (const childChunk of (0, util_1.allChunksInPrimaryChunkIterable)(chunk)) {
            const childChunkSCC = this.chunkToSccMap.get(childChunk);
            if (childChunkSCC === chunkSCC) {
                // Don't include your own SCC.
                // Your parent will have the hashes for your SCC siblings
                continue;
            }
            for (const childChunkSccNode of (_a = childChunkSCC === null || childChunkSCC === void 0 ? void 0 : childChunkSCC.nodes) !== null && _a !== void 0 ? _a : []) {
                childChunks.add(childChunkSccNode);
            }
        }
        return childChunks;
    }
}
function getChunkToManifestMap(chunks) {
    return new ChunkToManifestMapBuilder(chunks).build();
}
exports.getChunkToManifestMap = getChunkToManifestMap;
class AddLazySriRuntimeModule extends webpack_1.RuntimeModule {
    constructor(sriHashes, chunkName) {
        super(`webpack-subresource-integrity lazy hashes for direct children of chunk ${chunkName}`);
        this.sriHashes = sriHashes;
    }
    generate() {
        return webpack_1.Template.asString([
            `Object.assign(${util_1.sriHashVariableReference}, ${JSON.stringify(this.sriHashes)});`,
        ]);
    }
}
exports.AddLazySriRuntimeModule = AddLazySriRuntimeModule;
//# sourceMappingURL=manifest.js.map