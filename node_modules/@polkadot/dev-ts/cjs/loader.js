"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.load = void 0;
const tslib_1 = require("tslib");
const node_crypto_1 = tslib_1.__importDefault(require("node:crypto"));
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const node_url_1 = require("node:url");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const common_js_1 = require("./common.js");
/**
 * Load all TypeScript files, compile via tsc on-the-fly
 **/
async function load(url, context, nextLoad) {
    if (common_js_1.EXT_TS_REGEX.test(url)) {
        // used the chained loaders to retrieve
        const { source } = await nextLoad(url, {
            ...context,
            format: 'module'
        });
        // we use a hash of the source to determine caching
        const sourceHash = `//# sourceHash=${node_crypto_1.default.createHash('sha256').update(source).digest('hex')}`;
        const compiledFile = url.includes('/src/')
            ? (0, node_url_1.fileURLToPath)(url
                .replace(/\.tsx?$/, '.js')
                .replace('/src/', '/build-loader/'))
            : null;
        if (common_js_1.loaderOptions.isCached && compiledFile && node_fs_1.default.existsSync(compiledFile)) {
            const compiled = node_fs_1.default.readFileSync(compiledFile, 'utf-8');
            if (compiled.includes(sourceHash)) {
                return {
                    format: 'module',
                    source: compiled
                };
            }
        }
        // compile via typescript
        const { outputText } = typescript_1.default.transpileModule(source.toString(), {
            compilerOptions: {
                ...(url.endsWith('.tsx')
                    ? { jsx: typescript_1.default.JsxEmit.ReactJSX }
                    : {}),
                esModuleInterop: true,
                importHelpers: true,
                inlineSourceMap: true,
                module: typescript_1.default.ModuleKind.ESNext,
                moduleResolution: typescript_1.default.ModuleResolutionKind.NodeNext,
                skipLibCheck: true,
                // Aligns with scripts/polkadot-dev-build-ts & config/tsconfig
                target: typescript_1.default.ScriptTarget.ES2020
            },
            fileName: (0, node_url_1.fileURLToPath)(url)
        });
        if (common_js_1.loaderOptions.isCached && compiledFile) {
            const compiledDir = node_path_1.default.dirname(compiledFile);
            if (!node_fs_1.default.existsSync(compiledDir)) {
                node_fs_1.default.mkdirSync(compiledDir, { recursive: true });
            }
            node_fs_1.default.writeFileSync(compiledFile, `${outputText}\n${sourceHash}`, 'utf-8');
        }
        return {
            format: 'module',
            source: outputText
        };
    }
    return nextLoad(url, context);
}
exports.load = load;
