"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsAliases = void 0;
const tslib_1 = require("tslib");
const json5_1 = tslib_1.__importDefault(require("json5"));
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const node_url_1 = require("node:url");
const common_js_1 = require("./common.js");
/**
 * @internal
 *
 * Extracts the (relevant) tsconfig info, also using extends
 **/
function readConfigFile(currentPath = common_js_1.CWD_PATH, tsconfig = 'tsconfig.json', fromFile) {
    const configFile = node_path_1.default.join(currentPath, tsconfig);
    if (!node_fs_1.default.existsSync(configFile)) {
        console.warn(`No ${configFile}${fromFile ? ` (extended from ${fromFile})` : ''} found, assuming defaults`);
        return { paths: {} };
    }
    try {
        const { compilerOptions, extends: parentConfig } = json5_1.default.parse(node_fs_1.default.readFileSync(configFile, 'utf8'));
        let url;
        if (compilerOptions?.baseUrl) {
            const configDir = node_path_1.default.dirname(configFile);
            // the baseParentUrl is relative to the actual config file
            url = (0, node_url_1.pathToFileURL)(node_path_1.default.join(configDir, `${compilerOptions.baseUrl}/`));
        }
        // empty paths if none are found
        let paths = compilerOptions?.paths || {};
        if (parentConfig) {
            const allExtends = Array.isArray(parentConfig)
                ? parentConfig
                : [parentConfig];
            for (const extendsPath of allExtends) {
                const extRoot = extendsPath.startsWith('.')
                    ? currentPath
                    : common_js_1.MOD_PATH;
                const extSubs = extendsPath.split(/[\\/]/);
                const extPath = node_path_1.default.join(extRoot, ...extSubs.slice(0, -1));
                const extConfig = readConfigFile(extPath, extSubs.at(-1), configFile);
                // base configs are overridden by later configs, order here matters
                // FIXME The paths would be relative to the baseUrl at that point... for
                // now we don't care much since we define these 2 together in all @polkadot
                // configs, but it certainly _may_ create and issue at some point (for others)
                paths = { ...extConfig.paths, ...paths };
                url = url || extConfig.url;
            }
        }
        return url
            ? { paths, url }
            : { paths };
    }
    catch (error) {
        console.error(`FATAL: Error parsing ${configFile}:: ${error.message}`);
        throw error;
    }
}
/**
 * @internal
 *
 * Retrieves all TS aliases definitions
 **/
function extractAliases() {
    const { paths, url = common_js_1.CWD_URL } = readConfigFile();
    return Object
        .entries(paths)
        .filter((kv) => !!kv[1].length)
        // TODO The path value is an array - we only handle the first entry in there,
        // this is a possible fix into the future if it is ever an issue... (may have
        // some impacts on the actual loader where only 1 alias is retrieved)
        .map(([key, [path]]) => {
        const filter = key.split(/[\\/]/);
        const isWildcard = filter.at(-1) === '*';
        // ensure that when we have wilcards specified, they always occur in the last position
        if (filter.filter((f) => f.includes('*')).length !== (isWildcard ? 1 : 0)) {
            throw new Error(`FATAL: Wildcards in tsconfig.json path entries are only supported in the last position. Invalid ${key}: ${path} mapping`);
        }
        return {
            filter: isWildcard
                ? filter.slice(0, -1)
                : filter,
            isWildcard,
            path,
            url
        };
    });
}
/** We only export the aliases from the config */
exports.tsAliases = extractAliases();
