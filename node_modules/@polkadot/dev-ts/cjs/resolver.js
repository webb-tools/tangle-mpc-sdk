"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolve = exports.resolveAlias = exports.resolveNonAlias = exports.resolveExtBare = exports.resolveExtJson = exports.resolveExtJs = exports.resolveExtTs = void 0;
const tslib_1 = require("tslib");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const node_url_1 = require("node:url");
const common_js_1 = require("./common.js");
const tsconfig_js_1 = require("./tsconfig.js");
/**
 * @internal
 *
 * From a specified URL, extract the actual full path as well as the
 * directory that this path reflects (either equivalent to path or the
 * root of the file being referenced)
 */
function getParentPath(parentUrl) {
    const parentPath = (0, node_url_1.fileURLToPath)(parentUrl);
    return {
        parentDir: node_fs_1.default.existsSync(parentPath) && node_fs_1.default.lstatSync(parentPath).isDirectory()
            ? parentPath
            : node_path_1.default.dirname(parentPath),
        parentPath
    };
}
/**
 * @internal
 *
 * Resolve fully-specified imports with extensions.
 **/
function resolveExtTs(specifier, parentUrl) {
    // handle .ts extensions directly
    if (common_js_1.EXT_TS_REGEX.test(specifier)) {
        return {
            format: 'module',
            shortCircuit: true,
            url: new node_url_1.URL(specifier, parentUrl).href
        };
    }
}
exports.resolveExtTs = resolveExtTs;
/**
 * @internal
 *
 * Resolve fully-specified imports with extensions. Here we cater for the TS
 * mapping of import foo from './bar.js' where only './bar.ts' exists
 **/
function resolveExtJs(specifier, parentUrl) {
    // handle ts imports where import *.js -> *.ts
    // (unlike the ts resolution, we only cater for relative paths)
    if (specifier.startsWith('.') && common_js_1.EXT_JS_REGEX.test(specifier)) {
        const full = (0, node_url_1.fileURLToPath)(new node_url_1.URL(specifier, parentUrl));
        // when it doesn't exist, we try and see if a source replacement helps
        if (!node_fs_1.default.existsSync(full)) {
            const found = common_js_1.EXT_TS_ARRAY
                .map((e) => full.replace(common_js_1.EXT_JS_REGEX, e))
                .find((f) => node_fs_1.default.existsSync(f) && node_fs_1.default.lstatSync(f).isFile());
            if (found) {
                return {
                    format: 'module',
                    shortCircuit: true,
                    url: (0, node_url_1.pathToFileURL)(found).href
                };
            }
        }
    }
}
exports.resolveExtJs = resolveExtJs;
/**
 * @internal
 *
 * Resolution for Json files. Generally these would be via path aliasing.
 */
function resolveExtJson(specifier, parentUrl) {
    if (specifier.startsWith('.') && common_js_1.EXT_JSON_REGEX.test(specifier)) {
        const { parentDir } = getParentPath(parentUrl);
        const jsonPath = node_path_1.default.join(parentDir, specifier);
        if (node_fs_1.default.existsSync(jsonPath)) {
            return {
                // .json needs to be in 'json' format for the loader, for the
                // the rest (it should only be TS) we use the 'module' format
                format: 'json',
                shortCircuit: true,
                url: (0, node_url_1.pathToFileURL)(jsonPath).href
            };
        }
    }
}
exports.resolveExtJson = resolveExtJson;
/**
 * @internal
 *
 * Resolve relative (extensionless) paths.
 *
 * At some point we probably might need to extend this to cater for the
 * ts (recommended) approach for using .js extensions inside the sources.
 * However, since we don't use this in the polkadot-js code, can kick this
 * down the line
 **/
function resolveExtBare(specifier, parentUrl) {
    if (specifier.startsWith('.')) {
        const { parentDir, parentPath } = getParentPath(parentUrl);
        const found = specifier === '.'
            ? (
            // handle . imports for <dir>/index.ts
            common_js_1.EXT_TS_ARRAY
                .map((e) => node_path_1.default.join(parentDir, `index${e}`))
                .find((f) => node_fs_1.default.existsSync(f)) ||
                // handle the case where parentUrl needs an extension (generally via alias)
                common_js_1.EXT_TS_ARRAY
                    .map((e) => `${parentPath}${e}`)
                    .find((f) => node_fs_1.default.existsSync(f)))
            : (
            // tests to see if this is a file (without extension)
            common_js_1.EXT_TS_ARRAY
                .map((e) => node_path_1.default.join(parentDir, `${specifier}${e}`))
                .find((f) => node_fs_1.default.existsSync(f)) ||
                // test to see if this is a directory
                common_js_1.EXT_TS_ARRAY
                    .map((e) => node_path_1.default.join(parentDir, `${specifier}/index${e}`))
                    .find((f) => node_fs_1.default.existsSync(f)));
        if (found) {
            return {
                format: 'module',
                shortCircuit: true,
                url: (0, node_url_1.pathToFileURL)(found).href
            };
        }
    }
}
exports.resolveExtBare = resolveExtBare;
/**
 * @internal
 *
 * Resolve anything that is not an alias
 **/
function resolveNonAlias(specifier, parentUrl) {
    return (resolveExtTs(specifier, parentUrl) ||
        resolveExtJs(specifier, parentUrl) ||
        resolveExtJson(specifier, parentUrl) ||
        resolveExtBare(specifier, parentUrl));
}
exports.resolveNonAlias = resolveNonAlias;
/**
 * @internal
 *
 * Resolve TS alias mappings as defined in the tsconfig.json file
 **/
function resolveAlias(specifier, _parentUrl, aliases = tsconfig_js_1.tsAliases) {
    const parts = specifier.split(/[\\/]/);
    const found = aliases
        // return a [filter, [...partIndex]] mapping
        .map((alias) => ({
        alias,
        indexes: parts
            .map((_, i) => i)
            .filter((start) => (alias.isWildcard
            // parts should have more entries than the wildcard
            ? parts.length > alias.filter.length
            // or the same amount in case of a non-wildcard match
            : parts.length === alias.filter.length) &&
            // match all parts of the alias
            alias.filter.every((f, i) => parts[start + i] &&
                parts[start + i] === f))
    }))
        // we only return the first
        .find(({ indexes }) => indexes.length);
    if (found) {
        // do the actual un-aliased resolution
        return resolveNonAlias(`./${found.alias.path.replace('*', node_path_1.default.join(...parts.slice(found.alias.filter.length)))}`, found.alias.url);
    }
}
exports.resolveAlias = resolveAlias;
/**
 * Resolves a path using our logic.
 *
 * 1. First we attempt to directly resolve if .ts/.tsx extension is found
 * 2. Then we do relative resolves (this is for extension-less .ts files)
 * 3. The we try to do resolution via TS aliases
 *
 * ... finally, try the next loader in the chain
 */
function resolve(specifier, context, nextResolve) {
    const parentUrl = context.parentURL || common_js_1.CWD_URL;
    return (resolveNonAlias(specifier, parentUrl) ||
        resolveAlias(specifier, parentUrl) ||
        nextResolve(specifier, context));
}
exports.resolve = resolve;
