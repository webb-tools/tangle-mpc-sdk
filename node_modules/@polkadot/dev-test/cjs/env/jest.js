"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jest = void 0;
const node_test_1 = require("node:test");
const util_js_1 = require("../util.js");
const JEST_KEYS_STUB = ['advanceTimersByTime', 'advanceTimersToNextTimer', 'autoMockOff', 'autoMockOn', 'clearAllMocks', 'clearAllTimers', 'createMockFromModule', 'deepUnmock', 'disableAutomock', 'doMock', 'dontMock', 'enableAutomock', 'fn', 'genMockFromModule', 'getRealSystemTime', 'getSeed', 'getTimerCount', 'isEnvironmentTornDown', 'isMockFunction', 'isolateModules', 'isolateModulesAsync', 'mock', 'mocked', 'now', 'replaceProperty', 'requireActual', 'requireMock', 'resetAllMocks', 'resetModules', 'restoreAllMocks', 'retryTimes', 'runAllImmediates', 'runAllTicks', 'runAllTimers', 'runOnlyPendingTimers', 'setMock', 'setSystemTime', 'setTimeout', 'spyOn', 'unmock', 'unstable_mockModule', 'useFakeTimers', 'useRealTimers'];
const JEST_KEYS_WARN = ['setTimeout'];
const MOCK_KEYS_STUB = ['_isMockFunction', 'getMockImplementation', 'getMockName', 'mock', 'mockClear', 'mockImplementation', 'mockImplementationOnce', 'mockName', 'mockRejectedValue', 'mockRejectedValueOnce', 'mockReset', 'mockResolvedValue', 'mockResolvedValueOnce', 'mockRestore', 'mockReturnThis', 'mockReturnValue', 'mockReturnValueOnce', 'withImplementation'];
const jestStub = (0, util_js_1.stubObj)('jest', JEST_KEYS_STUB);
const jestWarn = (0, util_js_1.warnObj)('jest', JEST_KEYS_WARN);
const mockStub = (0, util_js_1.stubObj)('jest.fn()', MOCK_KEYS_STUB);
/**
 * @internal
 *
 * This adds the mockReset and mockRestore functionality to any
 * spy or mock function
 **/
function extendMock(mocked) {
    // We use the node:test mock here for casting below - however we
    // don't want this in any method signature since this is a private
    // types export, which could get us in "some" trouble
    //
    // Effectively the casts below ensure that our WithMock<*> aligns
    // on a high-level to what we use via private type...
    const spy = mocked;
    return (0, util_js_1.enhanceObj)((0, util_js_1.enhanceObj)(mocked, {
        mockImplementation: (fn) => {
            spy.mock.mockImplementation(fn);
        },
        mockImplementationOnce: (fn) => {
            spy.mock.mockImplementationOnce(fn);
        },
        mockReset: () => {
            spy.mock.resetCalls();
        },
        mockRestore: () => {
            spy.mock.restore();
        }
    }), mockStub);
}
/**
 * Sets up the jest object. This is certainly not extensive, and probably
 * not quite meant to be (never say never). Rather this adds the functionality
 * that we use in the polkadot-js projects.
 **/
function jest() {
    return {
        jest: (0, util_js_1.enhanceObj)((0, util_js_1.enhanceObj)({
            fn: (fn) => extendMock(node_test_1.mock.fn(fn)),
            restoreAllMocks: () => {
                node_test_1.mock.reset();
            },
            spyOn: (obj, key) => extendMock(node_test_1.mock.method(obj, key))
        }, jestWarn), jestStub)
    };
}
exports.jest = jest;
