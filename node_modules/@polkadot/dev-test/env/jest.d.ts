import type { AnyFn } from '../types.js';
/**
 * Sets up the jest object. This is certainly not extensive, and probably
 * not quite meant to be (never say never). Rather this adds the functionality
 * that we use in the polkadot-js projects.
 **/
export declare function jest(): {
    jest: {
        fn: <F extends AnyFn>(fn?: F | undefined) => F & {
            mock: {
                calls: {
                    arguments: unknown[];
                }[];
                mockImplementation: (fn: AnyFn) => void;
                mockImplementationOnce: (fn: AnyFn) => void;
                resetCalls: () => void;
                restore: () => void;
            };
        } & Omit<{
            mockImplementation: <F_1 extends AnyFn>(fn: F_1) => void;
            mockImplementationOnce: <F_2 extends AnyFn>(fn: F_2) => void;
            mockReset: () => void;
            mockRestore: () => void;
        }, "mock" | keyof F> & Omit<{
            mock: import("../types.js").StubFn;
            _isMockFunction: import("../types.js").StubFn;
            getMockImplementation: import("../types.js").StubFn;
            getMockName: import("../types.js").StubFn;
            mockClear: import("../types.js").StubFn;
            mockImplementation: import("../types.js").StubFn;
            mockImplementationOnce: import("../types.js").StubFn;
            mockName: import("../types.js").StubFn;
            mockRejectedValue: import("../types.js").StubFn;
            mockRejectedValueOnce: import("../types.js").StubFn;
            mockReset: import("../types.js").StubFn;
            mockResolvedValue: import("../types.js").StubFn;
            mockResolvedValueOnce: import("../types.js").StubFn;
            mockRestore: import("../types.js").StubFn;
            mockReturnThis: import("../types.js").StubFn;
            mockReturnValue: import("../types.js").StubFn;
            mockReturnValueOnce: import("../types.js").StubFn;
            withImplementation: import("../types.js").StubFn;
        }, "mock" | keyof F | Exclude<"mockImplementation", "mock" | keyof F> | Exclude<"mockImplementationOnce", "mock" | keyof F> | Exclude<"mockReset", "mock" | keyof F> | Exclude<"mockRestore", "mock" | keyof F>>;
        restoreAllMocks: () => void;
        spyOn: <F_3 extends AnyFn>(obj: object, key: string) => F_3 & {
            mock: {
                calls: {
                    arguments: unknown[];
                }[];
                mockImplementation: (fn: AnyFn) => void;
                mockImplementationOnce: (fn: AnyFn) => void;
                resetCalls: () => void;
                restore: () => void;
            };
        } & Omit<{
            mockImplementation: <F_4 extends AnyFn>(fn: F_4) => void;
            mockImplementationOnce: <F_5 extends AnyFn>(fn: F_5) => void;
            mockReset: () => void;
            mockRestore: () => void;
        }, "mock" | keyof F_3> & Omit<{
            mock: import("../types.js").StubFn;
            _isMockFunction: import("../types.js").StubFn;
            getMockImplementation: import("../types.js").StubFn;
            getMockName: import("../types.js").StubFn;
            mockClear: import("../types.js").StubFn;
            mockImplementation: import("../types.js").StubFn;
            mockImplementationOnce: import("../types.js").StubFn;
            mockName: import("../types.js").StubFn;
            mockRejectedValue: import("../types.js").StubFn;
            mockRejectedValueOnce: import("../types.js").StubFn;
            mockReset: import("../types.js").StubFn;
            mockResolvedValue: import("../types.js").StubFn;
            mockResolvedValueOnce: import("../types.js").StubFn;
            mockRestore: import("../types.js").StubFn;
            mockReturnThis: import("../types.js").StubFn;
            mockReturnValue: import("../types.js").StubFn;
            mockReturnValueOnce: import("../types.js").StubFn;
            withImplementation: import("../types.js").StubFn;
        }, "mock" | keyof F_3 | Exclude<"mockImplementation", "mock" | keyof F_3> | Exclude<"mockImplementationOnce", "mock" | keyof F_3> | Exclude<"mockReset", "mock" | keyof F_3> | Exclude<"mockRestore", "mock" | keyof F_3>>;
    } & Omit<{
        setTimeout: import("../types.js").StubFn;
    }, "fn" | "restoreAllMocks" | "spyOn"> & Omit<{
        setTimeout: import("../types.js").StubFn;
        mock: import("../types.js").StubFn;
        advanceTimersByTime: import("../types.js").StubFn;
        advanceTimersToNextTimer: import("../types.js").StubFn;
        autoMockOff: import("../types.js").StubFn;
        autoMockOn: import("../types.js").StubFn;
        clearAllMocks: import("../types.js").StubFn;
        clearAllTimers: import("../types.js").StubFn;
        createMockFromModule: import("../types.js").StubFn;
        deepUnmock: import("../types.js").StubFn;
        disableAutomock: import("../types.js").StubFn;
        doMock: import("../types.js").StubFn;
        dontMock: import("../types.js").StubFn;
        enableAutomock: import("../types.js").StubFn;
        fn: import("../types.js").StubFn;
        genMockFromModule: import("../types.js").StubFn;
        getRealSystemTime: import("../types.js").StubFn;
        getSeed: import("../types.js").StubFn;
        getTimerCount: import("../types.js").StubFn;
        isEnvironmentTornDown: import("../types.js").StubFn;
        isMockFunction: import("../types.js").StubFn;
        isolateModules: import("../types.js").StubFn;
        isolateModulesAsync: import("../types.js").StubFn;
        mocked: import("../types.js").StubFn;
        now: import("../types.js").StubFn;
        replaceProperty: import("../types.js").StubFn;
        requireActual: import("../types.js").StubFn;
        requireMock: import("../types.js").StubFn;
        resetAllMocks: import("../types.js").StubFn;
        resetModules: import("../types.js").StubFn;
        restoreAllMocks: import("../types.js").StubFn;
        retryTimes: import("../types.js").StubFn;
        runAllImmediates: import("../types.js").StubFn;
        runAllTicks: import("../types.js").StubFn;
        runAllTimers: import("../types.js").StubFn;
        runOnlyPendingTimers: import("../types.js").StubFn;
        setMock: import("../types.js").StubFn;
        setSystemTime: import("../types.js").StubFn;
        spyOn: import("../types.js").StubFn;
        unmock: import("../types.js").StubFn;
        unstable_mockModule: import("../types.js").StubFn;
        useFakeTimers: import("../types.js").StubFn;
        useRealTimers: import("../types.js").StubFn;
    }, "setTimeout" | "fn" | "restoreAllMocks" | "spyOn">;
};
