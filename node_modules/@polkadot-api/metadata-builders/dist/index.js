"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  getChecksumBuilder: () => getChecksumBuilder,
  getDynamicBuilder: () => getDynamicBuilder,
  getLookupFn: () => getLookupFn,
  getStaticBuilder: () => getStaticBuilder,
  getViewBuilder: () => getViewBuilder,
  primitiveTypes: () => primitiveTypes
});
module.exports = __toCommonJS(src_exports);

// src/lookups.ts
var voidVar = { type: "primitive", value: "_void" };
var getLookupFn = (lookupData) => {
  const lookups = /* @__PURE__ */ new Map();
  const from = /* @__PURE__ */ new Set();
  const withCache2 = (fn) => {
    return (id) => {
      let entry = lookups.get(id);
      if (entry)
        return entry;
      if (from.has(id)) {
        const entry2 = {
          id
        };
        lookups.set(id, entry2);
        return entry2;
      }
      from.add(id);
      const value = fn(id);
      entry = lookups.get(id);
      if (entry) {
        Object.assign(entry, value);
      } else {
        entry = {
          id,
          ...value
        };
        lookups.set(id, entry);
      }
      from.delete(id);
      return entry;
    };
  };
  const getLookupEntryDef = withCache2((id) => {
    const { def } = lookupData[id];
    if (def.tag === "composite") {
      if (def.value.length === 0)
        return voidVar;
      if (def.value.length === 1)
        return getLookupEntryDef(def.value[0].type);
      let allKey = true;
      const values = {};
      const innerDocs = {};
      def.value.forEach((x, idx) => {
        allKey = allKey && !!x.name;
        const key = x.name || idx;
        values[key] = getLookupEntryDef(x.type);
        innerDocs[key] = x.docs;
      });
      return allKey ? {
        type: "struct",
        value: values,
        innerDocs
      } : {
        type: "tuple",
        value: Object.values(values),
        innerDocs: Object.values(innerDocs)
      };
    }
    if (def.tag === "variant") {
      if (def.value.length === 0)
        return voidVar;
      const enumValue = {};
      const enumDocs = {};
      def.value.forEach((x) => {
        const key = x.name;
        enumDocs[key] = x.docs;
        if (x.fields.length === 0) {
          enumValue[key] = { ...voidVar, idx: x.index };
          return;
        }
        let allKey = true;
        const values = {};
        const innerDocs = {};
        x.fields.forEach((x2, idx) => {
          allKey = allKey && !!x2.name;
          const key2 = x2.name || idx;
          values[key2] = getLookupEntryDef(x2.type);
          innerDocs[key2] = x2.docs;
        });
        enumValue[key] = allKey ? {
          type: "struct",
          value: values,
          innerDocs,
          idx: x.index
        } : {
          type: "tuple",
          value: Object.values(values),
          innerDocs: Object.values(innerDocs),
          idx: x.index
        };
      });
      return {
        type: "enum",
        value: enumValue,
        innerDocs: enumDocs
      };
    }
    if (def.tag === "sequence") {
      const value2 = getLookupEntryDef(def.value);
      return {
        type: "sequence",
        value: value2
      };
    }
    if (def.tag === "array") {
      const value2 = getLookupEntryDef(def.value.type);
      return {
        type: "array",
        value: value2,
        len: def.value.len
      };
    }
    if (def.tag === "tuple") {
      if (def.value.length === 0)
        return voidVar;
      if (def.value.length === 1)
        return getLookupEntryDef(def.value[0]);
      const value2 = def.value.map((x) => getLookupEntryDef(x));
      const innerDocs = def.value.map((x) => lookupData[x].docs);
      return {
        type: "tuple",
        value: value2,
        innerDocs
      };
    }
    if (def.tag === "primitive") {
      return {
        type: "primitive",
        value: def.value.tag
      };
    }
    if (def.tag === "compact") {
      const translated = getLookupEntryDef(def.value);
      const isBig = Number(translated.value.slice(1)) > 32;
      return {
        type: "compact",
        isBig
      };
    }
    if (def.tag === "bitSequence") {
      return { type: "bitSequence" };
    }
    const value = def.value;
    return {
      type: "primitive",
      value
    };
  });
  return getLookupEntryDef;
};

// src/with-cache.ts
var withCache = (fn, onEnterCircular, onExitCircular) => (input, cache, stack, ...rest) => {
  const { id } = input;
  if (cache.has(id))
    return cache.get(id);
  if (stack.has(id)) {
    const res = onEnterCircular(() => cache.get(id), input, ...rest);
    cache.set(id, res);
    return res;
  }
  stack.add(id);
  let result = fn(input, cache, stack, ...rest);
  stack.delete(id);
  if (cache.has(id))
    result = onExitCircular(result, cache.get(id), input, ...rest);
  cache.set(id, result);
  return result;
};

// src/static-builder.ts
var primitiveTypes = {
  _void: "undefined",
  bool: "boolean",
  char: "string",
  str: "string",
  u8: "number",
  u16: "number",
  u32: "number",
  u64: "bigint",
  u128: "bigint",
  u256: "bigint",
  i8: "number",
  i16: "number",
  i32: "number",
  i64: "bigint",
  i128: "bigint",
  i256: "bigint",
  compactNumber: "number",
  compactBn: "bigint",
  bitSequence: "{bitsLen: number, bytes: Uint8Array}",
  historicMetaCompat: "any"
};
var toCamelCase = (...parts) => parts[0] + parts.slice(1).map((part) => part[0].toUpperCase() + part.slice(1)).join("");
var isBytes = (input) => input.type === "primitive" && input.value === "u8";
var getTypes = (varName) => primitiveTypes[varName] ?? `I${varName}`;
var _buildSyntax = (input, cache, stack, declarations, getVarName) => {
  if (input.type === "primitive") {
    declarations.imports.add(input.value);
    return input.value;
  }
  if (input.type === "compact") {
    const importVal = input.isBig ? "compactBn" : "compactNumber";
    declarations.imports.add(importVal);
    return importVal;
  }
  if (input.type === "bitSequence") {
    declarations.imports.add(input.type);
    return input.type;
  }
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    declarations.imports.add("Hex");
    declarations.typeImports.add("HexString");
    const variable = {
      id: "_bytesSeq",
      value: "Hex()",
      types: "HexString",
      directDependencies: /* @__PURE__ */ new Set()
    };
    if (!declarations.variables.has(variable.id)) {
      declarations.variables.set(variable.id, variable);
    }
    return variable.id;
  }
  if (declarations.variables.has(getVarName(input.id, "circular")))
    return getVarName(input.id, "circular");
  if (declarations.variables.has(getVarName(input.id)))
    return getVarName(input.id);
  const buildNextSyntax = (nextInput) => buildSyntax(nextInput, cache, stack, declarations, getVarName);
  const buildVector = (id, inner, len) => {
    declarations.imports.add("Vector");
    const dependsVar = buildNextSyntax(inner);
    const args = len ? [dependsVar, len] : [dependsVar];
    const variable = {
      id,
      value: `Vector(${args.join(", ")})`,
      types: `Array<${getTypes(dependsVar)}>`,
      directDependencies: /* @__PURE__ */ new Set([dependsVar])
    };
    declarations.variables.set(id, variable);
    return id;
  };
  const buildTuple = (id, value) => {
    declarations.imports.add("Tuple");
    const deps = value.map(buildNextSyntax);
    const variable = {
      id,
      value: `Tuple(${deps.join(", ")})`,
      types: `[${deps.map(getTypes).join(", ")}]`,
      directDependencies: new Set(deps)
    };
    declarations.variables.set(id, variable);
    return id;
  };
  const buildStruct = (id, value) => {
    declarations.imports.add("Struct");
    const deps = Object.values(value).map(buildNextSyntax);
    const variable = {
      id,
      value: `Struct({${Object.keys(value).map((key, idx) => `${key}: ${deps[idx]}`).join(", ")}})`,
      types: `{${Object.keys(value).map((key, idx) => `${key}: ${getTypes(deps[idx])}`).join(", ")}}`,
      directDependencies: new Set(deps)
    };
    declarations.variables.set(id, variable);
    return id;
  };
  const varId = getVarName(input.id);
  if (input.type === "array") {
    if (isBytes(input.value)) {
      if (input.len === 32 && (input.id === 0 || input.id === 1)) {
        declarations.imports.add("AccountId");
        const id = "_accountId";
        declarations.variables.set(id, {
          id,
          value: `AccountId()`,
          types: "SS58String",
          directDependencies: /* @__PURE__ */ new Set()
        });
        declarations.typeImports.add("SS58String");
        return id;
      }
      declarations.imports.add("Hex");
      declarations.variables.set(varId, {
        id: varId,
        value: `Hex(${input.len})`,
        types: "HexString",
        directDependencies: /* @__PURE__ */ new Set()
      });
      declarations.typeImports.add("HexString");
      return varId;
    }
    return buildVector(varId, input.value, input.len);
  }
  if (input.type === "sequence")
    return buildVector(varId, input.value);
  if (input.type === "tuple")
    return buildTuple(varId, input.value);
  if (input.type === "struct")
    return buildStruct(varId, input.value);
  declarations.imports.add("Enum");
  const dependencies = Object.entries(input.value).map(([key, value]) => {
    if (value.type === "primitive") {
      declarations.imports.add(value.value);
      return value.value;
    }
    const varName = toCamelCase(varId, key);
    if (value.type === "tuple") {
      if (value.value.length === 1) {
        let result;
        const innerVal = value.value[0];
        if (key.startsWith("Raw") && innerVal.type === "array" && isBytes(innerVal.value)) {
          const id = `_fixedStr${innerVal.len}`;
          result = id;
          if (!declarations.variables.has(id)) {
            declarations.imports.add("fixedStr");
            declarations.variables.set(id, {
              id,
              value: `fixedStr(${innerVal.len})`,
              types: "string",
              directDependencies: /* @__PURE__ */ new Set()
            });
          }
        } else {
          result = buildNextSyntax(value.value[0]);
        }
        if (!declarations.variables.has(varName)) {
          declarations.variables.set(varName, {
            id: varName,
            value: result,
            types: getTypes(result),
            directDependencies: /* @__PURE__ */ new Set([result])
          });
        }
        return varName;
      }
      return buildTuple(varName, value.value);
    } else {
      buildStruct(varName, value.value);
    }
    return varName;
  });
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  const innerEnum = `{${Object.keys(input.value).map(
    (key, idx) => `${key}: ${dependencies[idx]}`
  )}}${areIndexesSorted ? "" : `, [${indexes.join(", ")}]`}`;
  declarations.variables.set(varId, {
    id: varId,
    value: `Enum(${innerEnum})`,
    types: Object.keys(input.value).map(
      (key, idx) => `{tag: '${key}', value: ${getTypes(dependencies[idx])}}`
    ).join(" | "),
    directDependencies: new Set(dependencies)
  });
  return varId;
};
var buildSyntax = withCache(
  _buildSyntax,
  (_getter, entry, declarations, getVarName) => {
    declarations.imports.add("Self");
    const nonCircular = getVarName(entry.id);
    const variable = {
      id: getVarName(entry.id, "circular"),
      types: `I${nonCircular}`,
      value: `Self(() => ${nonCircular})`,
      directDependencies: /* @__PURE__ */ new Set([nonCircular])
    };
    declarations.variables.set(variable.id, variable);
    return variable.id;
  },
  (x) => x
);
var getStaticBuilder = (metadata) => {
  const declarations = {
    imports: /* @__PURE__ */ new Set(),
    typeImports: /* @__PURE__ */ new Set(["Codec"]),
    variables: /* @__PURE__ */ new Map()
  };
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  const getVarName = (idx, ...post) => {
    const { path } = lookupData[idx];
    const parts = path.length === 0 ? ["cdc" + idx] : ["c", ...path];
    parts.push(...post);
    return toCamelCase(...parts);
  };
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildSyntax(
    getLookupEntryDef(id),
    cache,
    /* @__PURE__ */ new Set(),
    declarations,
    getVarName
  );
  const buildNamedTuple = (params, varName) => {
    if (declarations.variables.has(varName))
      return varName;
    const args = params.map((p) => p.type).map(buildDefinition);
    const names = params.map((p) => p.name);
    declarations.imports.add("Tuple");
    const variable = {
      id: varName,
      types: `[${names.map(
        (name, pIdx) => `${name[0].toUpperCase() + name.slice(1)}: ${getTypes(args[pIdx])}`
      ).join(", ")}]`,
      value: `Tuple(${args.join(", ")})`,
      directDependencies: new Set(args)
    };
    declarations.variables.set(varName, variable);
    return varName;
  };
  const EMPTY_TUPLE_VAR_NAME = "_emptyTuple";
  const getEmptyTuple = () => {
    if (!declarations.variables.has(EMPTY_TUPLE_VAR_NAME)) {
      declarations.imports.add("Tuple");
      declarations.variables.set(EMPTY_TUPLE_VAR_NAME, {
        id: EMPTY_TUPLE_VAR_NAME,
        types: `[]`,
        value: `Tuple()`,
        directDependencies: /* @__PURE__ */ new Set()
      });
    }
    return EMPTY_TUPLE_VAR_NAME;
  };
  const buildStorage = (pallet, entry) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    if (storageEntry.type.tag === "plain")
      return {
        key: getEmptyTuple(),
        val: buildDefinition(storageEntry.type.value)
      };
    const { key, value } = storageEntry.type.value;
    const val = buildDefinition(value);
    const returnKey = storageEntry.type.value.hashers.length === 1 ? buildNamedTuple(
      [{ name: "key", type: key }],
      getVarName(key, "Tupled")
    ) : buildDefinition(key);
    return { key: returnKey, val };
  };
  const buildVariant = (type) => (pallet, name) => {
    const eventsLookup = getLookupEntryDef(
      metadata.pallets.find((x) => x.name === pallet)[type]
    );
    if (eventsLookup.type !== "enum")
      throw null;
    const returnVar = toCamelCase(buildDefinition(eventsLookup.id), name);
    if (!declarations.variables.has(returnVar) && eventsLookup.value[name].type === "primitive") {
      declarations.variables.set(returnVar, {
        id: returnVar,
        value: "_void",
        types: "undefined",
        directDependencies: /* @__PURE__ */ new Set()
      });
    }
    return returnVar;
  };
  const buildCall = (pallet, callName) => {
    const callsLookup = getLookupEntryDef(
      metadata.pallets.find((x) => x.name === pallet).calls
    );
    if (callsLookup.type !== "enum")
      throw null;
    const callEntry = callsLookup.value[callName];
    if (callEntry.type === "primitive")
      return getEmptyTuple();
    if (callEntry.type === "tuple")
      return toCamelCase(buildDefinition(callsLookup.id), callName);
    const params = Object.entries(callEntry.value).map(([name, val]) => ({
      name,
      type: val.id
    }));
    return buildNamedTuple(
      params,
      getVarName(callsLookup.id, callName, "Tupled")
    );
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  const getCode = () => {
    const typeImports = `import type {${[...declarations.typeImports].join(
      ", "
    )}} from "@polkadot-api/substrate-bindings";
`;
    const varImports = `import {${[...declarations.imports].join(
      ", "
    )}} from "@polkadot-api/substrate-bindings";

`;
    const code = [...declarations.variables.values()].map((variable) => {
      return `type I${variable.id} = ${variable.types};
const ${variable.id}: Codec<I${variable.id}> = ${variable.value};`;
    }).join("\n\n");
    return `${typeImports}${varImports}${code}`;
  };
  const getTypeFromVarName = (varName) => primitiveTypes[varName] ?? declarations.variables.get(varName)?.types ?? `I${varName}`;
  return {
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildCall,
    buildConstant,
    getTypeFromVarName,
    getCode
  };
};

// src/dynamic-builder.ts
var scale = __toESM(require("@polkadot-api/substrate-bindings"));
var _bytes = scale.Hex();
var isBytes2 = (input) => input.type === "primitive" && input.value === "u8";
var _buildCodec = (input, cache, stack, _accountId) => {
  if (input.type === "primitive")
    return scale[input.value];
  if (input.type === "compact")
    return scale.compact;
  if (input.type === "bitSequence")
    return scale.bitSequence;
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return _bytes;
  }
  const buildNextCodec = (nextInput) => buildCodec(nextInput, cache, stack, _accountId);
  const buildVector = (inner2, len) => {
    const innerCodec = buildNextCodec(inner2);
    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec);
  };
  const buildTuple = (value) => scale.Tuple(...value.map(buildNextCodec));
  const buildStruct = (value) => {
    const inner2 = Object.fromEntries(
      Object.entries(value).map(([key, value2]) => [key, buildNextCodec(value2)])
    );
    return scale.Struct(inner2);
  };
  if (input.type === "array") {
    if (isBytes2(input.value)) {
      return input.len === 32 && (input.id === 0 || input.id === 1) ? _accountId : scale.Hex(input.len);
    }
    return buildVector(input.value, input.len);
  }
  if (input.type === "sequence")
    return buildVector(input.value);
  if (input.type === "tuple")
    return buildTuple(input.value);
  if (input.type === "struct")
    return buildStruct(input.value);
  const dependencies = Object.entries(input.value).map(([k, v]) => {
    if (v.type === "primitive")
      return scale._void;
    if (v.type === "tuple" && v.value.length === 1) {
      const innerVal = v.value[0];
      return k.startsWith("Raw") && innerVal.type === "array" && isBytes2(innerVal.value) ? scale.fixedStr(innerVal.len) : buildNextCodec(innerVal);
    }
    return v.type === "tuple" ? buildTuple(v.value) : buildStruct(v.value);
  });
  const inner = Object.fromEntries(
    Object.keys(input.value).map((key, idx) => {
      return [key, dependencies[idx]];
    })
  );
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  return areIndexesSorted ? scale.Enum(inner) : scale.Enum(inner, indexes);
};
var buildCodec = withCache(_buildCodec, scale.Self, (res) => res);
var emptyTuple = scale.Tuple();
var getDynamicBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  let _accountId = scale.AccountId();
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildCodec(getLookupEntryDef(id), cache, /* @__PURE__ */ new Set(), _accountId);
  const prefix = metadata.pallets.find((x) => x.name === "System")?.constants.find((x) => x.name === "SS58Prefix");
  let ss58Prefix;
  if (prefix) {
    try {
      const prefixVal = buildDefinition(prefix.type).dec(prefix.value);
      if (typeof prefixVal === "number") {
        ss58Prefix = prefixVal;
        _accountId = scale.AccountId(prefixVal);
      }
    } catch (_) {
    }
  }
  const storagePallets = /* @__PURE__ */ new Map();
  const buildStorage = (pallet, entry) => {
    let storagePallet = storagePallets.get(pallet);
    if (!storagePallet)
      storagePallets.set(pallet, storagePallet = scale.Storage(pallet));
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    const storageWithFallback = (len, ...args) => {
      const result = storagePallet(...args);
      return {
        ...result,
        len,
        fallback: storageEntry.modifier === 1 ? result.dec(storageEntry.fallback) : void 0
      };
    };
    if (storageEntry.type.tag === "plain")
      return storageWithFallback(
        0,
        entry,
        buildDefinition(storageEntry.type.value).dec
      );
    const { key, value, hashers } = storageEntry.type.value;
    const val = buildDefinition(value);
    const hashes = hashers.map((x) => scale[x.tag]);
    const hashArgs = hashes.length === 1 ? [[buildDefinition(key), hashes[0]]] : getLookupEntryDef(key).value.map(
      (x, idx) => [
        buildDefinition(x.id),
        hashes[idx]
      ]
    );
    return storageWithFallback(hashes.length, entry, val.dec, ...hashArgs);
  };
  const buildCall = (pallet, callName) => {
    const palletEntry = metadata.pallets.find((x) => x.name === pallet);
    const callsLookup = getLookupEntryDef(palletEntry.calls);
    if (callsLookup.type !== "enum")
      throw null;
    const callEntry = callsLookup.value[callName];
    return {
      location: [palletEntry.index, callEntry.idx],
      args: callEntry.type === "primitive" ? emptyTuple : scale.Tuple(
        ...Object.values(callEntry.value).map(
          (l) => buildDefinition(l.id)
        )
      )
    };
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  const buildVariant = (type) => (pallet, name) => {
    const palletEntry = metadata.pallets.find((x) => x.name === pallet);
    const lookup = getLookupEntryDef(palletEntry[type]);
    if (lookup.type !== "enum")
      throw null;
    const event = lookup.value[name];
    return {
      location: [palletEntry.index, event.idx],
      codec: event.type === "primitive" ? scale._void : buildDefinition(lookup.id)
    };
  };
  return {
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildCall,
    buildConstant,
    ss58Prefix
  };
};

// src/checksum-builder.ts
var import_substrate_bindings = require("@polkadot-api/substrate-bindings");
var textEncoder = new TextEncoder();
var encodeText = textEncoder.encode.bind(textEncoder);
var getChecksum = (values, shape) => {
  const hasShape = typeof shape === "string";
  const res = new Uint8Array((values.length + (hasShape ? 1 : 0)) * 8);
  const dv = new DataView(res.buffer);
  let offset = 0;
  if (hasShape) {
    dv.setBigUint64(offset, (0, import_substrate_bindings.h64)(encodeText(shape)));
    offset += 8;
  }
  for (let i = 0; i < values.length; i++, offset += 8)
    dv.setBigUint64(offset, values[i]);
  return (0, import_substrate_bindings.h64)(res);
};
var primitiveChecksums = {
  _void: 0n,
  bool: 1n,
  char: 2n,
  str: 3n,
  u8: 4n,
  u16: 5n,
  u32: 6n,
  u64: 7n,
  u128: 8n,
  u256: 9n,
  i8: 5n,
  i16: 5n,
  i32: 6n,
  i64: 7n,
  i128: 8n,
  i256: 9n,
  compacts: 10n,
  compactb: 11n,
  bitSequence: 12n,
  historicMetaCompat: 13n
};
var bytesChecksum = 14n;
var _buildChecksum = (input, cache, stack) => {
  if (cache.has(input.id))
    return cache.get(input.id);
  if (input.type === "primitive")
    return primitiveChecksums[input.value];
  if (input.type === "compact")
    return primitiveChecksums[input.isBig ? "compactb" : "compacts"];
  if (input.type === "bitSequence")
    return primitiveChecksums.bitSequence;
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return bytesChecksum;
  }
  const buildNextChecksum = (nextInput) => buildChecksum(nextInput, cache, stack);
  const buildVector = (inner, len) => {
    const innerChecksum = buildNextChecksum(inner);
    return len ? getChecksum([innerChecksum, BigInt(len)], "Vector(,)") : getChecksum([innerChecksum], "Vector()");
  };
  const buildTuple = (value) => getChecksum(value.map(buildNextChecksum));
  const buildStruct = (value) => {
    return getChecksum(
      Object.values(value).map(buildNextChecksum),
      JSON.stringify(Object.keys(value))
    );
  };
  if (input.type === "array")
    return buildVector(input.value, input.len);
  if (input.type === "sequence")
    return buildVector(input.value);
  if (input.type === "tuple")
    return buildTuple(input.value);
  if (input.type === "struct")
    return buildStruct(input.value);
  const dependencies = Object.values(input.value).map((v) => {
    if (v.type === "primitive")
      return 0n;
    return v.type === "tuple" ? buildTuple(v.value) : buildStruct(v.value);
  });
  const keys = Object.keys(input.value);
  keys.push("Enum");
  return getChecksum(dependencies, JSON.stringify({ Enum: keys }));
};
var buildChecksum = withCache(
  _buildChecksum,
  () => 0n,
  (result) => result
);
var getChecksumBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildChecksum(getLookupEntryDef(id), cache, /* @__PURE__ */ new Set());
  const buildStorage = (pallet, entry) => {
    try {
      const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
      if (storageEntry.type.tag === "plain")
        return getChecksum([buildDefinition(storageEntry.type.value)]);
      const { key, value } = storageEntry.type.value;
      const val = buildDefinition(value);
      const returnKey = storageEntry.type.value.hashers.length === 1 ? getChecksum([buildDefinition(key)]) : buildDefinition(key);
      return getChecksum([val, returnKey]);
    } catch (_) {
      return null;
    }
  };
  const buildEnumEntry = (entry) => {
    if (entry.type === "primitive")
      return 0n;
    const values = Object.values(entry.value).map((l) => buildDefinition(l.id));
    return entry.type === "tuple" ? getChecksum(values) : getChecksum(values, JSON.stringify(Object.keys(entry.value)));
  };
  const buildCall = (pallet, callName) => {
    try {
      const palletEntry = metadata.pallets.find((x) => x.name === pallet);
      const callsLookup = getLookupEntryDef(palletEntry.calls);
      if (callsLookup.type !== "enum")
        throw null;
      return buildEnumEntry(callsLookup.value[callName]);
    } catch (_) {
      return null;
    }
  };
  const buildVariant = (variantType) => (pallet, name) => {
    try {
      const palletEntry = metadata.pallets.find((x) => x.name === pallet);
      const callsLookup = getLookupEntryDef(
        palletEntry[variantType]
      );
      if (callsLookup.type !== "enum")
        throw null;
      return buildEnumEntry(callsLookup.value[name]);
    } catch (_) {
      return null;
    }
  };
  const buildConstant = (pallet, constantName) => {
    try {
      const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
      return buildDefinition(storageEntry.type);
    } catch (_) {
      return null;
    }
  };
  const toStringEnhancer = (fn) => (...args) => fn(...args)?.toString(32) ?? null;
  return {
    buildDefinition: toStringEnhancer(buildDefinition),
    buildStorage: toStringEnhancer(buildStorage),
    buildCall: toStringEnhancer(buildCall),
    buildEvent: toStringEnhancer(buildVariant("events")),
    buildError: toStringEnhancer(buildVariant("errors")),
    buildConstant: toStringEnhancer(buildConstant)
  };
};

// src/view-builder/view-builder.ts
var import_utils2 = require("@polkadot-api/utils");
var import_substrate_bindings2 = require("@polkadot-api/substrate-bindings");

// src/view-builder/shaped-decoders.ts
var import_utils = require("@polkadot-api/utils");
var scale2 = __toESM(require("@polkadot-api/substrate-bindings"));
var toHex = import_utils.toHex;
var createInputValueDecoder = (dec, rest) => scale2.createDecoder((_bytes2) => {
  const bytes = _bytes2;
  const start = bytes.i;
  const value = dec(bytes);
  const input = toHex(new Uint8Array(bytes.buffer.slice(start, bytes.i)));
  return { ...rest, value, input };
});
var primitiveShapedDecoder = (codec, input, rest) => {
  const decoder = createInputValueDecoder(input, { codec, ...rest });
  return Object.assign(decoder, {
    shape: { codec }
  });
};
var complexShapedDecoder = (shape, input, rest) => {
  const decoder = createInputValueDecoder(input, { codec: shape.codec, ...rest });
  return Object.assign(decoder, {
    shape
  });
};
var AccountIdShaped = (ss58Prefix = 42) => {
  const enhanced = scale2.enhanceDecoder(
    scale2.AccountId(ss58Prefix).dec,
    (address) => ({
      address,
      ss58Prefix
    })
  );
  return primitiveShapedDecoder("AccountId", enhanced, {});
};
var BytesArray = (len) => primitiveShapedDecoder("BytesArray", scale2.Hex.dec(len), { len });
var _primitives = [
  "_void",
  "bool",
  "char",
  "str",
  "u8",
  "u16",
  "u32",
  "i8",
  "i16",
  "i32",
  "u64",
  "u128",
  "u256",
  "i64",
  "i128",
  "i256",
  "compactNumber",
  "compactBn",
  "bitSequence"
];
var corePrimitives = Object.fromEntries(
  _primitives.map((x) => [x, primitiveShapedDecoder(x, scale2[x].dec)])
);
var primitives = {
  ...corePrimitives,
  Bytes: primitiveShapedDecoder("Bytes", scale2.Hex.dec()),
  BytesArray,
  AccountId: AccountIdShaped()
};
var Sequence = (input) => complexShapedDecoder(
  { codec: "Sequence", shape: input.shape },
  scale2.Vector.dec(input)
);
var ArrayDec = (input, len) => complexShapedDecoder(
  { codec: "Array", shape: input.shape, len },
  scale2.Vector.dec(input, len)
);
var TupleDec = (...input) => complexShapedDecoder(
  { codec: "Tuple", shape: input.map((x) => x.shape) },
  scale2.Tuple.dec(...input)
);
var StructDec = (input) => complexShapedDecoder(
  { codec: "Struct", shape: (0, import_utils.mapStringRecord)(input, (x) => x.shape) },
  scale2.Struct.dec(input)
);
var EnumDec = (input, args) => complexShapedDecoder(
  { codec: "Enum", shape: (0, import_utils.mapStringRecord)(input, (x) => x.shape) },
  scale2.Enum.dec(input, args)
);
var selfDecoder = (value) => {
  let cache = (x) => {
    const decoder = value();
    const result2 = decoder;
    cache = decoder;
    return result2(x);
  };
  const result = (x) => cache(x);
  result.shape = { codec: "_void" };
  return result;
};
var complex = {
  Sequence,
  Array: ArrayDec,
  Tuple: TupleDec,
  Struct: StructDec,
  Enum: EnumDec
};

// src/view-builder/view-builder.ts
var withProp = (input, propName, propValue) => {
  const decoder = (0, import_substrate_bindings2.enhanceDecoder)(input, (x) => ({
    ...x,
    [propName]: propValue
  }));
  decoder.shape = input.shape;
  return decoder;
};
var addPath = (fn) => (input, cache, stack, lookupData, ...rest) => {
  const { path } = lookupData[input.id];
  const base = fn(input, cache, stack, lookupData, ...rest);
  return path.length ? withProp(base, "path", path) : base;
};
var _buildShapedDecoder = (input, cache, stack, lookupData, _accountId) => {
  if (input.type === "primitive")
    return primitives[input.value];
  if (input.type === "compact")
    return input.isBig ? primitives.compactBn : primitives.compactNumber;
  if (input.type === "bitSequence")
    return primitives.bitSequence;
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return primitives.Bytes;
  }
  const buildNext = (nextInput) => buildShapedDecoder(nextInput, cache, stack, lookupData, _accountId);
  const buildVector = (inner2, len) => {
    const _inner = buildNext(inner2);
    return len ? complex.Array(_inner, len) : complex.Sequence(_inner);
  };
  const buildTuple = (value, innerDocs) => withProp(complex.Tuple(...value.map(buildNext)), "innerDocs", innerDocs);
  const buildStruct = (value, innerDocs) => withProp(
    complex.Struct((0, import_utils2.mapStringRecord)(value, buildNext)),
    "innerDocs",
    innerDocs
  );
  if (input.type === "array") {
    if (input.value.type === "primitive" && input.value.value === "u8") {
      return input.len === 32 && (input.id === 0 || input.id === 1) ? _accountId : primitives.BytesArray(input.len);
    }
    return buildVector(input.value, input.len);
  }
  if (input.type === "sequence")
    return buildVector(input.value);
  if (input.type === "tuple")
    return buildTuple(input.value, input.innerDocs);
  if (input.type === "struct")
    return buildStruct(input.value, input.innerDocs);
  const dependencies = Object.values(input.value).map((v) => {
    if (v.type === "primitive")
      return primitives._void;
    if (v.type === "tuple" && v.value.length === 1) {
      return buildNext(v.value[0]);
    }
    return v.type === "tuple" ? buildTuple(v.value, v.innerDocs) : buildStruct(v.value, v.innerDocs);
  });
  const inner = Object.fromEntries(
    Object.keys(input.value).map((key, idx) => [key, dependencies[idx]])
  );
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  const withoutDocs = areIndexesSorted ? complex.Enum(inner) : complex.Enum(inner, indexes);
  const withDocs = (0, import_substrate_bindings2.enhanceDecoder)(withoutDocs, (val) => {
    const docs = input.innerDocs[val.value.tag];
    return {
      ...val,
      docs
    };
  });
  withDocs.shape = withoutDocs.shape;
  return withDocs;
};
var withPath = addPath(_buildShapedDecoder);
var buildShapedDecoder = withCache(withPath, selfDecoder, (outter, inner) => {
  inner.shape = outter.shape;
  return outter;
});
var hexStrFromByte = (input) => `0x${input.toString(16).padEnd(2, "0")}`;
var getViewBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const cache = /* @__PURE__ */ new Map();
  const getDecoder = (id) => buildShapedDecoder(
    getLookupEntryDef(id),
    cache,
    /* @__PURE__ */ new Set(),
    lookupData,
    _accountId
  );
  const getLookupEntryDef = getLookupFn(lookupData);
  let _accountId = primitives.AccountId;
  const prefix = metadata.pallets.find((x) => x.name === "System")?.constants.find((x) => x.name === "SS58Prefix");
  if (prefix) {
    try {
      const prefixVal = getDecoder(prefix.type)(prefix.value).value;
      if (typeof prefixVal === "number")
        _accountId = AccountIdShaped(prefixVal);
    } catch (_) {
    }
  }
  const buildDefinition = (id) => {
    const shapedDecoder = getDecoder(id);
    return {
      shape: shapedDecoder.shape,
      decoder: shapedDecoder
    };
  };
  const callDecoder = (0, import_substrate_bindings2.createDecoder)((bytes) => {
    const palletIdx = import_substrate_bindings2.u8.dec(bytes);
    const palletEntry = metadata.pallets.find((x) => x.index === palletIdx);
    if (!palletEntry)
      throw new Error("Invalid Pallet");
    const pallet = {
      value: {
        name: palletEntry.name,
        idx: palletIdx
      },
      input: hexStrFromByte(bytes[0])
    };
    const callsDecoder = getDecoder(palletEntry.calls);
    const decoded = callsDecoder(bytes);
    if (decoded.codec !== "Enum")
      throw null;
    const call = {
      value: {
        name: decoded.value.tag,
        idx: bytes[1]
      },
      input: hexStrFromByte(bytes[1]),
      docs: decoded.docs
    };
    return {
      pallet,
      call,
      args: { value: decoded.value.value, shape: callsDecoder.shape }
    };
  });
  return { buildDefinition, callDecoder };
};
//# sourceMappingURL=index.js.map