{"version":3,"sources":["../../src/index.ts","../../src/lookups.ts","../../src/with-cache.ts","../../src/static-builder.ts","../../src/dynamic-builder.ts","../../src/checksum-builder.ts","../../src/view-builder/view-builder.ts","../../src/view-builder/shaped-decoders.ts"],"sourcesContent":["export * from \"./lookups\"\nexport * from \"./static-builder\"\nexport * from \"./dynamic-builder\"\nexport * from \"./checksum-builder\"\nexport * from \"./view-builder\"\n","import type { StringRecord, V14Lookup } from \"@polkadot-api/substrate-bindings\"\n\nexport type VoidVar = { type: \"primitive\"; value: \"_void\" }\nconst voidVar: VoidVar = { type: \"primitive\", value: \"_void\" }\n\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | \"u8\"\n  | \"u16\"\n  | \"u32\"\n  | \"u64\"\n  | \"u128\"\n  | \"u256\"\n  | \"i8\"\n  | \"i16\"\n  | \"i32\"\n  | \"i64\"\n  | \"i128\"\n  | \"i256\"\n\nexport type PrimitiveVar =\n  | {\n      type: \"primitive\"\n      value: MetadataPrimitives\n    }\n  | VoidVar\n\nexport type CompactVar = { type: \"compact\"; isBig: boolean }\nexport type BitSequenceVar = { type: \"bitSequence\" }\nexport type TerminalVar = PrimitiveVar | CompactVar | BitSequenceVar\n\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<(TupleVar | StructVar | VoidVar) & { idx: number }>\n  innerDocs: StringRecord<string[]>\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nexport const getLookupFn = (lookupData: V14Lookup) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  const getLookupEntryDef = withCache((id): Var => {\n    const { def } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return voidVar\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1)\n        return getLookupEntryDef(def.value[0].type as number)\n\n      let allKey = true\n\n      const values: Record<string | number, LookupEntry> = {}\n      const innerDocs: Record<string | number, string[]> = {}\n      def.value.forEach((x, idx) => {\n        allKey = allKey && !!x.name\n        const key = x.name || idx\n        values[key] = getLookupEntryDef(x.type as number)\n        innerDocs[key] = x.docs\n      })\n\n      return allKey\n        ? {\n            type: \"struct\",\n            value: values as StringRecord<LookupEntry>,\n            innerDocs: innerDocs as StringRecord<string[]>,\n          }\n        : {\n            type: \"tuple\",\n            value: Object.values(values),\n            innerDocs: Object.values(innerDocs),\n          }\n    }\n\n    if (def.tag === \"variant\") {\n      if (def.value.length === 0) return voidVar\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { ...voidVar, idx: x.index }\n          return\n        }\n\n        let allKey = true\n\n        const values: Record<string | number, LookupEntry> = {}\n        const innerDocs: Record<string | number, string[]> = {}\n\n        x.fields.forEach((x, idx) => {\n          allKey = allKey && !!x.name\n          const key = x.name || idx\n          values[key] = getLookupEntryDef(x.type as number)\n          innerDocs[key] = x.docs\n        })\n\n        enumValue[key] = allKey\n          ? {\n              type: \"struct\",\n              value: values as StringRecord<LookupEntry>,\n              innerDocs: innerDocs as StringRecord<string[]>,\n              idx: x.index,\n            }\n          : {\n              type: \"tuple\",\n              value: Object.values(values),\n              innerDocs: Object.values(innerDocs),\n              idx: x.index,\n            }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\") {\n      const value = getLookupEntryDef(def.value as number)\n      return {\n        type: \"sequence\",\n        value,\n      }\n    }\n\n    if (def.tag === \"array\") {\n      const value = getLookupEntryDef(def.value.type as number)\n      return {\n        type: \"array\",\n        value,\n        len: def.value.len,\n      }\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return voidVar\n\n      // use to be a \"pointer\"\n      if (def.value.length === 1)\n        return getLookupEntryDef(def.value[0] as number)\n\n      const value = def.value.map((x) => getLookupEntryDef(x as number))\n      const innerDocs = def.value.map((x) => lookupData[x].docs)\n\n      return {\n        type: \"tuple\",\n        value,\n        innerDocs,\n      }\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value as number) as PrimitiveVar\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n      }\n    }\n\n    if (def.tag === \"bitSequence\") {\n      return { type: \"bitSequence\" }\n    }\n\n    // historicMetaCompat\n    const value = def.value as any\n    return {\n      type: \"primitive\",\n      value,\n    }\n  })\n\n  return getLookupEntryDef\n}\n","import { LookupEntry } from \"./lookups\"\n\ntype FnWithStack<Other extends Array<any>, T> = (\n  input: LookupEntry,\n  cache: Map<number, T>,\n  stack: Set<number>,\n  ...rest: Other\n) => T\n\nexport const withCache =\n  <Other extends Array<any>, T>(\n    fn: FnWithStack<Other, T>,\n    onEnterCircular: (\n      cacheGetter: () => T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n    onExitCircular: (\n      outter: T,\n      inner: T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n  ): FnWithStack<Other, T> =>\n  (input, cache, stack, ...rest) => {\n    const { id } = input\n    if (cache.has(id)) return cache.get(id)!\n\n    if (stack.has(id)) {\n      const res = onEnterCircular(() => cache.get(id)!, input, ...rest)\n      cache.set(id, res)\n      return res\n    }\n\n    stack.add(id)\n    let result = fn(input, cache, stack, ...rest)\n    stack.delete(id)\n\n    if (cache.has(id))\n      result = onExitCircular(result, cache.get(id)!, input, ...rest)\n\n    cache.set(id, result)\n    return result\n  }\n","import { StringRecord, V14 } from \"@polkadot-api/substrate-bindings\"\nimport { LookupEntry, getLookupFn } from \"./lookups\"\nimport { withCache } from \"./with-cache\"\n\ntype MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | \"u8\"\n  | \"u16\"\n  | \"u32\"\n  | \"u64\"\n  | \"u128\"\n  | \"u256\"\n  | \"i8\"\n  | \"i16\"\n  | \"i32\"\n  | \"i64\"\n  | \"i128\"\n  | \"i256\"\n\nexport const primitiveTypes: Record<\n  | MetadataPrimitives\n  | \"_void\"\n  | \"compactNumber\"\n  | \"compactBn\"\n  | \"bitSequence\"\n  | \"historicMetaCompat\",\n  string\n> = {\n  _void: \"undefined\",\n  bool: \"boolean\",\n  char: \"string\",\n  str: \"string\",\n  u8: \"number\",\n  u16: \"number\",\n  u32: \"number\",\n  u64: \"bigint\",\n  u128: \"bigint\",\n  u256: \"bigint\",\n  i8: \"number\",\n  i16: \"number\",\n  i32: \"number\",\n  i64: \"bigint\",\n  i128: \"bigint\",\n  i256: \"bigint\",\n  compactNumber: \"number\",\n  compactBn: \"bigint\",\n  bitSequence: \"{bitsLen: number, bytes: Uint8Array}\",\n  historicMetaCompat: \"any\",\n}\n\nexport interface Variable {\n  id: string\n  types: string\n  value: string\n  directDependencies: Set<string>\n}\n\nexport interface CodeDeclarations {\n  imports: Set<string>\n  typeImports: Set<string>\n  variables: Map<string, Variable>\n}\n\nconst toCamelCase = (...parts: string[]): string =>\n  parts[0] +\n  parts\n    .slice(1)\n    .map((part) => part[0].toUpperCase() + part.slice(1))\n    .join(\"\")\n\nconst isBytes = (input: LookupEntry) =>\n  input.type === \"primitive\" && input.value === \"u8\"\n\nconst getTypes = (varName: string) =>\n  primitiveTypes[varName as keyof typeof primitiveTypes] ?? `I${varName}`\n\nconst _buildSyntax = (\n  input: LookupEntry,\n  cache: Map<number, string>,\n  stack: Set<number>,\n  declarations: CodeDeclarations,\n  getVarName: (id: number, ...post: string[]) => string,\n): string => {\n  if (input.type === \"primitive\") {\n    declarations.imports.add(input.value)\n    return input.value\n  }\n\n  if (input.type === \"compact\") {\n    const importVal = input.isBig ? \"compactBn\" : \"compactNumber\"\n    declarations.imports.add(importVal)\n    return importVal\n  }\n\n  if (input.type === \"bitSequence\") {\n    declarations.imports.add(input.type)\n    return input.type\n  }\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    declarations.imports.add(\"Hex\")\n    declarations.typeImports.add(\"HexString\")\n    const variable = {\n      id: \"_bytesSeq\",\n      value: \"Hex()\",\n      types: \"HexString\",\n      directDependencies: new Set<string>(),\n    }\n\n    if (!declarations.variables.has(variable.id)) {\n      declarations.variables.set(variable.id, variable)\n    }\n\n    return variable.id\n  }\n\n  if (declarations.variables.has(getVarName(input.id, \"circular\")))\n    return getVarName(input.id, \"circular\")\n\n  if (declarations.variables.has(getVarName(input.id)))\n    return getVarName(input.id)\n\n  const buildNextSyntax = (nextInput: LookupEntry): string =>\n    buildSyntax(nextInput, cache, stack, declarations, getVarName)\n\n  const buildVector = (id: string, inner: LookupEntry, len?: number) => {\n    declarations.imports.add(\"Vector\")\n    const dependsVar = buildNextSyntax(inner)\n    const args = len ? [dependsVar, len] : [dependsVar]\n    const variable = {\n      id,\n      value: `Vector(${args.join(\", \")})`,\n      types: `Array<${getTypes(dependsVar)}>`,\n      directDependencies: new Set<string>([dependsVar]),\n    }\n    declarations.variables.set(id, variable)\n    return id\n  }\n\n  const buildTuple = (id: string, value: LookupEntry[]) => {\n    declarations.imports.add(\"Tuple\")\n    const deps = value.map(buildNextSyntax)\n    const variable = {\n      id,\n      value: `Tuple(${deps.join(\", \")})`,\n      types: `[${deps.map(getTypes).join(\", \")}]`,\n      directDependencies: new Set(deps),\n    }\n    declarations.variables.set(id, variable)\n    return id\n  }\n\n  const buildStruct = (id: string, value: StringRecord<LookupEntry>) => {\n    declarations.imports.add(\"Struct\")\n    const deps = Object.values(value).map(buildNextSyntax)\n    const variable = {\n      id,\n      value: `Struct({${Object.keys(value)\n        .map((key, idx) => `${key}: ${deps[idx]}`)\n        .join(\", \")}})`,\n      types: `{${Object.keys(value)\n        .map((key, idx) => `${key}: ${getTypes(deps[idx])}`)\n        .join(\", \")}}`,\n      directDependencies: new Set(deps),\n    }\n    declarations.variables.set(id, variable)\n    return id\n  }\n\n  const varId = getVarName(input.id)\n  if (input.type === \"array\") {\n    // Bytes case\n    if (isBytes(input.value)) {\n      if (input.len === 32 && (input.id === 0 || input.id === 1)) {\n        declarations.imports.add(\"AccountId\")\n        const id = \"_accountId\"\n        declarations.variables.set(id, {\n          id,\n          value: `AccountId()`,\n          types: \"SS58String\",\n          directDependencies: new Set<string>(),\n        })\n        declarations.typeImports.add(\"SS58String\")\n        return id\n      }\n\n      declarations.imports.add(\"Hex\")\n      declarations.variables.set(varId, {\n        id: varId,\n        value: `Hex(${input.len})`,\n        types: \"HexString\",\n        directDependencies: new Set<string>(),\n      })\n      declarations.typeImports.add(\"HexString\")\n      return varId\n    }\n\n    // non-fixed size Vector case\n    return buildVector(varId, input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(varId, input.value)\n  if (input.type === \"tuple\") return buildTuple(varId, input.value)\n  if (input.type === \"struct\") return buildStruct(varId, input.value)\n\n  // it has to be an enum by now\n  declarations.imports.add(\"Enum\")\n  const dependencies = Object.entries(input.value).map(([key, value]) => {\n    if (value.type === \"primitive\") {\n      declarations.imports.add(value.value)\n      return value.value\n    }\n\n    const varName = toCamelCase(varId, key)\n    if (value.type === \"tuple\") {\n      if (value.value.length === 1) {\n        let result: string\n        const innerVal = value.value[0]\n        if (\n          key.startsWith(\"Raw\") &&\n          innerVal.type === \"array\" &&\n          isBytes(innerVal.value)\n        ) {\n          const id = `_fixedStr${innerVal.len}`\n          result = id\n          if (!declarations.variables.has(id)) {\n            declarations.imports.add(\"fixedStr\")\n            declarations.variables.set(id, {\n              id,\n              value: `fixedStr(${innerVal.len})`,\n              types: \"string\",\n              directDependencies: new Set(),\n            })\n          }\n        } else {\n          result = buildNextSyntax(value.value[0])\n        }\n\n        if (!declarations.variables.has(varName)) {\n          declarations.variables.set(varName, {\n            id: varName,\n            value: result,\n            types: getTypes(result),\n            directDependencies: new Set([result]),\n          })\n        }\n\n        return varName\n      }\n      return buildTuple(varName, value.value)\n    } else {\n      buildStruct(varName, value.value)\n    }\n    return varName\n  })\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  const innerEnum = `{${Object.keys(input.value).map(\n    (key, idx) => `${key}: ${dependencies[idx]}`,\n  )}}${areIndexesSorted ? \"\" : `, [${indexes.join(\", \")}]`}`\n\n  declarations.variables.set(varId, {\n    id: varId,\n    value: `Enum(${innerEnum})`,\n    types: Object.keys(input.value)\n      .map(\n        (key, idx) => `{tag: '${key}', value: ${getTypes(dependencies[idx])}}`,\n      )\n      .join(\" | \"),\n    directDependencies: new Set<string>(dependencies),\n  })\n  return varId\n}\n\nconst buildSyntax = withCache(\n  _buildSyntax,\n  (_getter, entry, declarations, getVarName) => {\n    declarations.imports.add(\"Self\")\n\n    const nonCircular = getVarName(entry.id)\n    const variable: Variable = {\n      id: getVarName(entry.id, \"circular\"),\n      types: `I${nonCircular}`,\n      value: `Self(() => ${nonCircular})`,\n      directDependencies: new Set([nonCircular]),\n    }\n    declarations.variables.set(variable.id, variable)\n    return variable.id\n  },\n  (x) => x,\n)\n\nexport const getStaticBuilder = (metadata: V14) => {\n  const declarations: CodeDeclarations = {\n    imports: new Set<string>(),\n    typeImports: new Set<string>([\"Codec\"]),\n    variables: new Map(),\n  }\n\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n\n  const getVarName = (idx: number, ...post: string[]): string => {\n    const { path } = lookupData[idx]\n    const parts: string[] = path.length === 0 ? [\"cdc\" + idx] : [\"c\", ...path]\n\n    parts.push(...post)\n\n    return toCamelCase(...parts)\n  }\n\n  const cache = new Map()\n  const buildDefinition = (id: number) =>\n    buildSyntax(\n      getLookupEntryDef(id),\n      cache,\n      new Set(),\n      declarations,\n      getVarName,\n    )\n\n  const buildNamedTuple = (\n    params: Array<{ name: string; type: number }>,\n    varName: string,\n  ) => {\n    if (declarations.variables.has(varName)) return varName\n\n    const args = params.map((p) => p.type).map(buildDefinition)\n    const names = params.map((p) => p.name)\n    declarations.imports.add(\"Tuple\")\n\n    const variable: Variable = {\n      id: varName,\n      types: `[${names\n        .map(\n          (name, pIdx) =>\n            `${name[0].toUpperCase() + name.slice(1)}: ${getTypes(args[pIdx])}`,\n        )\n        .join(\", \")}]`,\n      value: `Tuple(${args.join(\", \")})`,\n      directDependencies: new Set(args),\n    }\n    declarations.variables.set(varName, variable)\n\n    return varName\n  }\n\n  const EMPTY_TUPLE_VAR_NAME = \"_emptyTuple\"\n  const getEmptyTuple = () => {\n    if (!declarations.variables.has(EMPTY_TUPLE_VAR_NAME)) {\n      declarations.imports.add(\"Tuple\")\n\n      declarations.variables.set(EMPTY_TUPLE_VAR_NAME, {\n        id: EMPTY_TUPLE_VAR_NAME,\n        types: `[]`,\n        value: `Tuple()`,\n        directDependencies: new Set(),\n      })\n    }\n    return EMPTY_TUPLE_VAR_NAME\n  }\n\n  const buildStorage = (pallet: string, entry: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    if (storageEntry.type.tag === \"plain\")\n      return {\n        key: getEmptyTuple(),\n        val: buildDefinition(storageEntry.type.value),\n      }\n\n    const { key, value } = storageEntry.type.value\n    const val = buildDefinition(value)\n\n    const returnKey =\n      storageEntry.type.value.hashers.length === 1\n        ? buildNamedTuple(\n            [{ name: \"key\", type: key }],\n            getVarName(key, \"Tupled\"),\n          )\n        : buildDefinition(key)\n\n    return { key: returnKey, val }\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\") => (pallet: string, name: string) => {\n      const eventsLookup = getLookupEntryDef(\n        metadata.pallets.find((x) => x.name === pallet)![type]! as number,\n      )\n      if (eventsLookup.type !== \"enum\") throw null\n\n      const returnVar = toCamelCase(buildDefinition(eventsLookup.id), name)\n\n      if (\n        !declarations.variables.has(returnVar) &&\n        eventsLookup.value[name].type === \"primitive\"\n      ) {\n        declarations.variables.set(returnVar, {\n          id: returnVar,\n          value: \"_void\",\n          types: \"undefined\",\n          directDependencies: new Set(),\n        })\n      }\n\n      return returnVar\n    }\n\n  const buildCall = (pallet: string, callName: string) => {\n    const callsLookup = getLookupEntryDef(\n      metadata.pallets.find((x) => x.name === pallet)!.calls! as number,\n    )\n\n    if (callsLookup.type !== \"enum\") throw null\n\n    const callEntry = callsLookup.value[callName]\n    if (callEntry.type === \"primitive\") return getEmptyTuple()\n    if (callEntry.type === \"tuple\")\n      return toCamelCase(buildDefinition(callsLookup.id), callName)\n\n    const params = Object.entries(callEntry.value).map(([name, val]) => ({\n      name,\n      type: val.id,\n    }))\n\n    return buildNamedTuple(\n      params,\n      getVarName(callsLookup.id, callName, \"Tupled\"),\n    )\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const getCode = (): string => {\n    const typeImports = `import type {${[...declarations.typeImports].join(\n      \", \",\n    )}} from \"@polkadot-api/substrate-bindings\";\\n`\n\n    const varImports = `import {${[...declarations.imports].join(\n      \", \",\n    )}} from \"@polkadot-api/substrate-bindings\";\\n\\n`\n\n    const code = [...declarations.variables.values()]\n      .map((variable) => {\n        return `type I${variable.id} = ${variable.types};\nconst ${variable.id}: Codec<I${variable.id}> = ${variable.value};`\n      })\n      .join(\"\\n\\n\")\n\n    return `${typeImports}${varImports}${code}`\n  }\n\n  const getTypeFromVarName = (varName: string) =>\n    primitiveTypes[varName as keyof typeof primitiveTypes] ??\n    declarations.variables.get(varName)?.types ??\n    `I${varName}`\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildCall,\n    buildConstant,\n    getTypeFromVarName,\n    getCode,\n  }\n}\n","import type { Codec, StringRecord, V14 } from \"@polkadot-api/substrate-bindings\"\nimport type { LookupEntry, TupleVar } from \"./lookups\"\nimport { getLookupFn } from \"./lookups\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { withCache } from \"./with-cache\"\n\nconst _bytes = scale.Hex()\n\nconst isBytes = (input: LookupEntry) =>\n  input.type === \"primitive\" && input.value === \"u8\"\n\nconst _buildCodec = (\n  input: LookupEntry,\n  cache: Map<number, Codec<any>>,\n  stack: Set<number>,\n  _accountId: Codec<scale.SS58String>,\n): Codec<any> => {\n  if (input.type === \"primitive\") return scale[input.value]\n  if (input.type === \"compact\") return scale.compact\n  if (input.type === \"bitSequence\") return scale.bitSequence\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return _bytes\n  }\n\n  const buildNextCodec = (nextInput: LookupEntry): Codec<any> =>\n    buildCodec(nextInput, cache, stack, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const innerCodec = buildNextCodec(inner)\n    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec)\n  }\n\n  const buildTuple = (value: LookupEntry[]) =>\n    scale.Tuple(...value.map(buildNextCodec))\n\n  const buildStruct = (value: StringRecord<LookupEntry>) => {\n    const inner = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, buildNextCodec(value)]),\n    ) as StringRecord<Codec<any>>\n    return scale.Struct(inner)\n  }\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (isBytes(input.value)) {\n      return input.len === 32 && (input.id === 0 || input.id === 1)\n        ? _accountId\n        : scale.Hex(input.len)\n    }\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value)\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  // it has to be an enum by now\n  const dependencies = Object.entries(input.value).map(([k, v]) => {\n    if (v.type === \"primitive\") return scale._void\n    if (v.type === \"tuple\" && v.value.length === 1) {\n      const innerVal = v.value[0]\n      return k.startsWith(\"Raw\") &&\n        innerVal.type === \"array\" &&\n        isBytes(innerVal.value)\n        ? scale.fixedStr(innerVal.len)\n        : buildNextCodec(innerVal)\n    }\n    return v.type === \"tuple\" ? buildTuple(v.value) : buildStruct(v.value)\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => {\n      return [key, dependencies[idx]]\n    }),\n  ) as StringRecord<Codec<any>>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  return areIndexesSorted\n    ? scale.Enum(inner)\n    : scale.Enum(inner, indexes as any)\n}\nconst buildCodec = withCache(_buildCodec, scale.Self, (res) => res)\n\nconst emptyTuple = scale.Tuple()\n\nexport const getDynamicBuilder = (metadata: V14) => {\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n  let _accountId = scale.AccountId()\n\n  const cache = new Map()\n  const buildDefinition = (id: number): Codec<any> =>\n    buildCodec(getLookupEntryDef(id), cache, new Set(), _accountId)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        _accountId = scale.AccountId(prefixVal)\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    const storageWithFallback = (\n      len: number,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const result = storagePallet!(...args)\n      return {\n        ...result,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? result.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        entry,\n        buildDefinition(storageEntry.type.value).dec,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = buildDefinition(value)\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: Array<scale.EncoderWithHash<any>> =\n      hashes.length === 1\n        ? [[buildDefinition(key), hashes[0]]]\n        : (getLookupEntryDef(key) as TupleVar).value.map(\n            (x, idx): scale.EncoderWithHash<any> => [\n              buildDefinition(x.id),\n              hashes[idx],\n            ],\n          )\n    return storageWithFallback(hashes.length, entry, val.dec, ...hashArgs)\n  }\n\n  const buildCall = (\n    pallet: string,\n    callName: string,\n  ): {\n    location: [number, number]\n    args: Codec<any>\n  } => {\n    const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n    const callsLookup = getLookupEntryDef(palletEntry.calls! as number)\n\n    if (callsLookup.type !== \"enum\") throw null\n    const callEntry = callsLookup.value[callName]\n    return {\n      location: [palletEntry.index, callEntry.idx],\n      args:\n        callEntry.type === \"primitive\"\n          ? emptyTuple\n          : scale.Tuple(\n              ...Object.values(callEntry.value).map((l) =>\n                buildDefinition(l.id),\n              ),\n            ),\n    }\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!)\n      if (lookup.type !== \"enum\") throw null\n      const event = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, event.idx],\n        codec:\n          event.type === \"primitive\" ? scale._void : buildDefinition(lookup.id),\n      }\n    }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildCall,\n    buildConstant,\n    ss58Prefix,\n  }\n}\n","import type { StringRecord, V14 } from \"@polkadot-api/substrate-bindings\"\nimport { h64 } from \"@polkadot-api/substrate-bindings\"\nimport {\n  EnumVar,\n  LookupEntry,\n  MetadataPrimitives,\n  getLookupFn,\n} from \"./lookups\"\nimport { withCache } from \"./with-cache\"\n\nconst textEncoder = new TextEncoder()\nconst encodeText = textEncoder.encode.bind(textEncoder)\n\nconst getChecksum = (values: Array<bigint>, shape?: string) => {\n  const hasShape = typeof shape === \"string\"\n  const res = new Uint8Array((values.length + (hasShape ? 1 : 0)) * 8)\n  const dv = new DataView(res.buffer)\n\n  let offset = 0\n  if (hasShape) {\n    dv.setBigUint64(offset, h64(encodeText(shape)))\n    offset += 8\n  }\n\n  for (let i = 0; i < values.length; i++, offset += 8)\n    dv.setBigUint64(offset, values[i])\n\n  return h64(res)\n}\n\nconst primitiveChecksums: Record<\n  | MetadataPrimitives\n  | \"_void\"\n  | \"compactb\"\n  | \"compacts\"\n  | \"bitSequence\"\n  | \"historicMetaCompat\",\n  bigint\n> = {\n  _void: 0n,\n  bool: 1n,\n  char: 2n,\n  str: 3n,\n  u8: 4n,\n  u16: 5n,\n  u32: 6n,\n  u64: 7n,\n  u128: 8n,\n  u256: 9n,\n  i8: 5n,\n  i16: 5n,\n  i32: 6n,\n  i64: 7n,\n  i128: 8n,\n  i256: 9n,\n  compacts: 10n,\n  compactb: 11n,\n  bitSequence: 12n,\n  historicMetaCompat: 13n,\n}\n\nconst bytesChecksum = 14n\n\nconst _buildChecksum = (\n  input: LookupEntry,\n  cache: Map<number, bigint>,\n  stack: Set<number>,\n): bigint => {\n  if (cache.has(input.id)) return cache.get(input.id)!\n\n  if (input.type === \"primitive\") return primitiveChecksums[input.value]\n  if (input.type === \"compact\")\n    return primitiveChecksums[input.isBig ? \"compactb\" : \"compacts\"]\n  if (input.type === \"bitSequence\") return primitiveChecksums.bitSequence\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return bytesChecksum\n  }\n\n  const buildNextChecksum = (nextInput: LookupEntry): bigint =>\n    buildChecksum(nextInput, cache, stack)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const innerChecksum = buildNextChecksum(inner)\n    return len\n      ? getChecksum([innerChecksum, BigInt(len)], \"Vector(,)\")\n      : getChecksum([innerChecksum], \"Vector()\")\n  }\n\n  const buildTuple = (value: LookupEntry[]) =>\n    getChecksum(value.map(buildNextChecksum))\n\n  const buildStruct = (value: StringRecord<LookupEntry>) => {\n    return getChecksum(\n      Object.values(value).map(buildNextChecksum),\n      JSON.stringify(Object.keys(value)),\n    )\n  }\n\n  if (input.type === \"array\") return buildVector(input.value, input.len)\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value)\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    if (v.type === \"primitive\") return 0n\n    return v.type === \"tuple\" ? buildTuple(v.value) : buildStruct(v.value)\n  })\n  const keys = Object.keys(input.value)\n  keys.push(\"Enum\")\n  return getChecksum(dependencies, JSON.stringify({ Enum: keys }))\n}\nconst buildChecksum = withCache(\n  _buildChecksum,\n  () => 0n,\n  (result) => result,\n)\n\nexport const getChecksumBuilder = (metadata: V14) => {\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n\n  const cache = new Map<number, bigint>()\n\n  const buildDefinition = (id: number): bigint =>\n    buildChecksum(getLookupEntryDef(id), cache, new Set())\n\n  const buildStorage = (pallet: string, entry: string): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .storage!.items.find((s) => s.name === entry)!\n\n      if (storageEntry.type.tag === \"plain\")\n        return getChecksum([buildDefinition(storageEntry.type.value)])\n\n      const { key, value } = storageEntry.type.value\n      const val = buildDefinition(value)\n      const returnKey =\n        storageEntry.type.value.hashers.length === 1\n          ? getChecksum([buildDefinition(key)])\n          : buildDefinition(key)\n      return getChecksum([val, returnKey])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): bigint => {\n    if (entry.type === \"primitive\") return 0n\n\n    const values = Object.values(entry.value).map((l) => buildDefinition(l.id))\n\n    return entry.type === \"tuple\"\n      ? getChecksum(values)\n      : getChecksum(values, JSON.stringify(Object.keys(entry.value)))\n  }\n\n  const buildCall = (pallet: string, callName: string): bigint | null => {\n    try {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const callsLookup = getLookupEntryDef(palletEntry.calls! as number)\n\n      if (callsLookup.type !== \"enum\") throw null\n      return buildEnumEntry(callsLookup.value[callName])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildVariant =\n    (variantType: \"errors\" | \"events\") =>\n    (pallet: string, name: string): bigint | null => {\n      try {\n        const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n        const callsLookup = getLookupEntryDef(\n          palletEntry[variantType]! as number,\n        )\n\n        if (callsLookup.type !== \"enum\") throw null\n        return buildEnumEntry(callsLookup.value[name])\n      } catch (_) {\n        return null\n      }\n    }\n\n  const buildConstant = (\n    pallet: string,\n    constantName: string,\n  ): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .constants!.find((s) => s.name === constantName)!\n\n      return buildDefinition(storageEntry.type as number)\n    } catch (_) {\n      return null\n    }\n  }\n\n  const toStringEnhancer =\n    <Args extends Array<any>>(\n      fn: (...args: Args) => bigint | null,\n    ): ((...args: Args) => string | null) =>\n    (...args) =>\n      fn(...args)?.toString(32) ?? null\n\n  return {\n    buildDefinition: toStringEnhancer(buildDefinition),\n\n    buildStorage: toStringEnhancer(buildStorage),\n    buildCall: toStringEnhancer(buildCall),\n    buildEvent: toStringEnhancer(buildVariant(\"events\")),\n    buildError: toStringEnhancer(buildVariant(\"errors\")),\n    buildConstant: toStringEnhancer(buildConstant),\n  }\n}\n","import { mapStringRecord } from \"@polkadot-api/utils\"\nimport {\n  Decoder,\n  type StringRecord,\n  type V14,\n  createDecoder,\n  u8,\n  HexString,\n  enhanceDecoder,\n} from \"@polkadot-api/substrate-bindings\"\nimport type { LookupEntry } from \"@/lookups\"\nimport { getLookupFn } from \"@/lookups\"\nimport {\n  primitives,\n  complex,\n  WithShapeWithoutExtra,\n  ShapedDecoder,\n  selfDecoder,\n  AccountIdShaped,\n  WithoutExtra,\n} from \"./shaped-decoders\"\nimport {\n  AccountIdDecoded,\n  Decoded,\n  DecodedCall,\n  GetViewBuilder,\n  PrimitiveDecoded,\n  Shape,\n} from \"./types\"\nimport { withCache } from \"@/with-cache\"\n\ntype WithProp<\n  T extends Decoder<any> & { shape: any },\n  PropName extends string,\n  PropValue,\n> = T extends Decoder<infer D> & { shape: infer S }\n  ? Decoder<\n      D extends WithoutExtra<PrimitiveDecoded>\n        ? PrimitiveDecoded\n        : D & { [P in PropName]: PropValue }\n    > & { shape: S }\n  : T\n\nconst withProp = <PropName extends string, PropValue>(\n  input: ShapedDecoder,\n  propName: PropName,\n  propValue: PropValue,\n): WithProp<ShapedDecoder, PropName, PropValue> => {\n  const decoder = enhanceDecoder(input as Decoder<{}>, (x) => ({\n    ...x,\n    [propName]: propValue,\n  })) as WithProp<ShapedDecoder, PropName, PropValue>\n  decoder.shape = input.shape\n  return decoder\n}\n\nconst addPath =\n  <Other extends Array<any>>(\n    fn: (\n      input: LookupEntry,\n      cache: Map<number, ShapedDecoder>,\n      stack: Set<number>,\n      lookupData: V14[\"lookup\"],\n      ...rest: Other\n    ) => ShapedDecoder,\n  ): ((\n    input: LookupEntry,\n    cache: Map<number, ShapedDecoder>,\n    stack: Set<number>,\n    lookupData: V14[\"lookup\"],\n    ...rest: Other\n  ) => ShapedDecoder | WithProp<ShapedDecoder, \"path\", string[]>) =>\n  (input, cache, stack, lookupData, ...rest) => {\n    const { path } = lookupData[input.id]\n    const base = fn(input, cache, stack, lookupData, ...rest)\n    return path.length ? withProp(base, \"path\", path) : base\n  }\n\nconst _buildShapedDecoder = (\n  input: LookupEntry,\n  cache: Map<number, ShapedDecoder>,\n  stack: Set<number>,\n  lookupData: V14[\"lookup\"],\n  _accountId: WithShapeWithoutExtra<AccountIdDecoded>,\n): ShapedDecoder => {\n  if (input.type === \"primitive\") return primitives[input.value]\n  if (input.type === \"compact\")\n    return input.isBig ? primitives.compactBn : primitives.compactNumber\n  if (input.type === \"bitSequence\") return primitives.bitSequence\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return primitives.Bytes\n  }\n\n  const buildNext = (nextInput: LookupEntry): ShapedDecoder =>\n    buildShapedDecoder(nextInput, cache, stack, lookupData, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const _inner = buildNext(inner)\n    return len ? complex.Array(_inner, len) : complex.Sequence(_inner)\n  }\n\n  const buildTuple = (value: LookupEntry[], innerDocs: string[][]) =>\n    withProp(complex.Tuple(...value.map(buildNext)), \"innerDocs\", innerDocs)\n\n  const buildStruct = (\n    value: StringRecord<LookupEntry>,\n    innerDocs: StringRecord<string[]>,\n  ) =>\n    withProp(\n      complex.Struct(mapStringRecord(value, buildNext)),\n      \"innerDocs\",\n      innerDocs,\n    )\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\") {\n      return input.len === 32 && (input.id === 0 || input.id === 1)\n        ? _accountId\n        : primitives.BytesArray(input.len)\n    }\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value, input.innerDocs)\n  if (input.type === \"struct\") return buildStruct(input.value, input.innerDocs)\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    if (v.type === \"primitive\") return primitives._void\n    if (v.type === \"tuple\" && v.value.length === 1) {\n      return buildNext(v.value[0])\n    }\n    return v.type === \"tuple\"\n      ? buildTuple(v.value, v.innerDocs)\n      : buildStruct(v.value, v.innerDocs)\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => [key, dependencies[idx]]),\n  ) as StringRecord<ShapedDecoder>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  const withoutDocs = areIndexesSorted\n    ? complex.Enum(inner)\n    : complex.Enum(inner, indexes as any)\n\n  const withDocs = enhanceDecoder(withoutDocs, (val) => {\n    const docs = input.innerDocs[val.value.tag]\n    return {\n      ...val,\n      docs,\n    }\n  }) as unknown as typeof withoutDocs\n  withDocs.shape = withoutDocs.shape\n  return withDocs\n}\n\nconst withPath = addPath(_buildShapedDecoder)\nconst buildShapedDecoder = withCache(withPath, selfDecoder, (outter, inner) => {\n  inner.shape = outter.shape\n  return outter\n})\n\nconst hexStrFromByte = (input: number) =>\n  `0x${input.toString(16).padEnd(2, \"0\")}` as HexString\n\nexport const getViewBuilder: GetViewBuilder = (metadata: V14) => {\n  const lookupData = metadata.lookup\n  const cache = new Map<number, ShapedDecoder>()\n\n  const getDecoder = (id: number) =>\n    buildShapedDecoder(\n      getLookupEntryDef(id),\n      cache,\n      new Set(),\n      lookupData,\n      _accountId,\n    )\n\n  const getLookupEntryDef = getLookupFn(lookupData)\n\n  let _accountId: WithShapeWithoutExtra<AccountIdDecoded> = primitives.AccountId\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n  if (prefix) {\n    try {\n      const prefixVal = getDecoder(prefix.type)(prefix.value).value\n\n      if (typeof prefixVal === \"number\") _accountId = AccountIdShaped(prefixVal)\n    } catch (_) {}\n  }\n\n  const buildDefinition = (\n    id: number,\n  ): { shape: Shape; decoder: Decoder<Decoded> } => {\n    const shapedDecoder = getDecoder(id)\n\n    return {\n      shape: shapedDecoder.shape,\n      decoder: shapedDecoder as any,\n    }\n  }\n\n  const callDecoder: Decoder<DecodedCall> = createDecoder((bytes) => {\n    const palletIdx = u8.dec(bytes)\n\n    const palletEntry = metadata.pallets.find((x) => x.index === palletIdx)\n    if (!palletEntry) throw new Error(\"Invalid Pallet\")\n\n    const pallet = {\n      value: {\n        name: palletEntry.name,\n        idx: palletIdx,\n      },\n      input: hexStrFromByte(bytes[0]),\n    }\n\n    const callsDecoder = getDecoder(palletEntry.calls!)\n\n    const decoded = callsDecoder(bytes)\n\n    if (decoded.codec !== \"Enum\") throw null\n\n    const call = {\n      value: {\n        name: decoded.value.tag,\n        idx: bytes[1],\n      },\n      input: hexStrFromByte(bytes[1]),\n      docs: (decoded as any).docs as string[],\n    }\n\n    return {\n      pallet,\n      call,\n      args: { value: decoded.value.value as any, shape: callsDecoder.shape },\n    }\n  })\n\n  return { buildDefinition, callDecoder }\n}\n","import { toHex as _toHex, mapStringRecord } from \"@polkadot-api/utils\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport type {\n  Decoder,\n  HexString,\n  StringRecord,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  ArrayDecoded,\n  ArrayShape,\n  BytesArrayDecoded,\n  ComplexDecoded,\n  ComplexShape,\n  Decoded,\n  EnumDecoded,\n  EnumShape,\n  PrimitiveDecoded,\n  SequenceDecoded,\n  SequenceShape,\n  StructDecoded,\n  StructShape,\n  TupleDecoded,\n  TupleShape,\n} from \"./types\"\n\nconst toHex = _toHex as (input: Uint8Array) => HexString\n\ntype Extras = \"docs\" | \"path\" | \"innerDocs\"\nexport type WithoutExtra<T extends {}> = Omit<T, Extras>\ntype PrimitiveCodec = PrimitiveDecoded[\"codec\"]\ntype ComplexCodec = ComplexDecoded[\"codec\"]\n\nexport type WithShapeWithoutExtra<T extends PrimitiveDecoded> = Decoder<\n  WithoutExtra<T>\n> & {\n  shape: { codec: T[\"codec\"] }\n}\ntype PrimitiveShapeDecoder = WithShapeWithoutExtra<PrimitiveDecoded>\n\ntype SequenceShapedDecoder = Decoder<WithoutExtra<SequenceDecoded>> & {\n  shape: SequenceShape\n}\ntype ArrayShapedDecoder = Decoder<WithoutExtra<ArrayDecoded>> & {\n  shape: ArrayShape\n}\ntype TupleShapedDecoder = Decoder<WithoutExtra<TupleDecoded>> & {\n  shape: TupleShape\n}\ntype StructShapedDecoder = Decoder<WithoutExtra<StructDecoded>> & {\n  shape: StructShape\n}\ntype EnumShapedDecoder = Decoder<WithoutExtra<EnumDecoded>> & {\n  shape: EnumShape\n}\ntype ComplexShapedDecoder =\n  | SequenceShapedDecoder\n  | ArrayShapedDecoder\n  | TupleShapedDecoder\n  | StructShapedDecoder\n  | EnumShapedDecoder\n\nexport type ShapedDecoder = PrimitiveShapeDecoder | ComplexShapedDecoder\n\ntype PrimitiveDecodedValue<C extends PrimitiveCodec> = (PrimitiveDecoded & {\n  codec: C\n})[\"value\"]\ntype PrimitiveDecodedRest<C extends PrimitiveCodec> = Omit<\n  PrimitiveDecoded & { codec: C },\n  \"value\" | \"input\" | \"codec\" | Extras\n>\n\ntype ComplexDecodedValue<C extends ComplexCodec> = (ComplexDecoded & {\n  codec: C\n})[\"value\"]\ntype ComplexDecodedRest<C extends ComplexCodec> = Omit<\n  ComplexDecoded & { codec: C },\n  \"value\" | \"input\" | \"codec\" | Extras\n>\n\nconst createInputValueDecoder = <T, Rest extends { codec: Decoded[\"codec\"] }>(\n  dec: Decoder<T>,\n  rest: Rest,\n): Decoder<\n  Rest & {\n    input: HexString\n    value: T\n  }\n> =>\n  scale.createDecoder((_bytes) => {\n    const bytes = _bytes as Uint8Array & { i: number; v: DataView }\n    const start = bytes.i\n    const value = dec(bytes)\n    const input = toHex(new Uint8Array(bytes.buffer.slice(start, bytes.i)))\n    return { ...rest, value, input }\n  })\n\nconst primitiveShapedDecoder = <C extends PrimitiveCodec>(\n  codec: C,\n  input: Decoder<PrimitiveDecodedValue<C>>,\n  rest?: PrimitiveDecodedRest<C>,\n): WithShapeWithoutExtra<\n  PrimitiveDecoded & {\n    codec: C\n  }\n> => {\n  const decoder: Decoder<WithoutExtra<PrimitiveDecoded>> =\n    createInputValueDecoder(input, { codec, ...rest })\n\n  return Object.assign(decoder, {\n    shape: { codec },\n  }) as any\n}\n\nconst complexShapedDecoder = <Shape extends ComplexShape>(\n  shape: Shape,\n  input: Decoder<ComplexDecodedValue<Shape[\"codec\"]>>,\n  rest?: ComplexDecodedRest<Shape[\"codec\"]>,\n): Decoder<\n  WithoutExtra<\n    ComplexDecoded & {\n      codec: Shape[\"codec\"]\n    }\n  >\n> & {\n  shape: Shape\n} => {\n  const decoder: Decoder<WithoutExtra<ComplexDecoded>> =\n    createInputValueDecoder(input, { codec: shape.codec, ...rest })\n\n  return Object.assign(decoder, {\n    shape,\n  })\n}\n\nexport const AccountIdShaped = (ss58Prefix = 42) => {\n  const enhanced = scale.enhanceDecoder(\n    scale.AccountId(ss58Prefix).dec,\n    (address) => ({\n      address,\n      ss58Prefix,\n    }),\n  )\n\n  return primitiveShapedDecoder(\"AccountId\", enhanced, {})\n}\n\nconst BytesArray = (len: number): WithShapeWithoutExtra<BytesArrayDecoded> =>\n  primitiveShapedDecoder(\"BytesArray\", scale.Hex.dec(len), { len })\n\nconst _primitives = [\n  \"_void\",\n  \"bool\",\n  \"char\",\n  \"str\",\n  \"u8\",\n  \"u16\",\n  \"u32\",\n  \"i8\",\n  \"i16\",\n  \"i32\",\n  \"u64\",\n  \"u128\",\n  \"u256\",\n  \"i64\",\n  \"i128\",\n  \"i256\",\n  \"compactNumber\",\n  \"compactBn\",\n  \"bitSequence\",\n] as const\n\ntype PrimitivesList = typeof _primitives\ntype PrimitivesKeys = PrimitivesList[number]\n\nconst corePrimitives: {\n  [P in PrimitivesKeys]: WithShapeWithoutExtra<\n    PrimitiveDecoded & {\n      codec: P\n    }\n  >\n} = Object.fromEntries(\n  _primitives.map((x) => [x, primitiveShapedDecoder(x, scale[x].dec)]),\n) as any\n\nexport const primitives = {\n  ...corePrimitives,\n  Bytes: primitiveShapedDecoder(\"Bytes\", scale.Hex.dec()),\n  BytesArray,\n  AccountId: AccountIdShaped(),\n}\n\nconst Sequence = (input: ShapedDecoder): SequenceShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Sequence\", shape: input.shape },\n    scale.Vector.dec(input as any),\n  )\n\nconst ArrayDec = (input: ShapedDecoder, len: number): ArrayShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Array\", shape: input.shape, len },\n    scale.Vector.dec(input as any, len),\n  )\n\nconst TupleDec = (...input: Array<ShapedDecoder>): TupleShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Tuple\", shape: input.map((x) => x.shape) },\n    scale.Tuple.dec(...(input as Array<Decoder<any>>)),\n  )\n\nconst StructDec = (input: StringRecord<ShapedDecoder>): StructShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Struct\", shape: mapStringRecord(input, (x) => x.shape) },\n    scale.Struct.dec(input as {}),\n  )\n\nconst EnumDec = (\n  input: StringRecord<ShapedDecoder>,\n  args?: number[],\n): EnumShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Enum\", shape: mapStringRecord(input, (x) => x.shape) },\n    scale.Enum.dec(input as {}, args as any),\n  )\n\nexport const selfDecoder = (value: () => ShapedDecoder): ShapedDecoder => {\n  let cache: Decoder<any> = (x) => {\n    const decoder = value()\n    const result = decoder\n    cache = decoder\n    return result(x)\n  }\n\n  const result = ((x) => cache(x)) as ShapedDecoder\n  result.shape = { codec: \"_void\" }\n  return result\n}\n\nexport const complex = {\n  Sequence,\n  Array: ArrayDec,\n  Tuple: TupleDec,\n  Struct: StructDec,\n  Enum: EnumDec,\n}\n"],"mappings":"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","names":["src_exports","__export","getChecksumBuilder","getDynamicBuilder","getLookupFn","getStaticBuilder","getViewBuilder","primitiveTypes","__toCommonJS","voidVar","getLookupFn","lookupData","lookups","from","getLookupEntryDef","fn","id","entry","value","def","allKey","values","innerDocs","x","idx","key","enumValue","enumDocs","translated","withCache","fn","onEnterCircular","onExitCircular","input","cache","stack","rest","id","res","result","primitiveTypes","toCamelCase","parts","part","isBytes","input","getTypes","varName","_buildSyntax","cache","stack","declarations","getVarName","importVal","variable","buildNextSyntax","nextInput","buildSyntax","buildVector","id","inner","len","dependsVar","buildTuple","value","deps","buildStruct","key","idx","varId","dependencies","result","innerVal","indexes","x","areIndexesSorted","innerEnum","withCache","_getter","entry","nonCircular","getStaticBuilder","metadata","lookupData","getLookupEntryDef","getLookupFn","post","path","buildDefinition","buildNamedTuple","params","args","p","names","name","pIdx","EMPTY_TUPLE_VAR_NAME","getEmptyTuple","buildStorage","pallet","storageEntry","s","val","buildVariant","type","eventsLookup","returnVar","buildCall","callName","callsLookup","callEntry","buildConstant","constantName","getCode","typeImports","varImports","code","getTypeFromVarName","scale","_bytes","isBytes","input","_buildCodec","cache","stack","_accountId","scale","buildNextCodec","nextInput","buildCodec","buildVector","inner","len","innerCodec","buildTuple","value","buildStruct","key","dependencies","k","v","innerVal","idx","indexes","x","i","withCache","res","emptyTuple","getDynamicBuilder","metadata","lookupData","getLookupEntryDef","getLookupFn","buildDefinition","id","prefix","ss58Prefix","prefixVal","storagePallets","buildStorage","pallet","entry","storagePallet","storageEntry","s","storageWithFallback","args","result","hashers","val","hashes","hashArgs","buildCall","callName","palletEntry","callsLookup","callEntry","l","buildConstant","constantName","buildVariant","type","name","lookup","event","import_substrate_bindings","textEncoder","encodeText","getChecksum","values","shape","hasShape","res","dv","offset","i","primitiveChecksums","bytesChecksum","_buildChecksum","input","cache","stack","buildNextChecksum","nextInput","buildChecksum","buildVector","inner","len","innerChecksum","buildTuple","value","buildStruct","dependencies","v","keys","withCache","result","getChecksumBuilder","metadata","lookupData","getLookupEntryDef","getLookupFn","buildDefinition","id","buildStorage","pallet","entry","storageEntry","x","s","key","val","returnKey","buildEnumEntry","l","buildCall","callName","palletEntry","callsLookup","buildVariant","variantType","name","buildConstant","constantName","toStringEnhancer","fn","args","import_utils","import_substrate_bindings","import_utils","scale","toHex","_toHex","createInputValueDecoder","dec","rest","_bytes","bytes","start","value","input","primitiveShapedDecoder","codec","decoder","complexShapedDecoder","shape","AccountIdShaped","ss58Prefix","enhanced","address","BytesArray","len","_primitives","corePrimitives","x","primitives","Sequence","ArrayDec","TupleDec","StructDec","EnumDec","args","selfDecoder","cache","result","complex","withProp","input","propName","propValue","decoder","x","addPath","fn","cache","stack","lookupData","rest","path","base","_buildShapedDecoder","_accountId","primitives","buildNext","nextInput","buildShapedDecoder","buildVector","inner","len","_inner","complex","buildTuple","value","innerDocs","buildStruct","dependencies","v","key","idx","indexes","withoutDocs","i","withDocs","val","docs","withPath","withCache","selfDecoder","outter","hexStrFromByte","getViewBuilder","metadata","getDecoder","id","getLookupEntryDef","getLookupFn","prefix","prefixVal","AccountIdShaped","buildDefinition","shapedDecoder","callDecoder","bytes","palletIdx","palletEntry","pallet","callsDecoder","decoded","call"]}