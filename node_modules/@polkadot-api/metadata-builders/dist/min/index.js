"use strict";var se=Object.create;var W=Object.defineProperty;var ce=Object.getOwnPropertyDescriptor;var ue=Object.getOwnPropertyNames;var pe=Object.getPrototypeOf,de=Object.prototype.hasOwnProperty;var le=(e,t)=>{for(var p in t)W(e,p,{get:t[p],enumerable:!0})},G=(e,t,p,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of ue(t))!de.call(e,s)&&s!==p&&W(e,s,{get:()=>t[s],enumerable:!(r=ce(t,s))||r.enumerable});return e};var J=(e,t,p)=>(p=e!=null?se(pe(e)):{},G(t||!e||!e.__esModule?W(p,"default",{value:e,enumerable:!0}):p,e)),me=e=>G(W({},"__esModule",{value:!0}),e);var We={};le(We,{getChecksumBuilder:()=>Ee,getDynamicBuilder:()=>Se,getLookupFn:()=>T,getStaticBuilder:()=>ve,getViewBuilder:()=>ae,primitiveTypes:()=>M});module.exports=me(We);var $={type:"primitive",value:"_void"},T=e=>{let t=new Map,p=new Set,s=(d=>o=>{let h=t.get(o);if(h)return h;if(p.has(o)){let c={id:o};return t.set(o,c),c}p.add(o);let y=d(o);return h=t.get(o),h?Object.assign(h,y):(h={id:o,...y},t.set(o,h)),p.delete(o),h})(d=>{let{def:o}=e[d];if(o.tag==="composite"){if(o.value.length===0)return $;if(o.value.length===1)return s(o.value[0].type);let y=!0,c={},v={};return o.value.forEach((b,g)=>{y=y&&!!b.name;let u=b.name||g;c[u]=s(b.type),v[u]=b.docs}),y?{type:"struct",value:c,innerDocs:v}:{type:"tuple",value:Object.values(c),innerDocs:Object.values(v)}}if(o.tag==="variant"){if(o.value.length===0)return $;let y={},c={};return o.value.forEach(v=>{let b=v.name;if(c[b]=v.docs,v.fields.length===0){y[b]={...$,idx:v.index};return}let g=!0,u={},n={};v.fields.forEach((i,a)=>{g=g&&!!i.name;let l=i.name||a;u[l]=s(i.type),n[l]=i.docs}),y[b]=g?{type:"struct",value:u,innerDocs:n,idx:v.index}:{type:"tuple",value:Object.values(u),innerDocs:Object.values(n),idx:v.index}}),{type:"enum",value:y,innerDocs:c}}if(o.tag==="sequence")return{type:"sequence",value:s(o.value)};if(o.tag==="array")return{type:"array",value:s(o.value.type),len:o.value.len};if(o.tag==="tuple"){if(o.value.length===0)return $;if(o.value.length===1)return s(o.value[0]);let y=o.value.map(v=>s(v)),c=o.value.map(v=>e[v].docs);return{type:"tuple",value:y,innerDocs:c}}if(o.tag==="primitive")return{type:"primitive",value:o.value.tag};if(o.tag==="compact"){let y=s(o.value);return{type:"compact",isBig:Number(y.value.slice(1))>32}}return o.tag==="bitSequence"?{type:"bitSequence"}:{type:"primitive",value:o.value}});return s};var L=(e,t,p)=>(r,s,d,...o)=>{let{id:h}=r;if(s.has(h))return s.get(h);if(d.has(h)){let c=t(()=>s.get(h),r,...o);return s.set(h,c),c}d.add(h);let y=e(r,s,d,...o);return d.delete(h),s.has(h)&&(y=p(y,s.get(h),r,...o)),s.set(h,y),y};var M={_void:"undefined",bool:"boolean",char:"string",str:"string",u8:"number",u16:"number",u32:"number",u64:"bigint",u128:"bigint",u256:"bigint",i8:"number",i16:"number",i32:"number",i64:"bigint",i128:"bigint",i256:"bigint",compactNumber:"number",compactBn:"bigint",bitSequence:"{bitsLen: number, bytes: Uint8Array}",historicMetaCompat:"any"},I=(...e)=>e[0]+e.slice(1).map(t=>t[0].toUpperCase()+t.slice(1)).join(""),Y=e=>e.type==="primitive"&&e.value==="u8",O=e=>M[e]??`I${e}`,ye=(e,t,p,r,s)=>{if(e.type==="primitive")return r.imports.add(e.value),e.value;if(e.type==="compact"){let n=e.isBig?"compactBn":"compactNumber";return r.imports.add(n),n}if(e.type==="bitSequence")return r.imports.add(e.type),e.type;if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8"){r.imports.add("Hex"),r.typeImports.add("HexString");let n={id:"_bytesSeq",value:"Hex()",types:"HexString",directDependencies:new Set};return r.variables.has(n.id)||r.variables.set(n.id,n),n.id}if(r.variables.has(s(e.id,"circular")))return s(e.id,"circular");if(r.variables.has(s(e.id)))return s(e.id);let d=n=>z(n,t,p,r,s),o=(n,i,a)=>{r.imports.add("Vector");let l=d(i),S={id:n,value:`Vector(${(a?[l,a]:[l]).join(", ")})`,types:`Array<${O(l)}>`,directDependencies:new Set([l])};return r.variables.set(n,S),n},h=(n,i)=>{r.imports.add("Tuple");let a=i.map(d),l={id:n,value:`Tuple(${a.join(", ")})`,types:`[${a.map(O).join(", ")}]`,directDependencies:new Set(a)};return r.variables.set(n,l),n},y=(n,i)=>{r.imports.add("Struct");let a=Object.values(i).map(d),l={id:n,value:`Struct({${Object.keys(i).map((m,S)=>`${m}: ${a[S]}`).join(", ")}})`,types:`{${Object.keys(i).map((m,S)=>`${m}: ${O(a[S])}`).join(", ")}}`,directDependencies:new Set(a)};return r.variables.set(n,l),n},c=s(e.id);if(e.type==="array"){if(Y(e.value)){if(e.len===32&&(e.id===0||e.id===1)){r.imports.add("AccountId");let n="_accountId";return r.variables.set(n,{id:n,value:"AccountId()",types:"SS58String",directDependencies:new Set}),r.typeImports.add("SS58String"),n}return r.imports.add("Hex"),r.variables.set(c,{id:c,value:`Hex(${e.len})`,types:"HexString",directDependencies:new Set}),r.typeImports.add("HexString"),c}return o(c,e.value,e.len)}if(e.type==="sequence")return o(c,e.value);if(e.type==="tuple")return h(c,e.value);if(e.type==="struct")return y(c,e.value);r.imports.add("Enum");let v=Object.entries(e.value).map(([n,i])=>{if(i.type==="primitive")return r.imports.add(i.value),i.value;let a=I(c,n);if(i.type==="tuple"){if(i.value.length===1){let l,m=i.value[0];if(n.startsWith("Raw")&&m.type==="array"&&Y(m.value)){let S=`_fixedStr${m.len}`;l=S,r.variables.has(S)||(r.imports.add("fixedStr"),r.variables.set(S,{id:S,value:`fixedStr(${m.len})`,types:"string",directDependencies:new Set}))}else l=d(i.value[0]);return r.variables.has(a)||r.variables.set(a,{id:a,value:l,types:O(l),directDependencies:new Set([l])}),a}return h(a,i.value)}else y(a,i.value);return a}),b=Object.values(e.value).map(n=>n.idx),g=b.every((n,i)=>n===i),u=`{${Object.keys(e.value).map((n,i)=>`${n}: ${v[i]}`)}}${g?"":`, [${b.join(", ")}]`}`;return r.variables.set(c,{id:c,value:`Enum(${u})`,types:Object.keys(e.value).map((n,i)=>`{tag: '${n}', value: ${O(v[i])}}`).join(" | "),directDependencies:new Set(v)}),c},z=L(ye,(e,t,p,r)=>{p.imports.add("Self");let s=r(t.id),d={id:r(t.id,"circular"),types:`I${s}`,value:`Self(() => ${s})`,directDependencies:new Set([s])};return p.variables.set(d.id,d),d.id},e=>e),ve=e=>{let t={imports:new Set,typeImports:new Set(["Codec"]),variables:new Map},p=e.lookup,r=T(p),s=(a,...l)=>{let{path:m}=p[a],S=m.length===0?["cdc"+a]:["c",...m];return S.push(...l),I(...S)},d=new Map,o=a=>z(r(a),d,new Set,t,s),h=(a,l)=>{if(t.variables.has(l))return l;let m=a.map(x=>x.type).map(o),S=a.map(x=>x.name);t.imports.add("Tuple");let E={id:l,types:`[${S.map((x,V)=>`${x[0].toUpperCase()+x.slice(1)}: ${O(m[V])}`).join(", ")}]`,value:`Tuple(${m.join(", ")})`,directDependencies:new Set(m)};return t.variables.set(l,E),l},y="_emptyTuple",c=()=>(t.variables.has(y)||(t.imports.add("Tuple"),t.variables.set(y,{id:y,types:"[]",value:"Tuple()",directDependencies:new Set})),y),v=(a,l)=>{let m=e.pallets.find(j=>j.name===a).storage.items.find(j=>j.name===l);if(m.type.tag==="plain")return{key:c(),val:o(m.type.value)};let{key:S,value:E}=m.type.value,x=o(E);return{key:m.type.value.hashers.length===1?h([{name:"key",type:S}],s(S,"Tupled")):o(S),val:x}},b=a=>(l,m)=>{let S=r(e.pallets.find(x=>x.name===l)[a]);if(S.type!=="enum")throw null;let E=I(o(S.id),m);return!t.variables.has(E)&&S.value[m].type==="primitive"&&t.variables.set(E,{id:E,value:"_void",types:"undefined",directDependencies:new Set}),E},g=(a,l)=>{let m=r(e.pallets.find(x=>x.name===a).calls);if(m.type!=="enum")throw null;let S=m.value[l];if(S.type==="primitive")return c();if(S.type==="tuple")return I(o(m.id),l);let E=Object.entries(S.value).map(([x,V])=>({name:x,type:V.id}));return h(E,s(m.id,l,"Tupled"))},u=(a,l)=>{let m=e.pallets.find(S=>S.name===a).constants.find(S=>S.name===l);return o(m.type)},n=()=>{let a=`import type {${[...t.typeImports].join(", ")}} from "@polkadot-api/substrate-bindings";
`,l=`import {${[...t.imports].join(", ")}} from "@polkadot-api/substrate-bindings";

`,m=[...t.variables.values()].map(S=>`type I${S.id} = ${S.types};
const ${S.id}: Codec<I${S.id}> = ${S.value};`).join(`

`);return`${a}${l}${m}`},i=a=>M[a]??t.variables.get(a)?.types??`I${a}`;return{buildDefinition:o,buildStorage:v,buildEvent:b("events"),buildError:b("errors"),buildCall:g,buildConstant:u,getTypeFromVarName:i,getCode:n}};var f=J(require("@polkadot-api/substrate-bindings"));var he=f.Hex(),Q=e=>e.type==="primitive"&&e.value==="u8",be=(e,t,p,r)=>{if(e.type==="primitive")return f[e.value];if(e.type==="compact")return f.compact;if(e.type==="bitSequence")return f.bitSequence;if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return he;let s=g=>X(g,t,p,r),d=(g,u)=>{let n=s(g);return u?f.Vector(n,u):f.Vector(n)},o=g=>f.Tuple(...g.map(s)),h=g=>{let u=Object.fromEntries(Object.entries(g).map(([n,i])=>[n,s(i)]));return f.Struct(u)};if(e.type==="array")return Q(e.value)?e.len===32&&(e.id===0||e.id===1)?r:f.Hex(e.len):d(e.value,e.len);if(e.type==="sequence")return d(e.value);if(e.type==="tuple")return o(e.value);if(e.type==="struct")return h(e.value);let y=Object.entries(e.value).map(([g,u])=>{if(u.type==="primitive")return f._void;if(u.type==="tuple"&&u.value.length===1){let n=u.value[0];return g.startsWith("Raw")&&n.type==="array"&&Q(n.value)?f.fixedStr(n.len):s(n)}return u.type==="tuple"?o(u.value):h(u.value)}),c=Object.fromEntries(Object.keys(e.value).map((g,u)=>[g,y[u]])),v=Object.values(e.value).map(g=>g.idx);return v.every((g,u)=>g===u)?f.Enum(c):f.Enum(c,v)},X=L(be,f.Self,e=>e),ge=f.Tuple(),Se=e=>{let t=e.lookup,p=T(t),r=f.AccountId(),s=new Map,d=u=>X(p(u),s,new Set,r),o=e.pallets.find(u=>u.name==="System")?.constants.find(u=>u.name==="SS58Prefix"),h;if(o)try{let u=d(o.type).dec(o.value);typeof u=="number"&&(h=u,r=f.AccountId(u))}catch{}let y=new Map,c=(u,n)=>{let i=y.get(u);i||y.set(u,i=f.Storage(u));let a=e.pallets.find(C=>C.name===u).storage.items.find(C=>C.name===n),l=(C,...B)=>{let K=i(...B);return{...K,len:C,fallback:a.modifier===1?K.dec(a.fallback):void 0}};if(a.type.tag==="plain")return l(0,n,d(a.type.value).dec);let{key:m,value:S,hashers:E}=a.type.value,x=d(S),V=E.map(C=>f[C.tag]),j=V.length===1?[[d(m),V[0]]]:p(m).value.map((C,B)=>[d(C.id),V[B]]);return l(V.length,n,x.dec,...j)},v=(u,n)=>{let i=e.pallets.find(m=>m.name===u),a=p(i.calls);if(a.type!=="enum")throw null;let l=a.value[n];return{location:[i.index,l.idx],args:l.type==="primitive"?ge:f.Tuple(...Object.values(l.value).map(m=>d(m.id)))}},b=(u,n)=>{let i=e.pallets.find(a=>a.name===u).constants.find(a=>a.name===n);return d(i.type)},g=u=>(n,i)=>{let a=e.pallets.find(S=>S.name===n),l=p(a[u]);if(l.type!=="enum")throw null;let m=l.value[i];return{location:[a.index,m.idx],codec:m.type==="primitive"?f._void:d(l.id)}};return{buildDefinition:d,buildStorage:c,buildEvent:g("events"),buildError:g("errors"),buildCall:v,buildConstant:b,ss58Prefix:h}};var F=require("@polkadot-api/substrate-bindings");var Z=new TextEncoder,fe=Z.encode.bind(Z),k=(e,t)=>{let p=typeof t=="string",r=new Uint8Array((e.length+(p?1:0))*8),s=new DataView(r.buffer),d=0;p&&(s.setBigUint64(d,(0,F.h64)(fe(t))),d+=8);for(let o=0;o<e.length;o++,d+=8)s.setBigUint64(d,e[o]);return(0,F.h64)(r)},H={_void:0n,bool:1n,char:2n,str:3n,u8:4n,u16:5n,u32:6n,u64:7n,u128:8n,u256:9n,i8:5n,i16:5n,i32:6n,i64:7n,i128:8n,i256:9n,compacts:10n,compactb:11n,bitSequence:12n,historicMetaCompat:13n},De=14n,xe=(e,t,p)=>{if(t.has(e.id))return t.get(e.id);if(e.type==="primitive")return H[e.value];if(e.type==="compact")return H[e.isBig?"compactb":"compacts"];if(e.type==="bitSequence")return H.bitSequence;if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return De;let r=c=>ee(c,t,p),s=(c,v)=>{let b=r(c);return v?k([b,BigInt(v)],"Vector(,)"):k([b],"Vector()")},d=c=>k(c.map(r)),o=c=>k(Object.values(c).map(r),JSON.stringify(Object.keys(c)));if(e.type==="array")return s(e.value,e.len);if(e.type==="sequence")return s(e.value);if(e.type==="tuple")return d(e.value);if(e.type==="struct")return o(e.value);let h=Object.values(e.value).map(c=>c.type==="primitive"?0n:c.type==="tuple"?d(c.value):o(c.value)),y=Object.keys(e.value);return y.push("Enum"),k(h,JSON.stringify({Enum:y}))},ee=L(xe,()=>0n,e=>e),Ee=e=>{let t=e.lookup,p=T(t),r=new Map,s=b=>ee(p(b),r,new Set),d=(b,g)=>{try{let u=e.pallets.find(m=>m.name===b).storage.items.find(m=>m.name===g);if(u.type.tag==="plain")return k([s(u.type.value)]);let{key:n,value:i}=u.type.value,a=s(i),l=u.type.value.hashers.length===1?k([s(n)]):s(n);return k([a,l])}catch{return null}},o=b=>{if(b.type==="primitive")return 0n;let g=Object.values(b.value).map(u=>s(u.id));return b.type==="tuple"?k(g):k(g,JSON.stringify(Object.keys(b.value)))},h=(b,g)=>{try{let u=e.pallets.find(i=>i.name===b),n=p(u.calls);if(n.type!=="enum")throw null;return o(n.value[g])}catch{return null}},y=b=>(g,u)=>{try{let n=e.pallets.find(a=>a.name===g),i=p(n[b]);if(i.type!=="enum")throw null;return o(i.value[u])}catch{return null}},c=(b,g)=>{try{let u=e.pallets.find(n=>n.name===b).constants.find(n=>n.name===g);return s(u.type)}catch{return null}},v=b=>(...g)=>b(...g)?.toString(32)??null;return{buildDefinition:v(s),buildStorage:v(d),buildCall:v(h),buildEvent:v(y("events")),buildError:v(y("errors")),buildConstant:v(c)}};var oe=require("@polkadot-api/utils"),A=require("@polkadot-api/substrate-bindings");var R=require("@polkadot-api/utils"),D=J(require("@polkadot-api/substrate-bindings")),ke=R.toHex,te=(e,t)=>D.createDecoder(p=>{let r=p,s=r.i,d=e(r),o=ke(new Uint8Array(r.buffer.slice(s,r.i)));return{...t,value:d,input:o}}),_=(e,t,p)=>{let r=te(t,{codec:e,...p});return Object.assign(r,{shape:{codec:e}})},q=(e,t,p)=>{let r=te(t,{codec:e.codec,...p});return Object.assign(r,{shape:e})},U=(e=42)=>{let t=D.enhanceDecoder(D.AccountId(e).dec,p=>({address:p,ss58Prefix:e}));return _("AccountId",t,{})},Ve=e=>_("BytesArray",D.Hex.dec(e),{len:e}),Ce=["_void","bool","char","str","u8","u16","u32","i8","i16","i32","u64","u128","u256","i64","i128","i256","compactNumber","compactBn","bitSequence"],Te=Object.fromEntries(Ce.map(e=>[e,_(e,D[e].dec)])),P={...Te,Bytes:_("Bytes",D.Hex.dec()),BytesArray:Ve,AccountId:U()},Pe=e=>q({codec:"Sequence",shape:e.shape},D.Vector.dec(e)),Le=(e,t)=>q({codec:"Array",shape:e.shape,len:t},D.Vector.dec(e,t)),we=(...e)=>q({codec:"Tuple",shape:e.map(t=>t.shape)},D.Tuple.dec(...e)),Ae=e=>q({codec:"Struct",shape:(0,R.mapStringRecord)(e,t=>t.shape)},D.Struct.dec(e)),Oe=(e,t)=>q({codec:"Enum",shape:(0,R.mapStringRecord)(e,p=>p.shape)},D.Enum.dec(e,t)),re=e=>{let t=r=>{let s=e(),d=s;return t=s,d(r)},p=r=>t(r);return p.shape={codec:"_void"},p},w={Sequence:Pe,Array:Le,Tuple:we,Struct:Ae,Enum:Oe};var N=(e,t,p)=>{let r=(0,A.enhanceDecoder)(e,s=>({...s,[t]:p}));return r.shape=e.shape,r},je=e=>(t,p,r,s,...d)=>{let{path:o}=s[t.id],h=e(t,p,r,s,...d);return o.length?N(h,"path",o):h},Re=(e,t,p,r,s)=>{if(e.type==="primitive")return P[e.value];if(e.type==="compact")return e.isBig?P.compactBn:P.compactNumber;if(e.type==="bitSequence")return P.bitSequence;if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return P.Bytes;let d=i=>ie(i,t,p,r,s),o=(i,a)=>{let l=d(i);return a?w.Array(l,a):w.Sequence(l)},h=(i,a)=>N(w.Tuple(...i.map(d)),"innerDocs",a),y=(i,a)=>N(w.Struct((0,oe.mapStringRecord)(i,d)),"innerDocs",a);if(e.type==="array")return e.value.type==="primitive"&&e.value.value==="u8"?e.len===32&&(e.id===0||e.id===1)?s:P.BytesArray(e.len):o(e.value,e.len);if(e.type==="sequence")return o(e.value);if(e.type==="tuple")return h(e.value,e.innerDocs);if(e.type==="struct")return y(e.value,e.innerDocs);let c=Object.values(e.value).map(i=>i.type==="primitive"?P._void:i.type==="tuple"&&i.value.length===1?d(i.value[0]):i.type==="tuple"?h(i.value,i.innerDocs):y(i.value,i.innerDocs)),v=Object.fromEntries(Object.keys(e.value).map((i,a)=>[i,c[a]])),b=Object.values(e.value).map(i=>i.idx),u=b.every((i,a)=>i===a)?w.Enum(v):w.Enum(v,b),n=(0,A.enhanceDecoder)(u,i=>{let a=e.innerDocs[i.value.tag];return{...i,docs:a}});return n.shape=u.shape,n},qe=je(Re),ie=L(qe,re,(e,t)=>(t.shape=e.shape,e)),ne=e=>`0x${e.toString(16).padEnd(2,"0")}`,ae=e=>{let t=e.lookup,p=new Map,r=c=>ie(s(c),p,new Set,t,d),s=T(t),d=P.AccountId,o=e.pallets.find(c=>c.name==="System")?.constants.find(c=>c.name==="SS58Prefix");if(o)try{let c=r(o.type)(o.value).value;typeof c=="number"&&(d=U(c))}catch{}let h=c=>{let v=r(c);return{shape:v.shape,decoder:v}},y=(0,A.createDecoder)(c=>{let v=A.u8.dec(c),b=e.pallets.find(a=>a.index===v);if(!b)throw new Error("Invalid Pallet");let g={value:{name:b.name,idx:v},input:ne(c[0])},u=r(b.calls),n=u(c);if(n.codec!=="Enum")throw null;let i={value:{name:n.value.tag,idx:c[1]},input:ne(c[1]),docs:n.docs};return{pallet:g,call:i,args:{value:n.value.value,shape:u.shape}}});return{buildDefinition:h,callDecoder:y}};
//# sourceMappingURL=index.js.map