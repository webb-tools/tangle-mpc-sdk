var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/client.ts
import {
  createClient as createRawClient
} from "@polkadot-api/substrate-client";

// src/storage.ts
import {
  debounceTime,
  distinctUntilChanged,
  exhaustMap,
  map,
  mergeMap,
  withLatestFrom
} from "rxjs";

// src/utils/shareLatest.ts
import { ReplaySubject, share } from "rxjs";
var shareLatest = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// src/utils/switchMapComplete.ts
import { Observable as Observable2 } from "rxjs";
function switchMapComplete(project) {
  return (source) => new Observable2((observer) => {
    let innerSubscription = null;
    let outterSubscription = source.subscribe({
      next(v) {
        innerSubscription?.unsubscribe();
        innerSubscription = project(v).subscribe({
          next(iV) {
            observer.next(iV);
          },
          error(e) {
            observer.error(e);
          }
        });
      },
      complete() {
        observer.complete();
      },
      error(e) {
        observer.error(e);
      }
    });
    return () => {
      innerSubscription?.unsubscribe();
      outterSubscription.unsubscribe();
      innerSubscription = null;
    };
  });
}

// src/utils/firstValueFromWithSignal.ts
import { noop } from "rxjs";
function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    const onAbort = signal ? () => {
      subscription.unsubscribe();
    } : noop;
    let isDone = false;
    const subscription = source.subscribe({
      next: (value) => {
        resolve(value);
        isDone = true;
        subscription?.unsubscribe();
      },
      error: (e) => {
        reject(e);
        signal?.removeEventListener("abort", onAbort);
      },
      complete: () => {
        reject(new Error("Observable completed without emitting"));
        signal?.removeEventListener("abort", onAbort);
      }
    });
    if (isDone) {
      subscription.unsubscribe();
    } else {
      signal?.addEventListener("abort", onAbort);
    }
  });
}

// src/utils/lazyScan.ts
import { defer, scan } from "rxjs";
var lazyScan = (reducer, getInit) => (base) => defer(() => base.pipe(scan(reducer, getInit())));

// src/utils/concatMapEager.ts
import { defer as defer2, Observable as Observable5 } from "rxjs";
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new Observable5((observer) => {
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (topSubscription.closed && innerSubscriptions.size === 0) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    innerSubscriptions.set(
      idx,
      inner$.subscribe({
        next(x) {
          if (observerIdx === idx) {
            observer.next(x);
          } else {
            results.get(idx).push(x);
          }
        },
        complete() {
          innerSubscriptions.delete(idx);
          if (idx === observerIdx) {
            observerIdx++;
            while (results.has(observerIdx)) {
              results.get(observerIdx).forEach((x) => observer.next(x));
              results.delete(observerIdx);
              if (innerSubscriptions.has(observerIdx)) {
                break;
              }
              observerIdx++;
            }
          }
          nextSubscription();
        },
        error(e) {
          observer.error(e);
        }
      })
    );
  };
  const topSubscription = source$.subscribe({
    next(outterValue) {
      const idx = mapperIdx++;
      queues.set(
        idx,
        defer2(() => mapper(outterValue, idx))
      );
      if (innerSubscriptions.size < concurrent) {
        nextSubscription();
      }
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (innerSubscriptions.size === 0) {
        observer.complete();
      }
    }
  });
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// src/utils/withoutComplete.ts
import { Observable as Observable6 } from "rxjs";
var withoutComplete = (source) => new Observable6(
  (observer) => source.subscribe({
    next(x) {
      observer.next(x);
    },
    error(e) {
      observer.error(e);
    }
  })
);

// src/storage.ts
var isOptionalArg = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createStorageEntry = (checksum, pallet, name, getRuntimeContext$, storage$, finalized$) => {
  const storageCall = (at, mapper, signal) => {
    const request$ = getRuntimeContext$(at).pipe(
      mergeMap((descriptors) => {
        const actualChecksum = descriptors.checksumBuilder.buildStorage(
          pallet,
          name
        );
        const codecs = descriptors.dynamicBuilder.buildStorage(pallet, name);
        if (checksum !== actualChecksum)
          throw new Error(
            `Incompatible runtime entry Storage(${pallet}.${name})`
          );
        const [block, args, decoder] = mapper(codecs);
        return storage$(block, ...args).pipe(map(decoder));
      })
    );
    return firstValueFromWithSignal(request$, signal);
  };
  const watchValue = (...args) => {
    const descriptors$ = finalized$.pipe(
      mergeMap(getRuntimeContext$),
      distinctUntilChanged(),
      map(
        (descriptors) => descriptors.dynamicBuilder.buildStorage(pallet, name)
      )
    );
    return finalized$.pipe(
      debounceTime(0),
      withLatestFrom(descriptors$),
      exhaustMap(
        ([latest, codecs]) => storage$(latest, "value", codecs.enc(...args), null).pipe(
          map((val) => ({ val, codecs }))
        )
      ),
      distinctUntilChanged((a, b) => a.val === b.val),
      map(
        ({ codecs, val }) => val === null ? codecs.fallback : codecs.dec(val)
      )
    );
  };
  const getValue = (...args) => {
    const invalidArgs = () => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    return storageCall(
      at ?? null,
      (codecs) => {
        const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
        if (args !== actualArgs && !isLastArgOptional)
          throw invalidArgs();
        const key = codecs.enc(...actualArgs);
        return [
          at,
          ["value", key, null],
          (response) => response === null ? codecs.fallback : codecs.dec(response)
        ];
      },
      signal
    );
  };
  const getEntries = (...args) => {
    const invalidArgs = () => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    return storageCall(
      at,
      (codecs) => {
        if (args.length > codecs.len)
          throw invalidArgs();
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs();
        return [
          at,
          ["descendantsValues", codecs.enc(...actualArgs), null],
          (x) => {
            return x.map(({ key, value }) => ({
              keyArgs: codecs.keyDecoder(key),
              value: codecs.dec(value)
            }));
          }
        ];
      },
      signal
    );
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  return { getValue, getValues, getEntries, watchValue };
};

// src/observableClient/chainHead/enhancers/operationLimitRecovery.ts
import { OperationLimitError } from "@polkadot-api/substrate-client";
import { Observable as Observable8 } from "rxjs";
var PendingTaskQueue = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value) {
    const newNode = { value };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value) {
    this.first = { value, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    const result = this.first?.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        delete this.first.prev?.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
};
var getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable, cb) => {
    tearDownOperations.set(observable, () => {
      tearDownOperations.delete(observable);
      cb();
    });
  };
  const teardown = (observable) => {
    tearDownOperations.get(observable)?.();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data)
      return;
    tearDownOperations.delete(data.source$);
    process(data);
  };
  const process = (data) => {
    const { source$, observer } = data;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        teardown(source$);
        if (e instanceof OperationLimitError)
          return addTask(data, true);
        observer.error(e);
        onEmptySlot();
      },
      complete() {
        observer.complete();
        onEmptySlot();
      }
    });
    if (!observer.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
      });
    }
  };
  const withRecovery = (topPriority = false) => (source$) => new Observable8((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery, withRecoveryFn };
};

// src/observableClient/chainHead/enhancers/unpin.ts
import {
  Observable as Observable9,
  Subject,
  filter,
  map as map2,
  merge,
  mergeMap as mergeMap2,
  pairwise,
  share as share2,
  skip,
  startWith
} from "rxjs";
var getWithUnpinning$ = (finalized$, follow$, unpin) => {
  const userUsageInput$ = new Subject();
  const userUsage$ = new Observable9((observer) => {
    const userSub = userUsageInput$.subscribe((value) => {
      observer.next({ ...value, isUser: true });
    });
    const finSub = finalized$.subscribe({
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    return () => {
      userSub.unsubscribe();
      finSub.unsubscribe();
    };
  });
  const internalUsage$ = finalized$.pipe(
    startWith(""),
    pairwise(),
    mergeMap2(([prev, current]) => [
      { type: "release", hash: prev, isUser: false },
      { type: "hold", hash: current, isUser: false }
    ]),
    skip(1)
  );
  const unpinFromUsage$ = merge(internalUsage$, userUsage$).pipe(
    lazyScan(
      (acc, { isUser, type, hash }) => {
        const { counters, bestBlocks } = acc;
        for (const hash2 in counters)
          if (!counters[hash2])
            delete counters[hash2];
        if (isUser && type === "hold" && !counters[hash]) {
          bestBlocks[hash] || (bestBlocks[hash] = 0);
          bestBlocks[hash]++;
          return acc;
        }
        if (isUser && type === "release" && bestBlocks[hash]) {
          if (!--bestBlocks[hash])
            delete bestBlocks[hash];
          return acc;
        }
        if (type === "release") {
          counters[hash]--;
        } else {
          counters[hash] || (counters[hash] = 0);
          counters[hash]++;
          if (!isUser && bestBlocks[hash]) {
            counters[hash] += bestBlocks[hash];
            delete bestBlocks[hash];
          }
        }
        return acc;
      },
      () => ({
        counters: {},
        bestBlocks: {}
      })
    ),
    map2(
      (acc) => Object.entries(acc.counters).filter(([, value]) => value === 0).map(([key]) => key)
    ),
    filter((x) => x.length > 0),
    share2()
  );
  const unpinFromPrunned$ = follow$.pipe(
    filter((e) => e.type === "finalized"),
    map2((e) => e.prunedBlockHashes)
  );
  merge(unpinFromUsage$, unpinFromPrunned$).pipe(filter((x) => x.length > 0)).subscribe((hashes) => {
    unpin(hashes);
  });
  const onHold = (hash) => {
    userUsageInput$.next({ type: "hold", hash });
  };
  const onRelease = (hash) => {
    setTimeout(() => {
      userUsageInput$.next({ type: "release", hash });
    }, 0);
  };
  const withUnpinning$ = (fn) => (hash, ...args) => {
    const base$ = fn(hash, ...args);
    return new Observable9((observer) => {
      onHold(hash);
      const subscription = base$.subscribe(observer);
      return () => {
        subscription.unsubscribe();
        onRelease(hash);
      };
    });
  };
  return { withUnpinning$, unpinFromUsage$ };
};

// src/observableClient/chainHead/enhancers/optionalHash.ts
import {
  Observable as Observable10,
  ReplaySubject as ReplaySubject2,
  concat,
  mergeMap as mergeMap3,
  of,
  share as share3,
  take,
  takeWhile
} from "rxjs";
var DONE = Symbol("DONE");
var delayUnsubscription = (source$) => new Observable10((observer) => {
  const subscription = source$.subscribe(observer);
  return () => {
    setTimeout(() => {
      subscription.unsubscribe();
    }, 0);
  };
});
var getWithOptionalhash$ = (finalized$) => {
  const current$ = finalized$.pipe(
    take(1),
    withoutComplete,
    share3({
      connector: () => new ReplaySubject2(1),
      resetOnError: true,
      resetOnRefCountZero: true,
      resetOnComplete: false
    }),
    delayUnsubscription
  );
  return (fn) => (hash, ...args) => hash ? fn(hash, ...args) : current$.pipe(
    mergeMap3((h) => concat(fn(h, ...args), of(DONE))),
    takeWhile((x) => x !== DONE)
  );
};

// src/observableClient/chainHead/enhancers/fromAbortControllerFn.ts
import { Observable as Observable11 } from "rxjs";
var fromAbortControllerFn = (fn) => (...args) => new Observable11((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value) => {
      observer.next(value);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

// src/observableClient/chainHead/enhancers/lazyFollower.ts
var withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

// src/observableClient/chainHead/enhancers/operationInaccessibleRecovery.ts
import { OperationInaccessibleError } from "@polkadot-api/substrate-client";
import { catchError, concatMap, throwError, timer } from "rxjs";
var operable = (source$) => {
  const result = source$.pipe(
    catchError(
      (e) => e instanceof OperationInaccessibleError ? timer(750).pipe(concatMap(() => result)) : throwError(() => e)
    )
  );
  return result;
};
var withOperationInaccessibleRecovery = (fn) => (...args) => operable(fn(...args));

// src/observableClient/chainHead/streams/runtime.ts
import { distinctUntilChanged as distinctUntilChanged2, map as map3, scan as scan2 } from "rxjs";
var getRuntime$ = (follow$) => {
  const shared = follow$.pipe(
    scan2(
      (acc, event) => {
        if (event.type === "initialized") {
          acc.candidates.clear();
          acc.current = event.finalizedBlockRuntime;
        }
        if (event.type === "newBlock" && event.newRuntime)
          acc.candidates.set(event.blockHash, event.newRuntime);
        if (event.type !== "finalized")
          return acc;
        const [newRuntimeHash] = event.finalizedBlockHashes.filter((h) => acc.candidates.has(h)).slice(-1);
        if (newRuntimeHash)
          acc.current = acc.candidates.get(newRuntimeHash);
        acc.candidates.clear();
        return acc;
      },
      {
        candidates: /* @__PURE__ */ new Map(),
        current: {}
      }
    ),
    shareLatest
  );
  const candidates$ = shared.pipe(map3((x) => x.candidates));
  const runtime$ = shared.pipe(
    map3((x) => x.current),
    distinctUntilChanged2(),
    shareLatest
  );
  return { runtime$, candidates$ };
};

// src/observableClient/chainHead/streams/follow.ts
import { Observable as Observable14, noop as noop2, share as share4 } from "rxjs";
var getFollow$ = (chainHead) => {
  let follower;
  let unfollow = noop2;
  const follow$ = new Observable14((observer) => {
    follower = chainHead(
      true,
      (e) => {
        observer.next(e);
      },
      (e) => {
        console.warn("chainHead crashed");
        console.error(e);
        observer.error(e);
      }
    );
    unfollow = () => {
      observer.complete();
      follower.unfollow();
    };
  }).pipe(share4());
  return {
    getFollower: () => {
      if (!follower)
        throw new Error("Missing chainHead subscription");
      return follower;
    },
    unfollow: () => {
      unfollow();
    },
    follow$
  };
};

// src/observableClient/chainHead/streams/finalized.ts
import { mergeMap as mergeMap4 } from "rxjs";
var getFinalized$ = (follow$) => follow$.pipe(
  mergeMap4((e) => {
    if (e.type === "finalized")
      return e.finalizedBlockHashes;
    if (e.type !== "initialized")
      return [];
    return [e.finalizedBlockHash];
  }),
  shareLatest
);

// src/observableClient/chainHead/streams/metadata$.ts
import { Tuple, compact, metadata } from "@polkadot-api/substrate-bindings";
import { map as map4, startWith as startWith2, withLatestFrom as withLatestFrom2 } from "rxjs";
var opaqueMeta = Tuple(compact, metadata);
var getMetadata$ = (call$, runtime$, finalized$) => {
  const _getMetadata$ = ([, hash]) => call$(hash, "Metadata_metadata", "").pipe(
    map4((response) => {
      const metadata2 = opaqueMeta.dec(response)[1];
      if (metadata2.metadata.tag !== "v14")
        throw new Error("Wrong metadata version");
      return metadata2.metadata.value;
    }),
    startWith2(null)
  );
  return runtime$.pipe(
    withLatestFrom2(finalized$),
    switchMapComplete(_getMetadata$),
    shareLatest
  );
};

// src/observableClient/chainHead/chainHead.ts
import {
  EMPTY,
  Observable as Observable17,
  asapScheduler,
  filter as filter3,
  from,
  map as map6,
  mergeAll,
  mergeMap as mergeMap5,
  observeOn,
  pipe,
  shareReplay,
  take as take2,
  withLatestFrom as withLatestFrom4
} from "rxjs";
import {
  getChecksumBuilder,
  getDynamicBuilder
} from "@polkadot-api/metadata-builders";
import {
  AccountId,
  blockHeader
} from "@polkadot-api/substrate-bindings";

// src/observableClient/chainHead/streams/best-block.ts
import {
  Observable as Observable16,
  Subject as Subject2,
  concatMap as concatMap2,
  startWith as startWith3,
  tap,
  withLatestFrom as withLatestFrom3
} from "rxjs";
import { combineLatest, filter as filter2, map as map5 } from "rxjs";
var getBestBlock$ = (follow$) => follow$.pipe(
  filter2((e) => e.type === "bestBlockChanged"),
  map5((e) => e.bestBlockHash),
  shareLatest
);
var getBestBlocks$ = (best$, finalized$, getHeader$) => {
  const _current$ = new Subject2();
  const getBlocks$ = (best, finalized, current) => new Observable16((observer) => {
    const result = /* @__PURE__ */ new Map();
    let sub;
    const process = (hash) => {
      if (hash === finalized) {
        observer.next(result);
        observer.complete();
        return;
      }
      const header = current.get(hash);
      if (header) {
        result.set(hash, header);
        process(header.parentHash);
        return;
      }
      sub = getHeader$(hash).subscribe({
        next(header2) {
          result.set(hash, header2);
          process(header2.parentHash);
        },
        error(e) {
          observer.error(e);
        }
      });
    };
    process(best);
    return () => {
      sub?.unsubscribe();
    };
  });
  return combineLatest({ best: best$, finalized: finalized$ }).pipe(
    withLatestFrom3(_current$.pipe(startWith3(/* @__PURE__ */ new Map()))),
    concatMap2(
      ([{ best, finalized }, current]) => getBlocks$(best, finalized, current).pipe(
        tap((x) => {
          _current$.next(x);
        }),
        map5((state) => {
          const result = [];
          let hash = best;
          while (hash !== finalized) {
            const header = state.get(hash);
            result.push({ hash, header });
            hash = header.parentHash;
          }
          return result;
        })
      )
    ),
    shareLatest
  );
};

// src/observableClient/chainHead/chainHead.ts
var chainHead_default = (chainHead) => () => {
  const { getFollower, unfollow, follow$ } = getFollow$(chainHead);
  const lazyFollower = withLazyFollower(getFollower);
  const { runtime$, candidates$: runtimeCandidates$ } = getRuntime$(follow$);
  const _finalized$ = getFinalized$(follow$);
  const bestBlock$ = getBestBlock$(follow$);
  const { withUnpinning$, unpinFromUsage$ } = getWithUnpinning$(
    _finalized$,
    follow$,
    lazyFollower("unpin")
  );
  const withOptionalHash$ = getWithOptionalhash$(_finalized$);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const commonEnhancer = (fn) => withOptionalHash$(withUnpinning$(withRecoveryFn(fromAbortControllerFn(fn))));
  const call$ = commonEnhancer(lazyFollower("call"));
  const body$ = commonEnhancer(lazyFollower("body"));
  const storage$ = withOperationInaccessibleRecovery(
    commonEnhancer(lazyFollower("storage"))
  );
  const lazyHeader = lazyFollower("header");
  const header$ = pipe(
    withUnpinning$((hash) => from(lazyHeader(hash))),
    map6(blockHeader.dec)
  );
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new Observable17(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        observer.next(
          recoveralStorage$(
            hash,
            queries.slice(-nDiscarded),
            childTrie,
            true
          )
        );
      }
    )
  ).pipe(mergeAll(), withRecovery(isHighPriority));
  const storageQueries$ = withOperationInaccessibleRecovery(
    withOptionalHash$(
      withUnpinning$(
        (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false)
      )
    )
  );
  const metadata$ = getMetadata$(call$, runtime$, _finalized$);
  const runtimeContext$ = runtime$.pipe(
    map6(() => {
      const result = metadata$.pipe(
        filter3(Boolean),
        map6((metadata2) => {
          const checksumBuilder = getChecksumBuilder(metadata2);
          const dynamicBuilder = getDynamicBuilder(metadata2);
          const events = dynamicBuilder.buildStorage("System", "Events");
          return {
            checksumBuilder,
            dynamicBuilder,
            events: {
              key: events.enc(),
              dec: events.dec
            },
            accountId: AccountId(dynamicBuilder.ss58Prefix)
          };
        }),
        take2(1),
        shareReplay(1)
      );
      result.subscribe();
      return result;
    }),
    shareLatest
  );
  metadata$.subscribe();
  const currentFinalized$ = new Observable17((observer) => {
    let latestRuntimeCtx;
    const toRemove = /* @__PURE__ */ new Set();
    const result = {};
    const sub1 = runtimeContext$.subscribe({
      next(v) {
        latestRuntimeCtx = v;
      },
      error(e) {
        observer.error(e);
      }
    });
    const sub2 = unpinFromUsage$.subscribe({
      next(v) {
        v.forEach((x) => {
          if (result[x])
            delete result[x];
          else
            toRemove.add(x);
        });
      },
      error(e) {
        observer.error(e);
      }
    });
    const sub3 = _finalized$.pipe(observeOn(asapScheduler)).subscribe({
      next(v) {
        if (toRemove.has(v))
          toRemove.delete(v);
        else
          result[v] = latestRuntimeCtx;
        observer.next(result);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    return () => {
      sub3.unsubscribe();
      sub2.unsubscribe();
      sub1.unsubscribe();
    };
  }).pipe(
    map6((x) => ({ ...x })),
    shareLatest
  );
  const getRuntimeContext$ = withOptionalHash$(
    (hash) => currentFinalized$.pipe(
      withLatestFrom4(runtimeCandidates$),
      take2(1),
      mergeMap5(
        ([x, runtimeCandidates]) => x[hash] ?? (runtimeCandidates.has(hash) ? EMPTY : Object.values(x).slice(-1)[0])
      )
    )
  );
  currentFinalized$.subscribe();
  const bestBlocks$ = getBestBlocks$(bestBlock$, _finalized$, header$);
  const finalizedHeader$ = _finalized$.pipe(
    concatMapEager(
      (hash) => header$(hash).pipe(map6((header) => ({ hash, header })))
    ),
    shareLatest
  );
  finalizedHeader$.subscribe();
  const finalized$ = finalizedHeader$.pipe(map6((x) => x.hash));
  return {
    finalized$,
    finalizedHeader$,
    bestBlock$,
    bestBlocks$,
    follow$,
    runtime$,
    metadata$,
    body$,
    call$,
    storage$,
    storageQueries$,
    unfollow,
    getRuntimeContext$
  };
};

// src/observableClient/tx.ts
import { Observable as Observable18 } from "rxjs";
var terminalTxEvents = /* @__PURE__ */ new Set(["error", "finalized", "invalid", "dropped"]);
var tx_default = (baseTransaction) => (transaction) => new Observable18(
  (observer) => baseTransaction(
    transaction,
    (event) => {
      if (event.type === "error")
        return observer.error(new Error(event.error));
      observer.next(event);
      if (terminalTxEvents.has(event.type))
        observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  )
);

// src/observableClient/getObservableClient.ts
var getObservableClient = ({
  chainHead,
  transaction,
  destroy
}) => ({
  chainHead$: chainHead_default(chainHead),
  tx$: tx_default(transaction),
  destroy
});

// src/tx.ts
import {
  firstValueFrom,
  lastValueFrom,
  map as map7,
  mergeMap as mergeMap6,
  of as of2,
  take as take3
} from "rxjs";
import { mergeUint8, toHex } from "@polkadot-api/utils";
var getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.tag === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => x.event);
  const lastEvent = events[events.length - 1];
  const ok = lastEvent.tag === "System" && lastEvent.value.tag === "ExtrinsicSuccess";
  return { ok, events };
};
var createTxEntry = (descriptor, pallet, name, getRuntimeContext$, client, storage$, signer) => {
  const getCallDataAndEventDec$ = (...decodedArgs) => getRuntimeContext$(null).pipe(
    map7(({ events, checksumBuilder, dynamicBuilder }) => {
      const checksum = checksumBuilder.buildCall(pallet, name);
      if (checksum !== descriptor)
        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
      const { location, args } = dynamicBuilder.buildCall(pallet, name);
      return {
        callData: mergeUint8(new Uint8Array(location), args.enc(decodedArgs)),
        events
      };
    })
  );
  const getCallData = (...args) => firstValueFrom(getCallDataAndEventDec$(...args)).then(
    (x) => toHex(x.callData)
  );
  const getTx = (from2, ...args) => firstValueFrom(
    getCallDataAndEventDec$(...args).pipe(
      mergeMap6(({ callData }) => signer(from2, callData)),
      map7(toHex)
    )
  );
  const submit = async (from2, ...args) => {
    const [tx, { key, dec }] = await firstValueFrom(
      getCallDataAndEventDec$(...args).pipe(
        mergeMap6(
          ({ callData, events }) => signer(from2, callData).then((result2) => ({
            result: result2,
            events
          }))
        ),
        map7((x) => [toHex(x.result), x.events])
      )
    );
    const result = await lastValueFrom(client.tx$(tx));
    switch (result.type) {
      case "invalid":
        throw new Error("Invalid");
      case "dropped":
        throw new Error("Dropped");
      case "finalized": {
        const systemEvents = await firstValueFrom(
          storage$(result.block.hash, "value", key, null).pipe(
            map7((x) => dec(x))
          )
        );
        return getTxSuccessFromSystemEvents(
          systemEvents,
          Number(result.block.index)
        );
      }
      default:
        return { ok: true, events: [] };
    }
  };
  const submit$ = (from2, ...args) => getCallDataAndEventDec$(...args).pipe(
    mergeMap6(
      ({ callData, events }) => signer(from2, callData).then((result) => ({
        result,
        events
      }))
    ),
    take3(1),
    mergeMap6(({ result, events: { key, dec } }) => {
      return client.tx$(toHex(result)).pipe(
        mergeMap6((result2) => {
          switch (result2.type) {
            case "invalid":
              throw new Error("Invalid");
            case "dropped":
              throw new Error("Dropped");
            case "finalized": {
              return storage$(result2.block.hash, "value", key, null).pipe(
                map7((x) => dec(x)),
                map7((events) => ({
                  ...result2,
                  ...getTxSuccessFromSystemEvents(
                    events,
                    Number(result2.block.index)
                  )
                }))
              );
            }
            default:
              return of2(result2);
          }
        })
      );
    })
  );
  return { getCallData, getTx, submit, submit$ };
};

// src/client.ts
import { firstValueFrom as firstValueFrom3 } from "rxjs";

// src/event.ts
import { firstValueFrom as firstValueFrom2, map as map8, mergeMap as mergeMap7 } from "rxjs";
var createEventEntry = (checksum, pallet, name, getRuntimeContext$, finalized, storage$) => {
  const shared$ = finalized.pipe(
    concatMapEager(
      (block) => getRuntimeContext$(block).pipe(map8((context) => ({ context, block })))
    ),
    concatMapEager(
      ({
        block,
        context: {
          events: { key, dec },
          checksumBuilder
        }
      }) => {
        const actualChecksum = checksumBuilder.buildEvent(pallet, name);
        if (checksum !== actualChecksum)
          throw new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
        return storage$(block, "value", key, null).pipe(
          map8((x) => {
            const events = dec(x);
            const winners = events.filter(
              (e) => e.event.tag === pallet && e.event.value.tag === name
            );
            return winners.map((x2) => {
              return {
                meta: {
                  phase: x2.phase,
                  blockHash: block
                },
                payload: x2.event.value.value
              };
            });
          })
        );
      }
    ),
    shareLatest
  );
  const watch = (f) => shared$.pipe(mergeMap7((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => firstValueFrom2(shared$);
  const filter4 = (events) => events.filter((e) => e.tag === pallet && e.value.tag === name).map((x) => x.value.value);
  return { watch, pull, filter: filter4 };
};

// src/client.ts
import { mapObject } from "@polkadot-api/utils";
var createNamespace = (descriptors, createTxFromAddress, chainHead, client) => {
  const query = {};
  for (const pallet in descriptors) {
    query[pallet] || (query[pallet] = {});
    const [stgEntries] = descriptors[pallet];
    for (const name in stgEntries) {
      query[pallet][name] = createStorageEntry(
        stgEntries[name],
        pallet,
        name,
        chainHead.getRuntimeContext$,
        chainHead.storage$,
        chainHead.finalized$
      );
    }
  }
  const tx = {};
  for (const pallet in descriptors) {
    tx[pallet] || (tx[pallet] = {});
    const [, txEntries] = descriptors[pallet];
    for (const name in txEntries) {
      tx[pallet][name] = createTxEntry(
        txEntries[name],
        pallet,
        name,
        chainHead.getRuntimeContext$,
        client,
        chainHead.storage$,
        createTxFromAddress
      );
    }
  }
  const events = {};
  for (const pallet in descriptors) {
    events[pallet] || (events[pallet] = {});
    const [, , evEntries] = descriptors[pallet];
    for (const name in evEntries) {
      events[pallet][name] = createEventEntry(
        evEntries[name],
        pallet,
        name,
        chainHead.getRuntimeContext$,
        chainHead.finalized$,
        chainHead.storage$
      );
    }
  }
  return {
    query,
    tx,
    event: events
  };
};
var createClient = (connect, descriptors) => {
  let createTx;
  const rawClient = createRawClient((onMsg) => {
    const result = connect(onMsg);
    createTx = result.createTx;
    return result;
  });
  const client = getObservableClient(rawClient);
  const chainHead = client.chainHead$();
  const createTxFromAddress = async (address, callData) => {
    const { accountId } = await firstValueFrom3(
      chainHead.getRuntimeContext$(null)
    );
    return createTx(accountId.enc(address), callData);
  };
  return {
    finalized$: chainHead.finalized$,
    bestBlock$: chainHead.bestBlock$,
    bestBlocks$: chainHead.bestBlocks$,
    ...mapObject(
      descriptors,
      (des) => createNamespace(des, createTxFromAddress, chainHead, client)
    )
  };
};
export {
  createClient,
  getObservableClient
};
//# sourceMappingURL=index.mjs.map