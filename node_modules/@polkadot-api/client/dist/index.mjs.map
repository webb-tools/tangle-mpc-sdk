{"version":3,"sources":["../src/client.ts","../src/storage.ts","../src/utils/shareLatest.ts","../src/utils/switchMapComplete.ts","../src/utils/firstValueFromWithSignal.ts","../src/utils/lazyScan.ts","../src/utils/concatMapEager.ts","../src/utils/withoutComplete.ts","../src/observableClient/chainHead/enhancers/operationLimitRecovery.ts","../src/observableClient/chainHead/enhancers/unpin.ts","../src/observableClient/chainHead/enhancers/optionalHash.ts","../src/observableClient/chainHead/enhancers/fromAbortControllerFn.ts","../src/observableClient/chainHead/enhancers/lazyFollower.ts","../src/observableClient/chainHead/enhancers/operationInaccessibleRecovery.ts","../src/observableClient/chainHead/streams/runtime.ts","../src/observableClient/chainHead/streams/follow.ts","../src/observableClient/chainHead/streams/finalized.ts","../src/observableClient/chainHead/streams/metadata$.ts","../src/observableClient/chainHead/chainHead.ts","../src/observableClient/chainHead/streams/best-block.ts","../src/observableClient/tx.ts","../src/observableClient/getObservableClient.ts","../src/tx.ts","../src/event.ts"],"sourcesContent":["import {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport { createStorageEntry, type StorageEntry } from \"./storage\"\nimport { getObservableClient } from \"./observableClient\"\nimport { CreateClient, CreateTx, EvApi, StorageApi, TxApi } from \"./types\"\nimport { TxClient, createTxEntry } from \"./tx\"\nimport { firstValueFrom } from \"rxjs\"\nimport { EvClient, createEventEntry } from \"./event\"\nimport {\n  Descriptors,\n  EventsFromDescriptors,\n  QueryFromDescriptors,\n  TxFromDescriptors,\n} from \"@polkadot-api/substrate-bindings\"\nimport { mapObject } from \"@polkadot-api/utils\"\n\nconst createNamespace = (\n  descriptors: Descriptors,\n  createTxFromAddress: (\n    address: string,\n    callData: Uint8Array,\n  ) => Promise<Uint8Array>,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n  client: ReturnType<typeof getObservableClient>,\n): {\n  query: StorageApi<QueryFromDescriptors<Descriptors>>\n  tx: TxApi<TxFromDescriptors<Descriptors>>\n  event: EvApi<EventsFromDescriptors<Descriptors>>\n} => {\n  const query = {} as Record<string, Record<string, StorageEntry<any, any>>>\n  for (const pallet in descriptors) {\n    query[pallet] ||= {}\n    const [stgEntries] = descriptors[pallet]\n    for (const name in stgEntries) {\n      query[pallet][name] = createStorageEntry(\n        stgEntries[name],\n        pallet,\n        name,\n        chainHead.getRuntimeContext$,\n        chainHead.storage$,\n        chainHead.finalized$,\n      )\n    }\n  }\n\n  const tx = {} as Record<string, Record<string, TxClient<any>>>\n  for (const pallet in descriptors) {\n    tx[pallet] ||= {}\n    const [, txEntries] = descriptors[pallet]\n    for (const name in txEntries) {\n      tx[pallet][name] = createTxEntry(\n        txEntries[name],\n        pallet,\n        name,\n        chainHead.getRuntimeContext$,\n        client,\n        chainHead.storage$,\n        createTxFromAddress,\n      )\n    }\n  }\n\n  const events = {} as Record<string, Record<string, EvClient<any>>>\n  for (const pallet in descriptors) {\n    events[pallet] ||= {}\n    const [, , evEntries] = descriptors[pallet]\n    for (const name in evEntries) {\n      events[pallet][name] = createEventEntry(\n        evEntries[name],\n        pallet,\n        name,\n        chainHead.getRuntimeContext$,\n        chainHead.finalized$,\n        chainHead.storage$,\n      )\n    }\n  }\n\n  return {\n    query: query as any,\n    tx: tx as any,\n    event: events as any,\n  }\n}\n\nexport const createClient: CreateClient = (connect, descriptors) => {\n  let createTx: CreateTx\n  const rawClient: SubstrateClient = createRawClient((onMsg) => {\n    const result = connect(onMsg)\n    createTx = result.createTx\n    return result\n  })\n  const client = getObservableClient(rawClient)\n  const chainHead = client.chainHead$()\n\n  const createTxFromAddress = async (address: string, callData: Uint8Array) => {\n    const { accountId } = await firstValueFrom(\n      chainHead.getRuntimeContext$(null),\n    )\n    return createTx(accountId.enc(address), callData)\n  }\n\n  return {\n    finalized$: chainHead.finalized$,\n    bestBlock$: chainHead.bestBlock$,\n    bestBlocks$: chainHead.bestBlocks$,\n    ...mapObject(descriptors, (des) =>\n      createNamespace(des, createTxFromAddress, chainHead, client),\n    ),\n  } as any\n}\n","import {\n  Observable,\n  debounceTime,\n  distinctUntilChanged,\n  exhaustMap,\n  map,\n  mergeMap,\n  withLatestFrom,\n} from \"rxjs\"\nimport { firstValueFromWithSignal } from \"@/utils\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport { getDynamicBuilder } from \"@polkadot-api/metadata-builders\"\nimport { RuntimeContext } from \"./observableClient/chainHead/chainHead\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : []\n\ntype StorageEntryWithoutKeys<Payload> = {\n  getValue: (options?: CallOptions) => Promise<Payload>\n  watchValue: () => Observable<Payload>\n}\n\ntype StorageEntryWithKeys<Args extends Array<any>, Payload> = {\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  watchValue: (...args: Args) => Observable<Payload>\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: Args; value: NonNullable<Payload> }>>\n}\n\nexport type StorageEntry<Args extends Array<any>, Payload> = Args extends []\n  ? StorageEntryWithoutKeys<Payload>\n  : StorageEntryWithKeys<Args, Payload>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createStorageEntry = (\n  checksum: string,\n  pallet: string,\n  name: string,\n  getRuntimeContext$: (hash: string | null) => Observable<RuntimeContext>,\n  storage$: Storage$,\n  finalized$: Observable<string>,\n) => {\n  const storageCall = <T, Type extends StorageItemInput[\"type\"]>(\n    at: string | null,\n    mapper: (\n      codecs: ReturnType<ReturnType<typeof getDynamicBuilder>[\"buildStorage\"]>,\n    ) => [\n      block: string | null,\n      args: [type: Type, key: string, childTrie: string | null],\n      decoder: (input: StorageResult<Type>) => T,\n    ],\n    signal?: AbortSignal,\n  ): Promise<T> => {\n    const request$ = getRuntimeContext$(at).pipe(\n      mergeMap((descriptors) => {\n        const actualChecksum = descriptors.checksumBuilder.buildStorage(\n          pallet,\n          name,\n        )\n        const codecs = descriptors.dynamicBuilder.buildStorage(pallet, name)\n        if (checksum !== actualChecksum)\n          throw new Error(\n            `Incompatible runtime entry Storage(${pallet}.${name})`,\n          )\n\n        const [block, args, decoder] = mapper(codecs)\n        return storage$(block, ...args).pipe(map(decoder))\n      }),\n    )\n    return firstValueFromWithSignal(request$, signal)\n  }\n\n  const watchValue = (...args: Array<any>) => {\n    const descriptors$ = finalized$.pipe(\n      mergeMap(getRuntimeContext$),\n      distinctUntilChanged(),\n      map((descriptors) =>\n        descriptors.dynamicBuilder.buildStorage(pallet, name),\n      ),\n    )\n\n    return finalized$.pipe(\n      debounceTime(0),\n      withLatestFrom(descriptors$),\n      exhaustMap(([latest, codecs]) =>\n        storage$(latest, \"value\", codecs.enc(...args), null).pipe(\n          map((val) => ({ val, codecs })),\n        ),\n      ),\n      distinctUntilChanged((a, b) => a.val === b.val),\n      map(({ codecs, val }) =>\n        val === null ? codecs.fallback : codecs.dec(val),\n      ),\n    )\n  }\n\n  const getValue = (...args: Array<any>) => {\n    const invalidArgs = () =>\n      new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    return storageCall(\n      at ?? null,\n      (codecs) => {\n        const actualArgs = args.length === codecs.len ? args : args.slice(0, -1)\n\n        if (args !== actualArgs && !isLastArgOptional) throw invalidArgs()\n\n        const key = codecs.enc(...actualArgs)\n        return [\n          at,\n          [\"value\", key, null],\n          (response: StorageResult<\"value\">) =>\n            response === null\n              ? codecs.fallback\n              : codecs.dec(response as string),\n        ]\n      },\n      signal,\n    )\n  }\n\n  const getEntries = (...args: Array<any>) => {\n    const invalidArgs = () =>\n      new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    return storageCall(\n      at,\n      (codecs) => {\n        if (args.length > codecs.len) throw invalidArgs()\n\n        const actualArgs =\n          args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n\n        if (args.length === codecs.len && actualArgs === args)\n          throw invalidArgs()\n\n        return [\n          at,\n          [\"descendantsValues\", codecs.enc(...actualArgs), null],\n          (x: StorageResult<\"descendantsValues\">) => {\n            return x.map(({ key, value }) => ({\n              keyArgs: codecs.keyDecoder(key),\n              value: codecs.dec(value),\n            }))\n          },\n        ]\n      },\n      signal,\n    )\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  return { getValue, getValues, getEntries, watchValue }\n}\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { Observable, OperatorFunction, Subscription } from \"rxjs\"\n\nexport function switchMapComplete<T, O>(\n  project: (value: T) => Observable<O>,\n): OperatorFunction<T, O> {\n  return (source: Observable<T>): Observable<O> =>\n    new Observable((observer) => {\n      let innerSubscription: Subscription | null = null\n      let outterSubscription = source.subscribe({\n        next(v) {\n          innerSubscription?.unsubscribe()\n          innerSubscription = project(v).subscribe({\n            next(iV) {\n              observer.next(iV)\n            },\n            error(e) {\n              observer.error(e)\n            },\n          })\n        },\n        complete() {\n          observer.complete()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n      return () => {\n        innerSubscription?.unsubscribe()\n        outterSubscription.unsubscribe()\n        innerSubscription = null\n      }\n    })\n}\n","import { Observable, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const onAbort = signal\n      ? () => {\n          subscription.unsubscribe()\n        }\n      : noop\n\n    let isDone = false\n    const subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n\n        // if the Observable emits synchronously, then `subscription`\n        // won't exist yet.\n        isDone = true\n        subscription?.unsubscribe()\n      },\n      error: (e) => {\n        reject(e)\n        signal?.removeEventListener(\"abort\", onAbort)\n      },\n      complete: () => {\n        reject(new Error(\"Observable completed without emitting\"))\n        signal?.removeEventListener(\"abort\", onAbort)\n      },\n    })\n\n    // in case that the observable emitted synchronously\n    if (isDone) {\n      subscription.unsubscribe()\n    } else {\n      signal?.addEventListener(\"abort\", onAbort)\n    }\n  })\n}\n","import { Observable, defer, scan } from \"rxjs\"\n\nexport const lazyScan =\n  <Acc, Item>(reducer: (acc: Acc, value: Item) => Acc, getInit: () => Acc) =>\n  (base: Observable<Item>): Observable<Acc> =>\n    defer(() => base.pipe(scan(reducer, getInit())))\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (topSubscription.closed && innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      const topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nexport const withoutComplete = <T>(source: Observable<T>) =>\n  new Observable<T>((observer) =>\n    source.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        observer.error(e)\n      },\n    }),\n  )\n","import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        teardown(source$)\n        if (e instanceof OperationLimitError) return addTask(data, true)\n\n        observer.error(e)\n        onEmptySlot()\n      },\n      complete() {\n        observer.complete()\n        onEmptySlot()\n      },\n    })\n\n    if (!observer.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n      })\n    }\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n","import {\n  Finalized,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  Subject,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  pairwise,\n  share,\n  skip,\n  startWith,\n} from \"rxjs\"\nimport { lazyScan } from \"@/utils\"\n\nexport const getWithUnpinning$ = (\n  finalized$: Observable<string>,\n  follow$: Observable<FollowEventWithRuntime>,\n  unpin: (hashes: string[]) => void,\n) => {\n  const userUsageInput$ = new Subject<{\n    type: \"hold\" | \"release\"\n    hash: string\n  }>()\n\n  const userUsage$ = new Observable<{\n    type: \"hold\" | \"release\"\n    hash: string\n    isUser: true\n  }>((observer) => {\n    const userSub = userUsageInput$.subscribe((value) => {\n      observer.next({ ...value, isUser: true })\n    })\n\n    const finSub = finalized$.subscribe({\n      error(e) {\n        observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    return () => {\n      userSub.unsubscribe()\n      finSub.unsubscribe()\n    }\n  })\n\n  // We ensure that the latest finalized block always stays pinned\n  const internalUsage$ = finalized$.pipe(\n    startWith(\"\"),\n    pairwise(),\n    mergeMap(([prev, current]) => [\n      { type: \"release\" as \"release\", hash: prev, isUser: false },\n      { type: \"hold\" as \"hold\", hash: current, isUser: false },\n    ]),\n    skip(1),\n  )\n\n  const unpinFromUsage$ = merge(internalUsage$, userUsage$).pipe(\n    lazyScan(\n      (acc, { isUser, type, hash }) => {\n        const { counters, bestBlocks } = acc\n        for (const hash in counters) if (!counters[hash]) delete counters[hash]\n\n        if (isUser && type === \"hold\" && !counters[hash]) {\n          bestBlocks[hash] ||= 0\n          bestBlocks[hash]++\n          return acc\n        }\n\n        if (isUser && type === \"release\" && bestBlocks[hash]) {\n          if (!--bestBlocks[hash]) delete bestBlocks[hash]\n          return acc\n        }\n\n        if (type === \"release\") {\n          counters[hash]--\n        } else {\n          counters[hash] ||= 0\n          counters[hash]++\n          if (!isUser && bestBlocks[hash]) {\n            counters[hash] += bestBlocks[hash]\n            delete bestBlocks[hash]\n          }\n        }\n\n        return acc\n      },\n      () => ({\n        counters: {} as Record<string, number>,\n        bestBlocks: {} as Record<string, number>,\n      }),\n    ),\n    map((acc) =>\n      Object.entries(acc.counters)\n        .filter(([, value]) => value === 0)\n        .map(([key]) => key),\n    ),\n    filter((x) => x.length > 0),\n    share(),\n  )\n\n  const unpinFromPrunned$ = follow$.pipe(\n    filter((e): e is Finalized => e.type === \"finalized\"),\n    map((e) => e.prunedBlockHashes),\n  )\n\n  merge(unpinFromUsage$, unpinFromPrunned$)\n    .pipe(filter((x) => x.length > 0))\n    .subscribe((hashes) => {\n      unpin(hashes)\n    })\n\n  const onHold = (hash: string) => {\n    userUsageInput$.next({ type: \"hold\", hash })\n  }\n  const onRelease = (hash: string) => {\n    setTimeout(() => {\n      userUsageInput$.next({ type: \"release\", hash })\n    }, 0)\n  }\n\n  const withUnpinning$ =\n    <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string, ...args: Args): Observable<T> => {\n      const base$ = fn(hash, ...args)\n      return new Observable<T>((observer) => {\n        onHold(hash)\n        const subscription = base$.subscribe(observer)\n        return () => {\n          subscription.unsubscribe()\n          onRelease(hash)\n        }\n      })\n    }\n\n  return { withUnpinning$, unpinFromUsage$ }\n}\n","import { withoutComplete } from \"@/utils\"\nimport {\n  Observable,\n  ReplaySubject,\n  concat,\n  mergeMap,\n  of,\n  share,\n  take,\n  takeWhile,\n} from \"rxjs\"\n\nconst DONE = Symbol(\"DONE\")\ntype DONE = typeof DONE\n\nconst delayUnsubscription = <T>(source$: Observable<T>) =>\n  new Observable<T>((observer) => {\n    const subscription = source$.subscribe(observer)\n    return () => {\n      setTimeout(() => {\n        subscription.unsubscribe()\n      }, 0)\n    }\n  })\n\nexport const getWithOptionalhash$ = (finalized$: Observable<string>) => {\n  const current$ = finalized$.pipe(\n    take(1),\n    withoutComplete,\n    share({\n      connector: () => new ReplaySubject(1),\n      resetOnError: true,\n      resetOnRefCountZero: true,\n      resetOnComplete: false,\n    }),\n    delayUnsubscription,\n  )\n\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) =>\n      hash\n        ? fn(hash, ...args)\n        : current$.pipe(\n            mergeMap((h) => concat(fn(h, ...args), of(DONE))),\n            takeWhile((x): x is T => x !== DONE),\n          )\n}\n","import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n","import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n","import { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\nimport { Observable, catchError, concatMap, throwError, timer } from \"rxjs\"\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const withOperationInaccessibleRecovery =\n  <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n  (...args: Args): Observable<T> =>\n    operable(fn(...args))\n","import { shareLatest } from \"@/utils\"\nimport { FollowEventWithRuntime, Runtime } from \"@polkadot-api/substrate-client\"\nimport { Observable, distinctUntilChanged, map, scan } from \"rxjs\"\n\nexport const getRuntime$ = (follow$: Observable<FollowEventWithRuntime>) => {\n  const shared = follow$.pipe(\n    scan(\n      (acc, event) => {\n        if (event.type === \"initialized\") {\n          acc.candidates.clear()\n          acc.current = event.finalizedBlockRuntime\n        }\n\n        if (event.type === \"newBlock\" && event.newRuntime)\n          acc.candidates.set(event.blockHash, event.newRuntime)\n\n        if (event.type !== \"finalized\") return acc\n\n        const [newRuntimeHash] = event.finalizedBlockHashes\n          .filter((h) => acc.candidates.has(h))\n          .slice(-1)\n        if (newRuntimeHash) acc.current = acc.candidates.get(newRuntimeHash)!\n\n        acc.candidates.clear()\n        return acc\n      },\n      {\n        candidates: new Map<string, Runtime>(),\n        current: {} as Runtime,\n      },\n    ),\n    shareLatest,\n  )\n\n  const candidates$ = shared.pipe(map((x) => x.candidates))\n\n  const runtime$ = shared.pipe(\n    map((x) => x.current),\n    distinctUntilChanged(),\n    shareLatest,\n  )\n\n  return { runtime$, candidates$ }\n}\n","import {\n  ChainHead,\n  FollowEventWithRuntime,\n  FollowResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, noop, share } from \"rxjs\"\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse\n  let unfollow: () => void = noop\n\n  const follow$ = new Observable<FollowEventWithRuntime>((observer) => {\n    follower = chainHead(\n      true,\n      (e) => {\n        observer.next(e)\n      },\n      (e) => {\n        console.warn(\"chainHead crashed\")\n        console.error(e)\n        observer.error(e)\n      },\n    )\n    unfollow = () => {\n      observer.complete()\n      follower.unfollow()\n    }\n  }).pipe(share())\n\n  return {\n    getFollower: () => {\n      if (!follower) throw new Error(\"Missing chainHead subscription\")\n      return follower\n    },\n    unfollow: () => {\n      unfollow()\n    },\n    follow$,\n  }\n}\n","import type { FollowEventWithRuntime } from \"@polkadot-api/substrate-client\"\nimport type { Observable } from \"rxjs\"\n\nimport { mergeMap } from \"rxjs\"\nimport { shareLatest } from \"@/utils\"\n\nexport const getFinalized$ = (follow$: Observable<FollowEventWithRuntime>) =>\n  follow$.pipe(\n    mergeMap((e) => {\n      if (e.type === \"finalized\") return e.finalizedBlockHashes\n      if (e.type !== \"initialized\") return []\n      return [e.finalizedBlockHash]\n    }),\n    shareLatest,\n  )\n","import { Tuple, compact, metadata } from \"@polkadot-api/substrate-bindings\"\nimport { Runtime } from \"@polkadot-api/substrate-client\"\nimport { Observable, map, startWith, withLatestFrom } from \"rxjs\"\nimport { switchMapComplete, shareLatest } from \"@/utils\"\n\nconst opaqueMeta = Tuple(compact, metadata)\n\nexport const getMetadata$ = (\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  runtime$: Observable<Runtime>,\n  finalized$: Observable<string>,\n) => {\n  const _getMetadata$ = ([, hash]: [runtime: Runtime, hash: string]) =>\n    call$(hash, \"Metadata_metadata\", \"\").pipe(\n      map((response) => {\n        const metadata = opaqueMeta.dec(response)[1]\n        if (metadata.metadata.tag !== \"v14\")\n          throw new Error(\"Wrong metadata version\")\n        return metadata.metadata.value\n      }),\n      startWith(null),\n    )\n\n  return runtime$.pipe(\n    withLatestFrom(finalized$),\n    switchMapComplete(_getMetadata$),\n    shareLatest,\n  )\n}\n","import type {\n  ChainHead,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  getWithRecovery,\n  getWithUnpinning$,\n  getWithOptionalhash$,\n  fromAbortControllerFn,\n  withLazyFollower,\n  withOperationInaccessibleRecovery,\n} from \"./enhancers\"\nimport { getRuntime$, getFollow$, getFinalized$, getMetadata$ } from \"./streams\"\nimport {\n  EMPTY,\n  Observable,\n  asapScheduler,\n  filter,\n  from,\n  map,\n  mergeAll,\n  mergeMap,\n  observeOn,\n  pipe,\n  shareReplay,\n  take,\n  withLatestFrom,\n} from \"rxjs\"\nimport {\n  Decoder,\n  getChecksumBuilder,\n  getDynamicBuilder,\n} from \"@polkadot-api/metadata-builders\"\nimport { concatMapEager, shareLatest } from \"@/utils\"\nimport {\n  AccountId,\n  Codec,\n  SS58String,\n  blockHeader,\n} from \"@polkadot-api/substrate-bindings\"\nimport { getBestBlock$, getBestBlocks$ } from \"./streams/best-block\"\n\nexport type { BlockHeaderWithHash } from \"./streams/best-block\"\n\nexport interface RuntimeContext {\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<any>\n  }\n  accountId: Codec<SS58String>\n}\n\nexport default (chainHead: ChainHead) => () => {\n  const { getFollower, unfollow, follow$ } = getFollow$(chainHead)\n\n  const lazyFollower = withLazyFollower(getFollower)\n\n  const { runtime$, candidates$: runtimeCandidates$ } = getRuntime$(follow$)\n  const _finalized$ = getFinalized$(follow$)\n  const bestBlock$ = getBestBlock$(follow$)\n\n  const { withUnpinning$, unpinFromUsage$ } = getWithUnpinning$(\n    _finalized$,\n    follow$,\n    lazyFollower(\"unpin\"),\n  )\n\n  const withOptionalHash$ = getWithOptionalhash$(_finalized$)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n  ) =>\n    withOptionalHash$(withUnpinning$(withRecoveryFn(fromAbortControllerFn(fn))))\n\n  const call$ = commonEnhancer(lazyFollower(\"call\"))\n  const body$ = commonEnhancer(lazyFollower(\"body\"))\n  const storage$ = withOperationInaccessibleRecovery(\n    commonEnhancer(lazyFollower(\"storage\")),\n  )\n\n  const lazyHeader = lazyFollower(\"header\")\n  const header$ = pipe(\n    withUnpinning$((hash: string) => from(lazyHeader(hash))),\n    map(blockHeader.dec),\n  )\n\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            observer.next(\n              recoveralStorage$(\n                hash,\n                queries.slice(-nDiscarded),\n                childTrie,\n                true,\n              ),\n            )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  const storageQueries$ = withOperationInaccessibleRecovery(\n    withOptionalHash$(\n      withUnpinning$(\n        (hash: string, queries: Array<StorageItemInput>, childTrie?: string) =>\n          recoveralStorage$(hash, queries, childTrie ?? null, false),\n      ),\n    ),\n  )\n\n  const metadata$ = getMetadata$(call$, runtime$, _finalized$)\n  const runtimeContext$ = runtime$.pipe(\n    map(() => {\n      const result = metadata$.pipe(\n        filter(Boolean),\n        map((metadata): RuntimeContext => {\n          const checksumBuilder = getChecksumBuilder(metadata)\n          const dynamicBuilder = getDynamicBuilder(metadata)\n          const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n          return {\n            checksumBuilder,\n            dynamicBuilder,\n            events: {\n              key: events.enc(),\n              dec: events.dec,\n            },\n            accountId: AccountId(dynamicBuilder.ss58Prefix),\n          }\n        }),\n        take(1),\n        shareReplay(1),\n      )\n      result.subscribe()\n      return result\n    }),\n    shareLatest,\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  metadata$.subscribe()\n\n  const currentFinalized$ = new Observable<\n    Record<string, Observable<RuntimeContext>>\n  >((observer) => {\n    let latestRuntimeCtx: Observable<RuntimeContext>\n    const toRemove = new Set<string>()\n    const result: Record<string, Observable<RuntimeContext>> = {}\n\n    const sub1 = runtimeContext$.subscribe({\n      next(v) {\n        latestRuntimeCtx = v\n      },\n      error(e) {\n        observer.error(e)\n      },\n    })\n\n    const sub2 = unpinFromUsage$.subscribe({\n      next(v) {\n        v.forEach((x) => {\n          if (result[x]) delete result[x]\n          else toRemove.add(x)\n        })\n      },\n      error(e) {\n        observer.error(e)\n      },\n    })\n\n    const sub3 = _finalized$.pipe(observeOn(asapScheduler)).subscribe({\n      next(v) {\n        if (toRemove.has(v)) toRemove.delete(v)\n        else result[v] = latestRuntimeCtx\n        observer.next(result)\n      },\n      error(e) {\n        observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    return () => {\n      sub3.unsubscribe()\n      sub2.unsubscribe()\n      sub1.unsubscribe()\n    }\n  }).pipe(\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  const getRuntimeContext$ = withOptionalHash$((hash: string) =>\n    currentFinalized$.pipe(\n      withLatestFrom(runtimeCandidates$),\n      take(1),\n      mergeMap(\n        ([x, runtimeCandidates]) =>\n          x[hash] ??\n          (runtimeCandidates.has(hash) ? EMPTY : Object.values(x).slice(-1)[0]),\n      ),\n    ),\n  )\n  currentFinalized$.subscribe()\n\n  const bestBlocks$ = getBestBlocks$(bestBlock$, _finalized$, header$)\n\n  const finalizedHeader$ = _finalized$.pipe(\n    concatMapEager((hash) =>\n      header$(hash).pipe(map((header) => ({ hash, header }))),\n    ),\n    shareLatest,\n  )\n  finalizedHeader$.subscribe()\n  const finalized$ = finalizedHeader$.pipe(map((x) => x.hash))\n\n  return {\n    finalized$,\n    finalizedHeader$,\n    bestBlock$,\n    bestBlocks$,\n    follow$,\n    runtime$,\n    metadata$,\n    body$,\n    call$,\n    storage$,\n    storageQueries$,\n    unfollow,\n    getRuntimeContext$,\n  }\n}\n","import type {\n  BestBlockChanged,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  Subject,\n  Subscription,\n  concatMap,\n  startWith,\n  tap,\n  withLatestFrom,\n} from \"rxjs\"\n\nimport { combineLatest, filter, map } from \"rxjs\"\nimport { shareLatest } from \"@/utils\"\nimport { BlockHeader } from \"@polkadot-api/substrate-bindings\"\n\nexport const getBestBlock$ = (follow$: Observable<FollowEventWithRuntime>) =>\n  follow$.pipe(\n    filter((e): e is BestBlockChanged => e.type === \"bestBlockChanged\"),\n    map((e) => e.bestBlockHash),\n    shareLatest,\n  )\n\nexport type BlockHeaderWithHash = { hash: string; header: BlockHeader }\n\nexport const getBestBlocks$ = (\n  best$: Observable<string>,\n  finalized$: Observable<string>,\n  getHeader$: (hash: string) => Observable<BlockHeader>,\n): Observable<Array<BlockHeaderWithHash>> => {\n  const _current$ = new Subject<Map<string, BlockHeader>>()\n  const getBlocks$ = (\n    best: string,\n    finalized: string,\n    current: Map<string, BlockHeader>,\n  ): Observable<Map<string, BlockHeader>> =>\n    new Observable((observer) => {\n      const result = new Map<string, BlockHeader>()\n      let sub: Subscription\n\n      const process = (hash: string) => {\n        if (hash === finalized) {\n          observer.next(result)\n          observer.complete()\n          return\n        }\n\n        const header = current.get(hash)\n        if (header) {\n          result.set(hash, header)\n          process(header.parentHash)\n          return\n        }\n\n        sub = getHeader$(hash).subscribe({\n          next(header) {\n            result.set(hash, header)\n            process(header.parentHash)\n          },\n          error(e) {\n            observer.error(e)\n          },\n        })\n      }\n\n      process(best)\n\n      return () => {\n        sub?.unsubscribe()\n      }\n    })\n\n  return combineLatest({ best: best$, finalized: finalized$ }).pipe(\n    withLatestFrom(_current$.pipe(startWith(new Map()))),\n    concatMap(([{ best, finalized }, current]) =>\n      getBlocks$(best, finalized, current).pipe(\n        tap((x) => {\n          _current$.next(x)\n        }),\n        map((state) => {\n          const result: Array<BlockHeaderWithHash> = []\n          let hash = best\n          while (hash !== finalized) {\n            const header = state.get(hash)!\n            result.push({ hash, header })\n            hash = header.parentHash\n          }\n          return result\n        }),\n      ),\n    ),\n    shareLatest,\n  )\n}\n","import type {\n  SubstrateClient,\n  TxBestChainBlockIncluded,\n  TxBroadcasted,\n  TxDropped,\n  TxFinalized,\n  TxInvalid,\n  TxValidated,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nconst terminalTxEvents = new Set([\"error\", \"finalized\", \"invalid\", \"dropped\"])\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<\n      | TxValidated\n      | TxBroadcasted\n      | TxBestChainBlockIncluded\n      | TxFinalized\n      | TxInvalid\n      | TxDropped\n    >((observer) =>\n      baseTransaction(\n        transaction,\n        (event) => {\n          if (event.type === \"error\")\n            return observer.error(new Error(event.error))\n\n          observer.next(event)\n          if (terminalTxEvents.has(event.type)) observer.complete()\n        },\n        (error) => {\n          observer.error(error)\n        },\n      ),\n    )\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nimport getChainHead$ from \"./chainHead/chainHead\"\nimport getTx$ from \"./tx\"\n\nexport const getObservableClient = ({\n  chainHead,\n  transaction,\n  destroy,\n}: SubstrateClient) => ({\n  chainHead$: getChainHead$(chainHead),\n  tx$: getTx$(transaction),\n  destroy,\n})\n","import type { SS58String, TxDescriptor } from \"@polkadot-api/substrate-bindings\"\nimport type { Storage$ } from \"./storage\"\nimport type {\n  TxBestChainBlockIncluded,\n  TxBroadcasted,\n  TxFinalized,\n  TxValidated,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  firstValueFrom,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n} from \"rxjs\"\nimport { mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { getObservableClient } from \"./observableClient\"\nimport { RuntimeContext } from \"./observableClient/chainHead/chainHead\"\n\ntype SystemEvent = {\n  phase:\n    | { tag: \"ApplyExtrinsic\"; value: number }\n    | { tag: \"Finalization\" }\n    | { tag: \"Initialization\" }\n  event: {\n    tag: string\n    value: {\n      tag: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\ntype TxSuccess = {\n  ok: boolean\n  events: Array<SystemEvent[\"event\"]>\n}\n\ntype TxFunction<Args extends Array<any>> = (\n  from: SS58String,\n  ...args: Args\n) => Promise<TxSuccess>\n\ntype TxObservable<Args extends Array<any>> = (\n  from: SS58String,\n  ...args: Args\n) => Observable<\n  | TxValidated\n  | TxBroadcasted\n  | TxBestChainBlockIncluded\n  | (TxFinalized & TxSuccess)\n>\n\ntype TxCall<Args extends Array<any>> = (...args: Args) => Promise<string>\n\ntype TxSigned<Args extends Array<any>> = (\n  from: SS58String,\n  ...args: Args\n) => Promise<string>\n\nexport type TxClient<Args extends Array<any>> = {\n  getCallData: TxCall<Args>\n  getTx: TxSigned<Args>\n  submit: TxFunction<Args>\n  submit$: TxObservable<Args>\n}\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): TxSuccess => {\n  const events = systemEvents\n    .filter((x) => x.phase.tag === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => x.event)\n\n  const lastEvent = events[events.length - 1]\n  const ok =\n    lastEvent.tag === \"System\" && lastEvent.value.tag === \"ExtrinsicSuccess\"\n\n  return { ok, events }\n}\n\nexport const createTxEntry = <Args extends Array<any>>(\n  descriptor: TxDescriptor<Args>,\n  pallet: string,\n  name: string,\n  getRuntimeContext$: (blockHash: string | null) => Observable<RuntimeContext>,\n  client: ReturnType<typeof getObservableClient>,\n  storage$: Storage$,\n  signer: (from: string, callData: Uint8Array) => Promise<Uint8Array>,\n): TxClient<Args> => {\n  const getCallDataAndEventDec$ = (...decodedArgs: Args) =>\n    getRuntimeContext$(null).pipe(\n      map(({ events, checksumBuilder, dynamicBuilder }) => {\n        const checksum = checksumBuilder.buildCall(pallet, name)\n        if (checksum !== descriptor)\n          throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`)\n\n        const { location, args } = dynamicBuilder.buildCall(pallet, name)\n        return {\n          callData: mergeUint8(new Uint8Array(location), args.enc(decodedArgs)),\n          events,\n        }\n      }),\n    )\n\n  const getCallData: TxCall<Args> = (...args) =>\n    firstValueFrom(getCallDataAndEventDec$(...args)).then((x) =>\n      toHex(x.callData),\n    )\n\n  const getTx: TxSigned<Args> = (from, ...args) =>\n    firstValueFrom(\n      getCallDataAndEventDec$(...args).pipe(\n        mergeMap(({ callData }) => signer(from, callData)),\n        map(toHex),\n      ),\n    )\n\n  const submit: TxFunction<Args> = async (from, ...args) => {\n    const [tx, { key, dec }] = await firstValueFrom(\n      getCallDataAndEventDec$(...args).pipe(\n        mergeMap(({ callData, events }) =>\n          signer(from, callData).then((result) => ({\n            result,\n            events,\n          })),\n        ),\n        map((x) => [toHex(x.result), x.events] as const),\n      ),\n    )\n\n    const result = await lastValueFrom(client.tx$(tx))\n\n    switch (result.type) {\n      case \"invalid\":\n        throw new Error(\"Invalid\")\n      case \"dropped\":\n        throw new Error(\"Dropped\")\n      case \"finalized\": {\n        const systemEvents = await firstValueFrom(\n          storage$(result.block.hash, \"value\", key, null).pipe(\n            map((x) => dec(x!)),\n          ),\n        )\n\n        return getTxSuccessFromSystemEvents(\n          systemEvents,\n          Number(result.block.index),\n        )\n      }\n      default:\n        return { ok: true, events: [] }\n    }\n  }\n\n  const submit$: TxObservable<Args> = (from, ...args) =>\n    getCallDataAndEventDec$(...args).pipe(\n      mergeMap(({ callData, events }) =>\n        signer(from, callData).then((result) => ({\n          result,\n          events,\n        })),\n      ),\n      take(1),\n      mergeMap(({ result, events: { key, dec } }) => {\n        return client.tx$(toHex(result)).pipe(\n          mergeMap((result) => {\n            switch (result.type) {\n              case \"invalid\":\n                throw new Error(\"Invalid\")\n              case \"dropped\":\n                throw new Error(\"Dropped\")\n              case \"finalized\": {\n                return storage$(result.block.hash, \"value\", key, null).pipe(\n                  map((x) => dec(x!)),\n                  map((events) => ({\n                    ...result,\n                    ...getTxSuccessFromSystemEvents(\n                      events,\n                      Number(result.block.index),\n                    ),\n                  })),\n                )\n              }\n              default:\n                return of(result)\n            }\n          }),\n        )\n      }),\n    )\n\n  return { getCallData, getTx, submit, submit$ }\n}\n","import { PlainDescriptor } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { Storage$ } from \"./storage\"\nimport { concatMapEager, shareLatest } from \"./utils\"\nimport { RuntimeContext } from \"./observableClient/chainHead/chainHead\"\n\nexport type EventPhase =\n  | { tag: \"ApplyExtrinsic\"; value: number }\n  | { tag: \"Finalization\" }\n  | { tag: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    blockHash: string\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      blockHash: string\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<T> = {\n  watch: EvWatch<T>\n  pull: EvPull<T>\n  filter: EvFilter<T>\n}\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    tag: string\n    value: {\n      tag: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <T>(\n  checksum: PlainDescriptor<T>,\n  pallet: string,\n  name: string,\n  getRuntimeContext$: (blockHash: string | null) => Observable<RuntimeContext>,\n  finalized: Observable<string>,\n  storage$: Storage$,\n): EvClient<T> => {\n  const shared$ = finalized.pipe(\n    concatMapEager((block) =>\n      getRuntimeContext$(block).pipe(map((context) => ({ context, block }))),\n    ),\n    concatMapEager(\n      ({\n        block,\n        context: {\n          events: { key, dec },\n          checksumBuilder,\n        },\n      }) => {\n        const actualChecksum = checksumBuilder.buildEvent(pallet, name)\n\n        if (checksum !== actualChecksum)\n          throw new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n\n        return storage$(block, \"value\", key, null).pipe(\n          map((x) => {\n            const events = dec(x!) as Array<SystemEvent>\n            const winners = events.filter(\n              (e) => e.event.tag === pallet && e.event.value.tag === name,\n            )\n            return winners.map((x) => {\n              return {\n                meta: {\n                  phase: x.phase,\n                  blockHash: block,\n                },\n                payload: x.event.value.value,\n              }\n            })\n          }),\n        )\n      },\n    ),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.tag === pallet && e.value.tag === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter }\n}\n"],"mappings":"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","names":["Observable","defer","Observable","Observable","Observable","Observable","Observable","map","mergeMap","share","Observable","mergeMap","hash","map","share","Observable","ReplaySubject","mergeMap","share","Observable","distinctUntilChanged","map","scan","Observable","noop","share","mergeMap","mergeMap","map","startWith","withLatestFrom","map","metadata","startWith","withLatestFrom","Observable","filter","map","mergeMap","take","withLatestFrom","Observable","Subject","concatMap","startWith","withLatestFrom","filter","map","filter","map","Subject","Observable","header","withLatestFrom","startWith","concatMap","map","Observable","filter","metadata","take","withLatestFrom","mergeMap","Observable","map","mergeMap","of","take","from","result","firstValueFrom","firstValueFrom","map","mergeMap","map","x","mergeMap","firstValueFrom","filter","firstValueFrom"]}