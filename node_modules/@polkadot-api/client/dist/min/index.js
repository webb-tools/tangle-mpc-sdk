"use strict";var _=Object.defineProperty;var je=Object.getOwnPropertyDescriptor;var Ke=Object.getOwnPropertyNames;var _e=Object.prototype.hasOwnProperty;var qe=(r,e,t)=>e in r?_(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var Qe=(r,e)=>{for(var t in e)_(r,t,{get:e[t],enumerable:!0})},Ze=(r,e,t,l)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of Ke(e))!_e.call(r,i)&&i!==t&&_(r,i,{get:()=>e[i],enumerable:!(l=je(e,i))||l.enumerable});return r};var Ye=r=>Ze(_({},"__esModule",{value:!0}),r);var re=(r,e,t)=>(qe(r,typeof e!="symbol"?e+"":e,t),t);var nt={};Qe(nt,{createClient:()=>rt,getObservableClient:()=>X});module.exports=Ye(nt);var De=require("@polkadot-api/substrate-client");var w=require("rxjs");var q=require("rxjs"),A=(0,q.share)({connector:()=>new q.ReplaySubject(1),resetOnError:!0,resetOnComplete:!0,resetOnRefCountZero:!0});var ge=require("rxjs");function de(r){return e=>new ge.Observable(t=>{let l=null,i=e.subscribe({next(a){l?.unsubscribe(),l=r(a).subscribe({next(u){t.next(u)},error(u){t.error(u)}})},complete(){t.complete()},error(a){t.error(a)}});return()=>{l?.unsubscribe(),i.unsubscribe(),l=null}})}var ye=require("rxjs");function fe(r,e){return new Promise((t,l)=>{let i=e?()=>{u.unsubscribe()}:ye.noop,a=!1,u=r.subscribe({next:p=>{t(p),a=!0,u?.unsubscribe()},error:p=>{l(p),e?.removeEventListener("abort",i)},complete:()=>{l(new Error("Observable completed without emitting")),e?.removeEventListener("abort",i)}});a?u.unsubscribe():e?.addEventListener("abort",i)})}var Q=require("rxjs"),he=(r,e)=>t=>(0,Q.defer)(()=>t.pipe((0,Q.scan)(r,e())));var Z=require("rxjs"),K=(r,e=1/0)=>t=>new Z.Observable(l=>{let i=new Map,a=new Map,u=new Map,p=0,g=0,m=0,h=()=>{let s=i.get(g);if(!s){n.closed&&a.size===0&&l.complete();return}let c=g++;i.delete(c),m!==c&&u.set(c,[]),a.set(c,s.subscribe({next(o){m===c?l.next(o):u.get(c).push(o)},complete(){if(a.delete(c),c===m)for(m++;u.has(m)&&(u.get(m).forEach(o=>l.next(o)),u.delete(m),!a.has(m));)m++;h()},error(o){l.error(o)}}))},n=t.subscribe({next(s){let c=p++;i.set(c,(0,Z.defer)(()=>r(s,c))),a.size<e&&h()},error(s){l.error(s)},complete(){a.size===0&&l.complete()}});return()=>{a.forEach(s=>s.unsubscribe()),n.unsubscribe(),i.clear(),u.clear()}});var ve=require("rxjs"),xe=r=>new ve.Observable(e=>r.subscribe({next(t){e.next(t)},error(t){e.error(t)}}));var Te=r=>typeof r!="object"?!1:Object.keys(r).every(e=>e==="at"&&typeof r.at=="string"||e==="signal"&&r.signal instanceof AbortSignal),Oe=(r,e,t,l,i,a)=>{let u=(n,s,c)=>{let o=l(n).pipe((0,w.mergeMap)(b=>{let d=b.checksumBuilder.buildStorage(e,t),x=b.dynamicBuilder.buildStorage(e,t);if(r!==d)throw new Error(`Incompatible runtime entry Storage(${e}.${t})`);let[y,E,F]=s(x);return i(y,...E).pipe((0,w.map)(F))}));return fe(o,c)},p=(...n)=>{let s=a.pipe((0,w.mergeMap)(l),(0,w.distinctUntilChanged)(),(0,w.map)(c=>c.dynamicBuilder.buildStorage(e,t)));return a.pipe((0,w.debounceTime)(0),(0,w.withLatestFrom)(s),(0,w.exhaustMap)(([c,o])=>i(c,"value",o.enc(...n),null).pipe((0,w.map)(b=>({val:b,codecs:o})))),(0,w.distinctUntilChanged)((c,o)=>c.val===o.val),(0,w.map)(({codecs:c,val:o})=>o===null?c.fallback:c.dec(o)))},g=(...n)=>{let s=()=>new Error(`Invalid Arguments calling ${e}.${t}(${n})`),c=n[n.length-1],o=Te(c),{signal:b,at:d}=o?c:{},x=d??null;return u(x??null,y=>{let E=n.length===y.len?n:n.slice(0,-1);if(n!==E&&!o)throw s();let F=y.enc(...E);return[x,["value",F,null],L=>L===null?y.fallback:y.dec(L)]},b)};return{getValue:g,getValues:(n,s)=>Promise.all(n.map(c=>g(...s?[...c,s]:c))),getEntries:(...n)=>{let s=()=>new Error(`Invalid Arguments calling ${e}.${t}(${n})`),c=n[n.length-1],o=Te(c),{signal:b,at:d}=o?c:{},x=d??null;return u(x,y=>{if(n.length>y.len)throw s();let E=n.length>0&&o?n.slice(0,-1):n;if(n.length===y.len&&E===n)throw s();return[x,["descendantsValues",y.enc(...E),null],F=>F.map(({key:L,value:j})=>({keyArgs:y.keyDecoder(L),value:y.dec(j)}))]},b)},watchValue:p}};var we=require("@polkadot-api/substrate-client"),Ae=require("rxjs");var Y=class{constructor(){re(this,"first");re(this,"last")}getRemoveFn(e){return()=>{e.prev?e.prev.next=e.next:this.first=e.next,e.next?e.next.prev=e.prev:this.last=e.prev,delete e.prev,delete e.next}}push(e){let t={value:e};return this.last===void 0?this.last=this.first=t:(this.last.next=t,t.prev=this.last,this.last=t),this.getRemoveFn(t)}unshift(e){return this.first={value:e,next:this.first},this.first.next&&(this.first.next.prev=this.first),this.last||(this.last=this.first),this.getRemoveFn(this.first)}pop(){let e=this.first?.value;return this.first&&(this.first=this.first.next,this.first?(delete this.first.prev?.next,delete this.first.prev):this.last=void 0),e}isEmpty(){return!this.first}},ne=()=>{let r=new Map,e=(s,c)=>{r.set(s,()=>{r.delete(s),c()})},t=s=>{r.get(s)?.()},l=new Y,i=l.unshift.bind(l),a=l.push.bind(l),u=(s,c)=>{let o=c?i:a;e(s.source$,o(s))},p=()=>{let s=l.pop();s&&(r.delete(s.source$),g(s))},g=s=>{let{source$:c,observer:o}=s,b=c.subscribe({next(d){o.next(d)},error(d){if(t(c),d instanceof we.OperationLimitError)return u(s,!0);o.error(d),p()},complete(){o.complete(),p()}});o.closed||e(c,()=>{b.unsubscribe()})},m=(s=!1)=>c=>new Ae.Observable(o=>{let b={observer:o,source$:c};return l.isEmpty()?g(b):u(b,s),()=>{t(c)}}),h=m();return{withRecovery:m,withRecoveryFn:s=>(...c)=>h(s(...c))}};var T=require("rxjs");var se=(r,e,t)=>{let l=new T.Subject,i=new T.Observable(n=>{let s=l.subscribe(o=>{n.next({...o,isUser:!0})}),c=r.subscribe({error(o){n.error(o)},complete(){n.complete()}});return()=>{s.unsubscribe(),c.unsubscribe()}}),a=r.pipe((0,T.startWith)(""),(0,T.pairwise)(),(0,T.mergeMap)(([n,s])=>[{type:"release",hash:n,isUser:!1},{type:"hold",hash:s,isUser:!1}]),(0,T.skip)(1)),u=(0,T.merge)(a,i).pipe(he((n,{isUser:s,type:c,hash:o})=>{let{counters:b,bestBlocks:d}=n;for(let x in b)b[x]||delete b[x];return s&&c==="hold"&&!b[o]?(d[o]||(d[o]=0),d[o]++,n):s&&c==="release"&&d[o]?(--d[o]||delete d[o],n):(c==="release"?b[o]--:(b[o]||(b[o]=0),b[o]++,!s&&d[o]&&(b[o]+=d[o],delete d[o])),n)},()=>({counters:{},bestBlocks:{}})),(0,T.map)(n=>Object.entries(n.counters).filter(([,s])=>s===0).map(([s])=>s)),(0,T.filter)(n=>n.length>0),(0,T.share)()),p=e.pipe((0,T.filter)(n=>n.type==="finalized"),(0,T.map)(n=>n.prunedBlockHashes));(0,T.merge)(u,p).pipe((0,T.filter)(n=>n.length>0)).subscribe(n=>{t(n)});let g=n=>{l.next({type:"hold",hash:n})},m=n=>{setTimeout(()=>{l.next({type:"release",hash:n})},0)};return{withUnpinning$:n=>(s,...c)=>{let o=n(s,...c);return new T.Observable(b=>{g(s);let d=o.subscribe(b);return()=>{d.unsubscribe(),m(s)}})},unpinFromUsage$:u}};var S=require("rxjs"),Se=Symbol("DONE"),Ge=r=>new S.Observable(e=>{let t=r.subscribe(e);return()=>{setTimeout(()=>{t.unsubscribe()},0)}}),oe=r=>{let e=r.pipe((0,S.take)(1),xe,(0,S.share)({connector:()=>new S.ReplaySubject(1),resetOnError:!0,resetOnRefCountZero:!0,resetOnComplete:!1}),Ge);return t=>(l,...i)=>l?t(l,...i):e.pipe((0,S.mergeMap)(a=>(0,S.concat)(t(a,...i),(0,S.of)(Se))),(0,S.takeWhile)(a=>a!==Se))};var $e=require("rxjs"),ie=r=>(...e)=>new $e.Observable(t=>{let l=new AbortController;return r(...e,l.signal).then(i=>{t.next(i),t.complete()},i=>{t.error(i)}),()=>{t.unsubscribe(),l.abort(),l=void 0}});var ae=r=>e=>(...t)=>r()[e](...t);var Ee=require("@polkadot-api/substrate-client"),P=require("rxjs"),Je=r=>{let e=r.pipe((0,P.catchError)(t=>t instanceof Ee.OperationInaccessibleError?(0,P.timer)(750).pipe((0,P.concatMap)(()=>e)):(0,P.throwError)(()=>t)));return e},le=r=>(...e)=>Je(r(...e));var z=require("rxjs"),ce=r=>{let e=r.pipe((0,z.scan)((i,a)=>{if(a.type==="initialized"&&(i.candidates.clear(),i.current=a.finalizedBlockRuntime),a.type==="newBlock"&&a.newRuntime&&i.candidates.set(a.blockHash,a.newRuntime),a.type!=="finalized")return i;let[u]=a.finalizedBlockHashes.filter(p=>i.candidates.has(p)).slice(-1);return u&&(i.current=i.candidates.get(u)),i.candidates.clear(),i},{candidates:new Map,current:{}}),A),t=e.pipe((0,z.map)(i=>i.candidates));return{runtime$:e.pipe((0,z.map)(i=>i.current),(0,z.distinctUntilChanged)(),A),candidates$:t}};var U=require("rxjs"),pe=r=>{let e,t=U.noop,l=new U.Observable(i=>{e=r(!0,a=>{i.next(a)},a=>{console.warn("chainHead crashed"),console.error(a),i.error(a)}),t=()=>{i.complete(),e.unfollow()}}).pipe((0,U.share)());return{getFollower:()=>{if(!e)throw new Error("Missing chainHead subscription");return e},unfollow:()=>{t()},follow$:l}};var Ce=require("rxjs");var ue=r=>r.pipe((0,Ce.mergeMap)(e=>e.type==="finalized"?e.finalizedBlockHashes:e.type!=="initialized"?[]:[e.finalizedBlockHash]),A);var V=require("@polkadot-api/substrate-bindings"),N=require("rxjs");var Xe=(0,V.Tuple)(V.compact,V.metadata),me=(r,e,t)=>{let l=([,i])=>r(i,"Metadata_metadata","").pipe((0,N.map)(a=>{let u=Xe.dec(a)[1];if(u.metadata.tag!=="v14")throw new Error("Wrong metadata version");return u.metadata.value}),(0,N.startWith)(null));return e.pipe((0,N.withLatestFrom)(t),de(l),A)};var f=require("rxjs"),G=require("@polkadot-api/metadata-builders");var J=require("@polkadot-api/substrate-bindings");var R=require("rxjs"),D=require("rxjs");var ke=r=>r.pipe((0,D.filter)(e=>e.type==="bestBlockChanged"),(0,D.map)(e=>e.bestBlockHash),A),Re=(r,e,t)=>{let l=new R.Subject,i=(a,u,p)=>new R.Observable(g=>{let m=new Map,h,n=s=>{if(s===u){g.next(m),g.complete();return}let c=p.get(s);if(c){m.set(s,c),n(c.parentHash);return}h=t(s).subscribe({next(o){m.set(s,o),n(o.parentHash)},error(o){g.error(o)}})};return n(a),()=>{h?.unsubscribe()}});return(0,D.combineLatest)({best:r,finalized:e}).pipe((0,R.withLatestFrom)(l.pipe((0,R.startWith)(new Map))),(0,R.concatMap)(([{best:a,finalized:u},p])=>i(a,u,p).pipe((0,R.tap)(g=>{l.next(g)}),(0,D.map)(g=>{let m=[],h=a;for(;h!==u;){let n=g.get(h);m.push({hash:h,header:n}),h=n.parentHash}return m}))),A)};var Fe=r=>()=>{let{getFollower:e,unfollow:t,follow$:l}=pe(r),i=ae(e),{runtime$:a,candidates$:u}=ce(l),p=ue(l),g=ke(l),{withUnpinning$:m,unpinFromUsage$:h}=se(p,l,i("unpin")),n=oe(p),{withRecovery:s,withRecoveryFn:c}=ne(),o=v=>n(m(c(ie(v)))),b=o(i("call")),d=o(i("body")),x=le(o(i("storage"))),y=i("header"),E=(0,f.pipe)(m(v=>(0,f.from)(y(v))),(0,f.map)(J.blockHeader.dec)),F=(v,$,k,B)=>new f.Observable(I=>e().storageSubscription(v,$,k??null,H=>{I.next(H)},H=>{I.error(H)},()=>{I.complete()},H=>{I.next(F(v,$.slice(-H),k,!0))})).pipe((0,f.mergeAll)(),s(B)),L=le(n(m((v,$,k)=>F(v,$,k??null,!1)))),j=me(b,a,p),Le=a.pipe((0,f.map)(()=>{let v=j.pipe((0,f.filter)(Boolean),(0,f.map)($=>{let k=(0,G.getChecksumBuilder)($),B=(0,G.getDynamicBuilder)($),I=B.buildStorage("System","Events");return{checksumBuilder:k,dynamicBuilder:B,events:{key:I.enc(),dec:I.dec},accountId:(0,J.AccountId)(B.ss58Prefix)}}),(0,f.take)(1),(0,f.shareReplay)(1));return v.subscribe(),v}),A);j.subscribe();let be=new f.Observable(v=>{let $,k=new Set,B={},I=Le.subscribe({next(C){$=C},error(C){v.error(C)}}),H=h.subscribe({next(C){C.forEach(te=>{B[te]?delete B[te]:k.add(te)})},error(C){v.error(C)}}),Ne=p.pipe((0,f.observeOn)(f.asapScheduler)).subscribe({next(C){k.has(C)?k.delete(C):B[C]=$,v.next(B)},error(C){v.error(C)},complete(){v.complete()}});return()=>{Ne.unsubscribe(),H.unsubscribe(),I.unsubscribe()}}).pipe((0,f.map)(v=>({...v})),A),Ue=n(v=>be.pipe((0,f.withLatestFrom)(u),(0,f.take)(1),(0,f.mergeMap)(([$,k])=>$[v]??(k.has(v)?f.EMPTY:Object.values($).slice(-1)[0]))));be.subscribe();let Ve=Re(g,p,E),ee=p.pipe(K(v=>E(v).pipe((0,f.map)($=>({hash:v,header:$})))),A);return ee.subscribe(),{finalized$:ee.pipe((0,f.map)(v=>v.hash)),finalizedHeader$:ee,bestBlock$:g,bestBlocks$:Ve,follow$:l,runtime$:a,metadata$:j,body$:d,call$:b,storage$:x,storageQueries$:L,unfollow:t,getRuntimeContext$:Ue}};var Be=require("rxjs"),et=new Set(["error","finalized","invalid","dropped"]),Ie=r=>e=>new Be.Observable(t=>r(e,l=>{if(l.type==="error")return t.error(new Error(l.error));t.next(l),et.has(l.type)&&t.complete()},l=>{t.error(l)}));var X=({chainHead:r,transaction:e,destroy:t})=>({chainHead$:Fe(r),tx$:Ie(e),destroy:t});var O=require("rxjs"),W=require("@polkadot-api/utils"),Pe=(r,e)=>{let t=r.filter(a=>a.phase.tag==="ApplyExtrinsic"&&a.phase.value===e).map(a=>a.event),l=t[t.length-1];return{ok:l.tag==="System"&&l.value.tag==="ExtrinsicSuccess",events:t}},He=(r,e,t,l,i,a,u)=>{let p=(...s)=>l(null).pipe((0,O.map)(({events:c,checksumBuilder:o,dynamicBuilder:b})=>{if(o.buildCall(e,t)!==r)throw new Error(`Incompatible runtime entry Tx(${e}.${t})`);let{location:x,args:y}=b.buildCall(e,t);return{callData:(0,W.mergeUint8)(new Uint8Array(x),y.enc(s)),events:c}}));return{getCallData:(...s)=>(0,O.firstValueFrom)(p(...s)).then(c=>(0,W.toHex)(c.callData)),getTx:(s,...c)=>(0,O.firstValueFrom)(p(...c).pipe((0,O.mergeMap)(({callData:o})=>u(s,o)),(0,O.map)(W.toHex))),submit:async(s,...c)=>{let[o,{key:b,dec:d}]=await(0,O.firstValueFrom)(p(...c).pipe((0,O.mergeMap)(({callData:y,events:E})=>u(s,y).then(F=>({result:F,events:E}))),(0,O.map)(y=>[(0,W.toHex)(y.result),y.events]))),x=await(0,O.lastValueFrom)(i.tx$(o));switch(x.type){case"invalid":throw new Error("Invalid");case"dropped":throw new Error("Dropped");case"finalized":{let y=await(0,O.firstValueFrom)(a(x.block.hash,"value",b,null).pipe((0,O.map)(E=>d(E))));return Pe(y,Number(x.block.index))}default:return{ok:!0,events:[]}}},submit$:(s,...c)=>p(...c).pipe((0,O.mergeMap)(({callData:o,events:b})=>u(s,o).then(d=>({result:d,events:b}))),(0,O.take)(1),(0,O.mergeMap)(({result:o,events:{key:b,dec:d}})=>i.tx$((0,W.toHex)(o)).pipe((0,O.mergeMap)(x=>{switch(x.type){case"invalid":throw new Error("Invalid");case"dropped":throw new Error("Dropped");case"finalized":return a(x.block.hash,"value",b,null).pipe((0,O.map)(y=>d(y)),(0,O.map)(y=>({...x,...Pe(y,Number(x.block.index))})));default:return(0,O.of)(x)}}))))}};var We=require("rxjs");var M=require("rxjs");var ze=(r,e,t,l,i,a)=>{let u=i.pipe(K(h=>l(h).pipe((0,M.map)(n=>({context:n,block:h})))),K(({block:h,context:{events:{key:n,dec:s},checksumBuilder:c}})=>{let o=c.buildEvent(e,t);if(r!==o)throw new Error(`Incompatible runtime entry Event(${e}.${t})`);return a(h,"value",n,null).pipe((0,M.map)(b=>s(b).filter(y=>y.event.tag===e&&y.event.value.tag===t).map(y=>({meta:{phase:y.phase,blockHash:h},payload:y.event.value.value}))))}),A);return{watch:h=>u.pipe((0,M.mergeMap)(n=>h?n.filter(s=>h(s.payload)):n)),pull:()=>(0,M.firstValueFrom)(u),filter:h=>h.filter(n=>n.tag===e&&n.value.tag===t).map(n=>n.value.value)}};var Me=require("@polkadot-api/utils"),tt=(r,e,t,l)=>{let i={};for(let p in r){i[p]||(i[p]={});let[g]=r[p];for(let m in g)i[p][m]=Oe(g[m],p,m,t.getRuntimeContext$,t.storage$,t.finalized$)}let a={};for(let p in r){a[p]||(a[p]={});let[,g]=r[p];for(let m in g)a[p][m]=He(g[m],p,m,t.getRuntimeContext$,l,t.storage$,e)}let u={};for(let p in r){u[p]||(u[p]={});let[,,g]=r[p];for(let m in g)u[p][m]=ze(g[m],p,m,t.getRuntimeContext$,t.finalized$,t.storage$)}return{query:i,tx:a,event:u}},rt=(r,e)=>{let t,l=(0,De.createClient)(p=>{let g=r(p);return t=g.createTx,g}),i=X(l),a=i.chainHead$(),u=async(p,g)=>{let{accountId:m}=await(0,We.firstValueFrom)(a.getRuntimeContext$(null));return t(m.enc(p),g)};return{finalized$:a.finalized$,bestBlock$:a.bestBlock$,bestBlocks$:a.bestBlocks$,...(0,Me.mapObject)(e,p=>tt(p,u,a,i))}};
//# sourceMappingURL=index.js.map