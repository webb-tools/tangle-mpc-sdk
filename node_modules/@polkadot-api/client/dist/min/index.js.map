{"version":3,"sources":["../../src/index.ts","../../src/client.ts","../../src/storage.ts","../../src/utils/shareLatest.ts","../../src/utils/switchMapComplete.ts","../../src/utils/firstValueFromWithSignal.ts","../../src/utils/lazyScan.ts","../../src/utils/concatMapEager.ts","../../src/utils/withoutComplete.ts","../../src/observableClient/chainHead/enhancers/operationLimitRecovery.ts","../../src/observableClient/chainHead/enhancers/unpin.ts","../../src/observableClient/chainHead/enhancers/optionalHash.ts","../../src/observableClient/chainHead/enhancers/fromAbortControllerFn.ts","../../src/observableClient/chainHead/enhancers/lazyFollower.ts","../../src/observableClient/chainHead/enhancers/operationInaccessibleRecovery.ts","../../src/observableClient/chainHead/streams/runtime.ts","../../src/observableClient/chainHead/streams/follow.ts","../../src/observableClient/chainHead/streams/finalized.ts","../../src/observableClient/chainHead/streams/metadata$.ts","../../src/observableClient/chainHead/chainHead.ts","../../src/observableClient/chainHead/streams/best-block.ts","../../src/observableClient/tx.ts","../../src/observableClient/getObservableClient.ts","../../src/tx.ts","../../src/event.ts"],"sourcesContent":["export * from \"./client\"\nexport * from \"./observableClient\"\n","import {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport { createStorageEntry, type StorageEntry } from \"./storage\"\nimport { getObservableClient } from \"./observableClient\"\nimport { CreateClient, CreateTx, EvApi, StorageApi, TxApi } from \"./types\"\nimport { TxClient, createTxEntry } from \"./tx\"\nimport { firstValueFrom } from \"rxjs\"\nimport { EvClient, createEventEntry } from \"./event\"\nimport {\n  Descriptors,\n  EventsFromDescriptors,\n  QueryFromDescriptors,\n  TxFromDescriptors,\n} from \"@polkadot-api/substrate-bindings\"\nimport { mapObject } from \"@polkadot-api/utils\"\n\nconst createNamespace = (\n  descriptors: Descriptors,\n  createTxFromAddress: (\n    address: string,\n    callData: Uint8Array,\n  ) => Promise<Uint8Array>,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n  client: ReturnType<typeof getObservableClient>,\n): {\n  query: StorageApi<QueryFromDescriptors<Descriptors>>\n  tx: TxApi<TxFromDescriptors<Descriptors>>\n  event: EvApi<EventsFromDescriptors<Descriptors>>\n} => {\n  const query = {} as Record<string, Record<string, StorageEntry<any, any>>>\n  for (const pallet in descriptors) {\n    query[pallet] ||= {}\n    const [stgEntries] = descriptors[pallet]\n    for (const name in stgEntries) {\n      query[pallet][name] = createStorageEntry(\n        stgEntries[name],\n        pallet,\n        name,\n        chainHead.getRuntimeContext$,\n        chainHead.storage$,\n        chainHead.finalized$,\n      )\n    }\n  }\n\n  const tx = {} as Record<string, Record<string, TxClient<any>>>\n  for (const pallet in descriptors) {\n    tx[pallet] ||= {}\n    const [, txEntries] = descriptors[pallet]\n    for (const name in txEntries) {\n      tx[pallet][name] = createTxEntry(\n        txEntries[name],\n        pallet,\n        name,\n        chainHead.getRuntimeContext$,\n        client,\n        chainHead.storage$,\n        createTxFromAddress,\n      )\n    }\n  }\n\n  const events = {} as Record<string, Record<string, EvClient<any>>>\n  for (const pallet in descriptors) {\n    events[pallet] ||= {}\n    const [, , evEntries] = descriptors[pallet]\n    for (const name in evEntries) {\n      events[pallet][name] = createEventEntry(\n        evEntries[name],\n        pallet,\n        name,\n        chainHead.getRuntimeContext$,\n        chainHead.finalized$,\n        chainHead.storage$,\n      )\n    }\n  }\n\n  return {\n    query: query as any,\n    tx: tx as any,\n    event: events as any,\n  }\n}\n\nexport const createClient: CreateClient = (connect, descriptors) => {\n  let createTx: CreateTx\n  const rawClient: SubstrateClient = createRawClient((onMsg) => {\n    const result = connect(onMsg)\n    createTx = result.createTx\n    return result\n  })\n  const client = getObservableClient(rawClient)\n  const chainHead = client.chainHead$()\n\n  const createTxFromAddress = async (address: string, callData: Uint8Array) => {\n    const { accountId } = await firstValueFrom(\n      chainHead.getRuntimeContext$(null),\n    )\n    return createTx(accountId.enc(address), callData)\n  }\n\n  return {\n    finalized$: chainHead.finalized$,\n    bestBlock$: chainHead.bestBlock$,\n    bestBlocks$: chainHead.bestBlocks$,\n    ...mapObject(descriptors, (des) =>\n      createNamespace(des, createTxFromAddress, chainHead, client),\n    ),\n  } as any\n}\n","import {\n  Observable,\n  debounceTime,\n  distinctUntilChanged,\n  exhaustMap,\n  map,\n  mergeMap,\n  withLatestFrom,\n} from \"rxjs\"\nimport { firstValueFromWithSignal } from \"@/utils\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport { getDynamicBuilder } from \"@polkadot-api/metadata-builders\"\nimport { RuntimeContext } from \"./observableClient/chainHead/chainHead\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : []\n\ntype StorageEntryWithoutKeys<Payload> = {\n  getValue: (options?: CallOptions) => Promise<Payload>\n  watchValue: () => Observable<Payload>\n}\n\ntype StorageEntryWithKeys<Args extends Array<any>, Payload> = {\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  watchValue: (...args: Args) => Observable<Payload>\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: Args; value: NonNullable<Payload> }>>\n}\n\nexport type StorageEntry<Args extends Array<any>, Payload> = Args extends []\n  ? StorageEntryWithoutKeys<Payload>\n  : StorageEntryWithKeys<Args, Payload>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createStorageEntry = (\n  checksum: string,\n  pallet: string,\n  name: string,\n  getRuntimeContext$: (hash: string | null) => Observable<RuntimeContext>,\n  storage$: Storage$,\n  finalized$: Observable<string>,\n) => {\n  const storageCall = <T, Type extends StorageItemInput[\"type\"]>(\n    at: string | null,\n    mapper: (\n      codecs: ReturnType<ReturnType<typeof getDynamicBuilder>[\"buildStorage\"]>,\n    ) => [\n      block: string | null,\n      args: [type: Type, key: string, childTrie: string | null],\n      decoder: (input: StorageResult<Type>) => T,\n    ],\n    signal?: AbortSignal,\n  ): Promise<T> => {\n    const request$ = getRuntimeContext$(at).pipe(\n      mergeMap((descriptors) => {\n        const actualChecksum = descriptors.checksumBuilder.buildStorage(\n          pallet,\n          name,\n        )\n        const codecs = descriptors.dynamicBuilder.buildStorage(pallet, name)\n        if (checksum !== actualChecksum)\n          throw new Error(\n            `Incompatible runtime entry Storage(${pallet}.${name})`,\n          )\n\n        const [block, args, decoder] = mapper(codecs)\n        return storage$(block, ...args).pipe(map(decoder))\n      }),\n    )\n    return firstValueFromWithSignal(request$, signal)\n  }\n\n  const watchValue = (...args: Array<any>) => {\n    const descriptors$ = finalized$.pipe(\n      mergeMap(getRuntimeContext$),\n      distinctUntilChanged(),\n      map((descriptors) =>\n        descriptors.dynamicBuilder.buildStorage(pallet, name),\n      ),\n    )\n\n    return finalized$.pipe(\n      debounceTime(0),\n      withLatestFrom(descriptors$),\n      exhaustMap(([latest, codecs]) =>\n        storage$(latest, \"value\", codecs.enc(...args), null).pipe(\n          map((val) => ({ val, codecs })),\n        ),\n      ),\n      distinctUntilChanged((a, b) => a.val === b.val),\n      map(({ codecs, val }) =>\n        val === null ? codecs.fallback : codecs.dec(val),\n      ),\n    )\n  }\n\n  const getValue = (...args: Array<any>) => {\n    const invalidArgs = () =>\n      new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    return storageCall(\n      at ?? null,\n      (codecs) => {\n        const actualArgs = args.length === codecs.len ? args : args.slice(0, -1)\n\n        if (args !== actualArgs && !isLastArgOptional) throw invalidArgs()\n\n        const key = codecs.enc(...actualArgs)\n        return [\n          at,\n          [\"value\", key, null],\n          (response: StorageResult<\"value\">) =>\n            response === null\n              ? codecs.fallback\n              : codecs.dec(response as string),\n        ]\n      },\n      signal,\n    )\n  }\n\n  const getEntries = (...args: Array<any>) => {\n    const invalidArgs = () =>\n      new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    return storageCall(\n      at,\n      (codecs) => {\n        if (args.length > codecs.len) throw invalidArgs()\n\n        const actualArgs =\n          args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n\n        if (args.length === codecs.len && actualArgs === args)\n          throw invalidArgs()\n\n        return [\n          at,\n          [\"descendantsValues\", codecs.enc(...actualArgs), null],\n          (x: StorageResult<\"descendantsValues\">) => {\n            return x.map(({ key, value }) => ({\n              keyArgs: codecs.keyDecoder(key),\n              value: codecs.dec(value),\n            }))\n          },\n        ]\n      },\n      signal,\n    )\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  return { getValue, getValues, getEntries, watchValue }\n}\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { Observable, OperatorFunction, Subscription } from \"rxjs\"\n\nexport function switchMapComplete<T, O>(\n  project: (value: T) => Observable<O>,\n): OperatorFunction<T, O> {\n  return (source: Observable<T>): Observable<O> =>\n    new Observable((observer) => {\n      let innerSubscription: Subscription | null = null\n      let outterSubscription = source.subscribe({\n        next(v) {\n          innerSubscription?.unsubscribe()\n          innerSubscription = project(v).subscribe({\n            next(iV) {\n              observer.next(iV)\n            },\n            error(e) {\n              observer.error(e)\n            },\n          })\n        },\n        complete() {\n          observer.complete()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n      return () => {\n        innerSubscription?.unsubscribe()\n        outterSubscription.unsubscribe()\n        innerSubscription = null\n      }\n    })\n}\n","import { Observable, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const onAbort = signal\n      ? () => {\n          subscription.unsubscribe()\n        }\n      : noop\n\n    let isDone = false\n    const subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n\n        // if the Observable emits synchronously, then `subscription`\n        // won't exist yet.\n        isDone = true\n        subscription?.unsubscribe()\n      },\n      error: (e) => {\n        reject(e)\n        signal?.removeEventListener(\"abort\", onAbort)\n      },\n      complete: () => {\n        reject(new Error(\"Observable completed without emitting\"))\n        signal?.removeEventListener(\"abort\", onAbort)\n      },\n    })\n\n    // in case that the observable emitted synchronously\n    if (isDone) {\n      subscription.unsubscribe()\n    } else {\n      signal?.addEventListener(\"abort\", onAbort)\n    }\n  })\n}\n","import { Observable, defer, scan } from \"rxjs\"\n\nexport const lazyScan =\n  <Acc, Item>(reducer: (acc: Acc, value: Item) => Acc, getInit: () => Acc) =>\n  (base: Observable<Item>): Observable<Acc> =>\n    defer(() => base.pipe(scan(reducer, getInit())))\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (topSubscription.closed && innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      const topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nexport const withoutComplete = <T>(source: Observable<T>) =>\n  new Observable<T>((observer) =>\n    source.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        observer.error(e)\n      },\n    }),\n  )\n","import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        teardown(source$)\n        if (e instanceof OperationLimitError) return addTask(data, true)\n\n        observer.error(e)\n        onEmptySlot()\n      },\n      complete() {\n        observer.complete()\n        onEmptySlot()\n      },\n    })\n\n    if (!observer.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n      })\n    }\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n","import {\n  Finalized,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  Subject,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  pairwise,\n  share,\n  skip,\n  startWith,\n} from \"rxjs\"\nimport { lazyScan } from \"@/utils\"\n\nexport const getWithUnpinning$ = (\n  finalized$: Observable<string>,\n  follow$: Observable<FollowEventWithRuntime>,\n  unpin: (hashes: string[]) => void,\n) => {\n  const userUsageInput$ = new Subject<{\n    type: \"hold\" | \"release\"\n    hash: string\n  }>()\n\n  const userUsage$ = new Observable<{\n    type: \"hold\" | \"release\"\n    hash: string\n    isUser: true\n  }>((observer) => {\n    const userSub = userUsageInput$.subscribe((value) => {\n      observer.next({ ...value, isUser: true })\n    })\n\n    const finSub = finalized$.subscribe({\n      error(e) {\n        observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    return () => {\n      userSub.unsubscribe()\n      finSub.unsubscribe()\n    }\n  })\n\n  // We ensure that the latest finalized block always stays pinned\n  const internalUsage$ = finalized$.pipe(\n    startWith(\"\"),\n    pairwise(),\n    mergeMap(([prev, current]) => [\n      { type: \"release\" as \"release\", hash: prev, isUser: false },\n      { type: \"hold\" as \"hold\", hash: current, isUser: false },\n    ]),\n    skip(1),\n  )\n\n  const unpinFromUsage$ = merge(internalUsage$, userUsage$).pipe(\n    lazyScan(\n      (acc, { isUser, type, hash }) => {\n        const { counters, bestBlocks } = acc\n        for (const hash in counters) if (!counters[hash]) delete counters[hash]\n\n        if (isUser && type === \"hold\" && !counters[hash]) {\n          bestBlocks[hash] ||= 0\n          bestBlocks[hash]++\n          return acc\n        }\n\n        if (isUser && type === \"release\" && bestBlocks[hash]) {\n          if (!--bestBlocks[hash]) delete bestBlocks[hash]\n          return acc\n        }\n\n        if (type === \"release\") {\n          counters[hash]--\n        } else {\n          counters[hash] ||= 0\n          counters[hash]++\n          if (!isUser && bestBlocks[hash]) {\n            counters[hash] += bestBlocks[hash]\n            delete bestBlocks[hash]\n          }\n        }\n\n        return acc\n      },\n      () => ({\n        counters: {} as Record<string, number>,\n        bestBlocks: {} as Record<string, number>,\n      }),\n    ),\n    map((acc) =>\n      Object.entries(acc.counters)\n        .filter(([, value]) => value === 0)\n        .map(([key]) => key),\n    ),\n    filter((x) => x.length > 0),\n    share(),\n  )\n\n  const unpinFromPrunned$ = follow$.pipe(\n    filter((e): e is Finalized => e.type === \"finalized\"),\n    map((e) => e.prunedBlockHashes),\n  )\n\n  merge(unpinFromUsage$, unpinFromPrunned$)\n    .pipe(filter((x) => x.length > 0))\n    .subscribe((hashes) => {\n      unpin(hashes)\n    })\n\n  const onHold = (hash: string) => {\n    userUsageInput$.next({ type: \"hold\", hash })\n  }\n  const onRelease = (hash: string) => {\n    setTimeout(() => {\n      userUsageInput$.next({ type: \"release\", hash })\n    }, 0)\n  }\n\n  const withUnpinning$ =\n    <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string, ...args: Args): Observable<T> => {\n      const base$ = fn(hash, ...args)\n      return new Observable<T>((observer) => {\n        onHold(hash)\n        const subscription = base$.subscribe(observer)\n        return () => {\n          subscription.unsubscribe()\n          onRelease(hash)\n        }\n      })\n    }\n\n  return { withUnpinning$, unpinFromUsage$ }\n}\n","import { withoutComplete } from \"@/utils\"\nimport {\n  Observable,\n  ReplaySubject,\n  concat,\n  mergeMap,\n  of,\n  share,\n  take,\n  takeWhile,\n} from \"rxjs\"\n\nconst DONE = Symbol(\"DONE\")\ntype DONE = typeof DONE\n\nconst delayUnsubscription = <T>(source$: Observable<T>) =>\n  new Observable<T>((observer) => {\n    const subscription = source$.subscribe(observer)\n    return () => {\n      setTimeout(() => {\n        subscription.unsubscribe()\n      }, 0)\n    }\n  })\n\nexport const getWithOptionalhash$ = (finalized$: Observable<string>) => {\n  const current$ = finalized$.pipe(\n    take(1),\n    withoutComplete,\n    share({\n      connector: () => new ReplaySubject(1),\n      resetOnError: true,\n      resetOnRefCountZero: true,\n      resetOnComplete: false,\n    }),\n    delayUnsubscription,\n  )\n\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) =>\n      hash\n        ? fn(hash, ...args)\n        : current$.pipe(\n            mergeMap((h) => concat(fn(h, ...args), of(DONE))),\n            takeWhile((x): x is T => x !== DONE),\n          )\n}\n","import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n","import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n","import { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\nimport { Observable, catchError, concatMap, throwError, timer } from \"rxjs\"\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const withOperationInaccessibleRecovery =\n  <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n  (...args: Args): Observable<T> =>\n    operable(fn(...args))\n","import { shareLatest } from \"@/utils\"\nimport { FollowEventWithRuntime, Runtime } from \"@polkadot-api/substrate-client\"\nimport { Observable, distinctUntilChanged, map, scan } from \"rxjs\"\n\nexport const getRuntime$ = (follow$: Observable<FollowEventWithRuntime>) => {\n  const shared = follow$.pipe(\n    scan(\n      (acc, event) => {\n        if (event.type === \"initialized\") {\n          acc.candidates.clear()\n          acc.current = event.finalizedBlockRuntime\n        }\n\n        if (event.type === \"newBlock\" && event.newRuntime)\n          acc.candidates.set(event.blockHash, event.newRuntime)\n\n        if (event.type !== \"finalized\") return acc\n\n        const [newRuntimeHash] = event.finalizedBlockHashes\n          .filter((h) => acc.candidates.has(h))\n          .slice(-1)\n        if (newRuntimeHash) acc.current = acc.candidates.get(newRuntimeHash)!\n\n        acc.candidates.clear()\n        return acc\n      },\n      {\n        candidates: new Map<string, Runtime>(),\n        current: {} as Runtime,\n      },\n    ),\n    shareLatest,\n  )\n\n  const candidates$ = shared.pipe(map((x) => x.candidates))\n\n  const runtime$ = shared.pipe(\n    map((x) => x.current),\n    distinctUntilChanged(),\n    shareLatest,\n  )\n\n  return { runtime$, candidates$ }\n}\n","import {\n  ChainHead,\n  FollowEventWithRuntime,\n  FollowResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, noop, share } from \"rxjs\"\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse\n  let unfollow: () => void = noop\n\n  const follow$ = new Observable<FollowEventWithRuntime>((observer) => {\n    follower = chainHead(\n      true,\n      (e) => {\n        observer.next(e)\n      },\n      (e) => {\n        console.warn(\"chainHead crashed\")\n        console.error(e)\n        observer.error(e)\n      },\n    )\n    unfollow = () => {\n      observer.complete()\n      follower.unfollow()\n    }\n  }).pipe(share())\n\n  return {\n    getFollower: () => {\n      if (!follower) throw new Error(\"Missing chainHead subscription\")\n      return follower\n    },\n    unfollow: () => {\n      unfollow()\n    },\n    follow$,\n  }\n}\n","import type { FollowEventWithRuntime } from \"@polkadot-api/substrate-client\"\nimport type { Observable } from \"rxjs\"\n\nimport { mergeMap } from \"rxjs\"\nimport { shareLatest } from \"@/utils\"\n\nexport const getFinalized$ = (follow$: Observable<FollowEventWithRuntime>) =>\n  follow$.pipe(\n    mergeMap((e) => {\n      if (e.type === \"finalized\") return e.finalizedBlockHashes\n      if (e.type !== \"initialized\") return []\n      return [e.finalizedBlockHash]\n    }),\n    shareLatest,\n  )\n","import { Tuple, compact, metadata } from \"@polkadot-api/substrate-bindings\"\nimport { Runtime } from \"@polkadot-api/substrate-client\"\nimport { Observable, map, startWith, withLatestFrom } from \"rxjs\"\nimport { switchMapComplete, shareLatest } from \"@/utils\"\n\nconst opaqueMeta = Tuple(compact, metadata)\n\nexport const getMetadata$ = (\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  runtime$: Observable<Runtime>,\n  finalized$: Observable<string>,\n) => {\n  const _getMetadata$ = ([, hash]: [runtime: Runtime, hash: string]) =>\n    call$(hash, \"Metadata_metadata\", \"\").pipe(\n      map((response) => {\n        const metadata = opaqueMeta.dec(response)[1]\n        if (metadata.metadata.tag !== \"v14\")\n          throw new Error(\"Wrong metadata version\")\n        return metadata.metadata.value\n      }),\n      startWith(null),\n    )\n\n  return runtime$.pipe(\n    withLatestFrom(finalized$),\n    switchMapComplete(_getMetadata$),\n    shareLatest,\n  )\n}\n","import type {\n  ChainHead,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  getWithRecovery,\n  getWithUnpinning$,\n  getWithOptionalhash$,\n  fromAbortControllerFn,\n  withLazyFollower,\n  withOperationInaccessibleRecovery,\n} from \"./enhancers\"\nimport { getRuntime$, getFollow$, getFinalized$, getMetadata$ } from \"./streams\"\nimport {\n  EMPTY,\n  Observable,\n  asapScheduler,\n  filter,\n  from,\n  map,\n  mergeAll,\n  mergeMap,\n  observeOn,\n  pipe,\n  shareReplay,\n  take,\n  withLatestFrom,\n} from \"rxjs\"\nimport {\n  Decoder,\n  getChecksumBuilder,\n  getDynamicBuilder,\n} from \"@polkadot-api/metadata-builders\"\nimport { concatMapEager, shareLatest } from \"@/utils\"\nimport {\n  AccountId,\n  Codec,\n  SS58String,\n  blockHeader,\n} from \"@polkadot-api/substrate-bindings\"\nimport { getBestBlock$, getBestBlocks$ } from \"./streams/best-block\"\n\nexport type { BlockHeaderWithHash } from \"./streams/best-block\"\n\nexport interface RuntimeContext {\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<any>\n  }\n  accountId: Codec<SS58String>\n}\n\nexport default (chainHead: ChainHead) => () => {\n  const { getFollower, unfollow, follow$ } = getFollow$(chainHead)\n\n  const lazyFollower = withLazyFollower(getFollower)\n\n  const { runtime$, candidates$: runtimeCandidates$ } = getRuntime$(follow$)\n  const _finalized$ = getFinalized$(follow$)\n  const bestBlock$ = getBestBlock$(follow$)\n\n  const { withUnpinning$, unpinFromUsage$ } = getWithUnpinning$(\n    _finalized$,\n    follow$,\n    lazyFollower(\"unpin\"),\n  )\n\n  const withOptionalHash$ = getWithOptionalhash$(_finalized$)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n  ) =>\n    withOptionalHash$(withUnpinning$(withRecoveryFn(fromAbortControllerFn(fn))))\n\n  const call$ = commonEnhancer(lazyFollower(\"call\"))\n  const body$ = commonEnhancer(lazyFollower(\"body\"))\n  const storage$ = withOperationInaccessibleRecovery(\n    commonEnhancer(lazyFollower(\"storage\")),\n  )\n\n  const lazyHeader = lazyFollower(\"header\")\n  const header$ = pipe(\n    withUnpinning$((hash: string) => from(lazyHeader(hash))),\n    map(blockHeader.dec),\n  )\n\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            observer.next(\n              recoveralStorage$(\n                hash,\n                queries.slice(-nDiscarded),\n                childTrie,\n                true,\n              ),\n            )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  const storageQueries$ = withOperationInaccessibleRecovery(\n    withOptionalHash$(\n      withUnpinning$(\n        (hash: string, queries: Array<StorageItemInput>, childTrie?: string) =>\n          recoveralStorage$(hash, queries, childTrie ?? null, false),\n      ),\n    ),\n  )\n\n  const metadata$ = getMetadata$(call$, runtime$, _finalized$)\n  const runtimeContext$ = runtime$.pipe(\n    map(() => {\n      const result = metadata$.pipe(\n        filter(Boolean),\n        map((metadata): RuntimeContext => {\n          const checksumBuilder = getChecksumBuilder(metadata)\n          const dynamicBuilder = getDynamicBuilder(metadata)\n          const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n          return {\n            checksumBuilder,\n            dynamicBuilder,\n            events: {\n              key: events.enc(),\n              dec: events.dec,\n            },\n            accountId: AccountId(dynamicBuilder.ss58Prefix),\n          }\n        }),\n        take(1),\n        shareReplay(1),\n      )\n      result.subscribe()\n      return result\n    }),\n    shareLatest,\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  metadata$.subscribe()\n\n  const currentFinalized$ = new Observable<\n    Record<string, Observable<RuntimeContext>>\n  >((observer) => {\n    let latestRuntimeCtx: Observable<RuntimeContext>\n    const toRemove = new Set<string>()\n    const result: Record<string, Observable<RuntimeContext>> = {}\n\n    const sub1 = runtimeContext$.subscribe({\n      next(v) {\n        latestRuntimeCtx = v\n      },\n      error(e) {\n        observer.error(e)\n      },\n    })\n\n    const sub2 = unpinFromUsage$.subscribe({\n      next(v) {\n        v.forEach((x) => {\n          if (result[x]) delete result[x]\n          else toRemove.add(x)\n        })\n      },\n      error(e) {\n        observer.error(e)\n      },\n    })\n\n    const sub3 = _finalized$.pipe(observeOn(asapScheduler)).subscribe({\n      next(v) {\n        if (toRemove.has(v)) toRemove.delete(v)\n        else result[v] = latestRuntimeCtx\n        observer.next(result)\n      },\n      error(e) {\n        observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    return () => {\n      sub3.unsubscribe()\n      sub2.unsubscribe()\n      sub1.unsubscribe()\n    }\n  }).pipe(\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  const getRuntimeContext$ = withOptionalHash$((hash: string) =>\n    currentFinalized$.pipe(\n      withLatestFrom(runtimeCandidates$),\n      take(1),\n      mergeMap(\n        ([x, runtimeCandidates]) =>\n          x[hash] ??\n          (runtimeCandidates.has(hash) ? EMPTY : Object.values(x).slice(-1)[0]),\n      ),\n    ),\n  )\n  currentFinalized$.subscribe()\n\n  const bestBlocks$ = getBestBlocks$(bestBlock$, _finalized$, header$)\n\n  const finalizedHeader$ = _finalized$.pipe(\n    concatMapEager((hash) =>\n      header$(hash).pipe(map((header) => ({ hash, header }))),\n    ),\n    shareLatest,\n  )\n  finalizedHeader$.subscribe()\n  const finalized$ = finalizedHeader$.pipe(map((x) => x.hash))\n\n  return {\n    finalized$,\n    finalizedHeader$,\n    bestBlock$,\n    bestBlocks$,\n    follow$,\n    runtime$,\n    metadata$,\n    body$,\n    call$,\n    storage$,\n    storageQueries$,\n    unfollow,\n    getRuntimeContext$,\n  }\n}\n","import type {\n  BestBlockChanged,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  Subject,\n  Subscription,\n  concatMap,\n  startWith,\n  tap,\n  withLatestFrom,\n} from \"rxjs\"\n\nimport { combineLatest, filter, map } from \"rxjs\"\nimport { shareLatest } from \"@/utils\"\nimport { BlockHeader } from \"@polkadot-api/substrate-bindings\"\n\nexport const getBestBlock$ = (follow$: Observable<FollowEventWithRuntime>) =>\n  follow$.pipe(\n    filter((e): e is BestBlockChanged => e.type === \"bestBlockChanged\"),\n    map((e) => e.bestBlockHash),\n    shareLatest,\n  )\n\nexport type BlockHeaderWithHash = { hash: string; header: BlockHeader }\n\nexport const getBestBlocks$ = (\n  best$: Observable<string>,\n  finalized$: Observable<string>,\n  getHeader$: (hash: string) => Observable<BlockHeader>,\n): Observable<Array<BlockHeaderWithHash>> => {\n  const _current$ = new Subject<Map<string, BlockHeader>>()\n  const getBlocks$ = (\n    best: string,\n    finalized: string,\n    current: Map<string, BlockHeader>,\n  ): Observable<Map<string, BlockHeader>> =>\n    new Observable((observer) => {\n      const result = new Map<string, BlockHeader>()\n      let sub: Subscription\n\n      const process = (hash: string) => {\n        if (hash === finalized) {\n          observer.next(result)\n          observer.complete()\n          return\n        }\n\n        const header = current.get(hash)\n        if (header) {\n          result.set(hash, header)\n          process(header.parentHash)\n          return\n        }\n\n        sub = getHeader$(hash).subscribe({\n          next(header) {\n            result.set(hash, header)\n            process(header.parentHash)\n          },\n          error(e) {\n            observer.error(e)\n          },\n        })\n      }\n\n      process(best)\n\n      return () => {\n        sub?.unsubscribe()\n      }\n    })\n\n  return combineLatest({ best: best$, finalized: finalized$ }).pipe(\n    withLatestFrom(_current$.pipe(startWith(new Map()))),\n    concatMap(([{ best, finalized }, current]) =>\n      getBlocks$(best, finalized, current).pipe(\n        tap((x) => {\n          _current$.next(x)\n        }),\n        map((state) => {\n          const result: Array<BlockHeaderWithHash> = []\n          let hash = best\n          while (hash !== finalized) {\n            const header = state.get(hash)!\n            result.push({ hash, header })\n            hash = header.parentHash\n          }\n          return result\n        }),\n      ),\n    ),\n    shareLatest,\n  )\n}\n","import type {\n  SubstrateClient,\n  TxBestChainBlockIncluded,\n  TxBroadcasted,\n  TxDropped,\n  TxFinalized,\n  TxInvalid,\n  TxValidated,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nconst terminalTxEvents = new Set([\"error\", \"finalized\", \"invalid\", \"dropped\"])\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<\n      | TxValidated\n      | TxBroadcasted\n      | TxBestChainBlockIncluded\n      | TxFinalized\n      | TxInvalid\n      | TxDropped\n    >((observer) =>\n      baseTransaction(\n        transaction,\n        (event) => {\n          if (event.type === \"error\")\n            return observer.error(new Error(event.error))\n\n          observer.next(event)\n          if (terminalTxEvents.has(event.type)) observer.complete()\n        },\n        (error) => {\n          observer.error(error)\n        },\n      ),\n    )\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nimport getChainHead$ from \"./chainHead/chainHead\"\nimport getTx$ from \"./tx\"\n\nexport const getObservableClient = ({\n  chainHead,\n  transaction,\n  destroy,\n}: SubstrateClient) => ({\n  chainHead$: getChainHead$(chainHead),\n  tx$: getTx$(transaction),\n  destroy,\n})\n","import type { SS58String, TxDescriptor } from \"@polkadot-api/substrate-bindings\"\nimport type { Storage$ } from \"./storage\"\nimport type {\n  TxBestChainBlockIncluded,\n  TxBroadcasted,\n  TxFinalized,\n  TxValidated,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  firstValueFrom,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n} from \"rxjs\"\nimport { mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { getObservableClient } from \"./observableClient\"\nimport { RuntimeContext } from \"./observableClient/chainHead/chainHead\"\n\ntype SystemEvent = {\n  phase:\n    | { tag: \"ApplyExtrinsic\"; value: number }\n    | { tag: \"Finalization\" }\n    | { tag: \"Initialization\" }\n  event: {\n    tag: string\n    value: {\n      tag: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\ntype TxSuccess = {\n  ok: boolean\n  events: Array<SystemEvent[\"event\"]>\n}\n\ntype TxFunction<Args extends Array<any>> = (\n  from: SS58String,\n  ...args: Args\n) => Promise<TxSuccess>\n\ntype TxObservable<Args extends Array<any>> = (\n  from: SS58String,\n  ...args: Args\n) => Observable<\n  | TxValidated\n  | TxBroadcasted\n  | TxBestChainBlockIncluded\n  | (TxFinalized & TxSuccess)\n>\n\ntype TxCall<Args extends Array<any>> = (...args: Args) => Promise<string>\n\ntype TxSigned<Args extends Array<any>> = (\n  from: SS58String,\n  ...args: Args\n) => Promise<string>\n\nexport type TxClient<Args extends Array<any>> = {\n  getCallData: TxCall<Args>\n  getTx: TxSigned<Args>\n  submit: TxFunction<Args>\n  submit$: TxObservable<Args>\n}\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): TxSuccess => {\n  const events = systemEvents\n    .filter((x) => x.phase.tag === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => x.event)\n\n  const lastEvent = events[events.length - 1]\n  const ok =\n    lastEvent.tag === \"System\" && lastEvent.value.tag === \"ExtrinsicSuccess\"\n\n  return { ok, events }\n}\n\nexport const createTxEntry = <Args extends Array<any>>(\n  descriptor: TxDescriptor<Args>,\n  pallet: string,\n  name: string,\n  getRuntimeContext$: (blockHash: string | null) => Observable<RuntimeContext>,\n  client: ReturnType<typeof getObservableClient>,\n  storage$: Storage$,\n  signer: (from: string, callData: Uint8Array) => Promise<Uint8Array>,\n): TxClient<Args> => {\n  const getCallDataAndEventDec$ = (...decodedArgs: Args) =>\n    getRuntimeContext$(null).pipe(\n      map(({ events, checksumBuilder, dynamicBuilder }) => {\n        const checksum = checksumBuilder.buildCall(pallet, name)\n        if (checksum !== descriptor)\n          throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`)\n\n        const { location, args } = dynamicBuilder.buildCall(pallet, name)\n        return {\n          callData: mergeUint8(new Uint8Array(location), args.enc(decodedArgs)),\n          events,\n        }\n      }),\n    )\n\n  const getCallData: TxCall<Args> = (...args) =>\n    firstValueFrom(getCallDataAndEventDec$(...args)).then((x) =>\n      toHex(x.callData),\n    )\n\n  const getTx: TxSigned<Args> = (from, ...args) =>\n    firstValueFrom(\n      getCallDataAndEventDec$(...args).pipe(\n        mergeMap(({ callData }) => signer(from, callData)),\n        map(toHex),\n      ),\n    )\n\n  const submit: TxFunction<Args> = async (from, ...args) => {\n    const [tx, { key, dec }] = await firstValueFrom(\n      getCallDataAndEventDec$(...args).pipe(\n        mergeMap(({ callData, events }) =>\n          signer(from, callData).then((result) => ({\n            result,\n            events,\n          })),\n        ),\n        map((x) => [toHex(x.result), x.events] as const),\n      ),\n    )\n\n    const result = await lastValueFrom(client.tx$(tx))\n\n    switch (result.type) {\n      case \"invalid\":\n        throw new Error(\"Invalid\")\n      case \"dropped\":\n        throw new Error(\"Dropped\")\n      case \"finalized\": {\n        const systemEvents = await firstValueFrom(\n          storage$(result.block.hash, \"value\", key, null).pipe(\n            map((x) => dec(x!)),\n          ),\n        )\n\n        return getTxSuccessFromSystemEvents(\n          systemEvents,\n          Number(result.block.index),\n        )\n      }\n      default:\n        return { ok: true, events: [] }\n    }\n  }\n\n  const submit$: TxObservable<Args> = (from, ...args) =>\n    getCallDataAndEventDec$(...args).pipe(\n      mergeMap(({ callData, events }) =>\n        signer(from, callData).then((result) => ({\n          result,\n          events,\n        })),\n      ),\n      take(1),\n      mergeMap(({ result, events: { key, dec } }) => {\n        return client.tx$(toHex(result)).pipe(\n          mergeMap((result) => {\n            switch (result.type) {\n              case \"invalid\":\n                throw new Error(\"Invalid\")\n              case \"dropped\":\n                throw new Error(\"Dropped\")\n              case \"finalized\": {\n                return storage$(result.block.hash, \"value\", key, null).pipe(\n                  map((x) => dec(x!)),\n                  map((events) => ({\n                    ...result,\n                    ...getTxSuccessFromSystemEvents(\n                      events,\n                      Number(result.block.index),\n                    ),\n                  })),\n                )\n              }\n              default:\n                return of(result)\n            }\n          }),\n        )\n      }),\n    )\n\n  return { getCallData, getTx, submit, submit$ }\n}\n","import { PlainDescriptor } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { Storage$ } from \"./storage\"\nimport { concatMapEager, shareLatest } from \"./utils\"\nimport { RuntimeContext } from \"./observableClient/chainHead/chainHead\"\n\nexport type EventPhase =\n  | { tag: \"ApplyExtrinsic\"; value: number }\n  | { tag: \"Finalization\" }\n  | { tag: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    blockHash: string\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      blockHash: string\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<T> = {\n  watch: EvWatch<T>\n  pull: EvPull<T>\n  filter: EvFilter<T>\n}\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    tag: string\n    value: {\n      tag: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <T>(\n  checksum: PlainDescriptor<T>,\n  pallet: string,\n  name: string,\n  getRuntimeContext$: (blockHash: string | null) => Observable<RuntimeContext>,\n  finalized: Observable<string>,\n  storage$: Storage$,\n): EvClient<T> => {\n  const shared$ = finalized.pipe(\n    concatMapEager((block) =>\n      getRuntimeContext$(block).pipe(map((context) => ({ context, block }))),\n    ),\n    concatMapEager(\n      ({\n        block,\n        context: {\n          events: { key, dec },\n          checksumBuilder,\n        },\n      }) => {\n        const actualChecksum = checksumBuilder.buildEvent(pallet, name)\n\n        if (checksum !== actualChecksum)\n          throw new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n\n        return storage$(block, \"value\", key, null).pipe(\n          map((x) => {\n            const events = dec(x!) as Array<SystemEvent>\n            const winners = events.filter(\n              (e) => e.event.tag === pallet && e.event.value.tag === name,\n            )\n            return winners.map((x) => {\n              return {\n                meta: {\n                  phase: x.phase,\n                  blockHash: block,\n                },\n                payload: x.event.value.value,\n              }\n            })\n          }),\n        )\n      },\n    ),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.tag === pallet && e.value.tag === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter }\n}\n"],"mappings":"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","names":["src_exports","__export","createClient","getObservableClient","__toCommonJS","import_substrate_client","import_rxjs","import_rxjs","shareLatest","import_rxjs","switchMapComplete","project","source","observer","innerSubscription","outterSubscription","v","iV","e","import_rxjs","firstValueFromWithSignal","source","signal","resolve","reject","onAbort","subscription","isDone","value","e","import_rxjs","lazyScan","reducer","getInit","base","import_rxjs","concatMapEager","mapper","concurrent","source$","observer","queues","innerSubscriptions","results","mapperIdx","subscriptionIdx","observerIdx","nextSubscription","inner$","topSubscription","idx","x","e","outterValue","subscription","import_rxjs","withoutComplete","source","observer","x","e","isOptionalArg","lastArg","k","createStorageEntry","checksum","pallet","name","getRuntimeContext$","storage$","finalized$","storageCall","at","mapper","signal","request$","descriptors","actualChecksum","codecs","block","args","decoder","firstValueFromWithSignal","watchValue","descriptors$","latest","val","a","b","getValue","invalidArgs","isLastArgOptional","_at","actualArgs","key","response","keyArgs","options","x","value","import_substrate_client","import_rxjs","PendingTaskQueue","__publicField","node","value","newNode","result","getWithRecovery","tearDownOperations","setTeardown","observable","cb","teardown","pendingTasks","unshift","push","addTask","task","topPriority","fn","onEmptySlot","data","process","source$","observer","subscription","x","e","withRecovery","pendingTask","withNormalRecovery","args","import_rxjs","getWithUnpinning$","finalized$","follow$","unpin","userUsageInput$","userUsage$","observer","userSub","value","finSub","e","internalUsage$","prev","current","unpinFromUsage$","lazyScan","acc","isUser","type","hash","counters","bestBlocks","key","x","unpinFromPrunned$","hashes","onHold","onRelease","fn","args","base$","subscription","import_rxjs","DONE","delayUnsubscription","source$","observer","subscription","getWithOptionalhash$","finalized$","current$","withoutComplete","fn","hash","args","h","x","import_rxjs","fromAbortControllerFn","fn","args","observer","aborter","value","error","withLazyFollower","getFollower","key","args","import_substrate_client","import_rxjs","operable","source$","result","e","withOperationInaccessibleRecovery","fn","args","import_rxjs","getRuntime$","follow$","shared","acc","event","newRuntimeHash","h","shareLatest","candidates$","x","import_rxjs","getFollow$","chainHead","follower","unfollow","follow$","observer","e","import_rxjs","getFinalized$","follow$","shareLatest","import_substrate_bindings","import_rxjs","opaqueMeta","getMetadata$","call$","runtime$","finalized$","_getMetadata$","hash","response","metadata","switchMapComplete","shareLatest","import_rxjs","import_metadata_builders","import_substrate_bindings","import_rxjs","getBestBlock$","follow$","shareLatest","getBestBlocks$","best$","finalized$","getHeader$","_current$","getBlocks$","best","finalized","current","observer","result","sub","process","hash","header","e","x","state","chainHead_default","chainHead","getFollower","unfollow","follow$","getFollow$","lazyFollower","withLazyFollower","runtime$","runtimeCandidates$","getRuntime$","_finalized$","getFinalized$","bestBlock$","getBestBlock$","withUnpinning$","unpinFromUsage$","getWithUnpinning$","withOptionalHash$","getWithOptionalhash$","withRecovery","withRecoveryFn","getWithRecovery","commonEnhancer","fn","fromAbortControllerFn","call$","body$","storage$","withOperationInaccessibleRecovery","lazyHeader","header$","hash","recoveralStorage$","queries","childTrie","isHighPriority","observer","items","error","nDiscarded","storageQueries$","metadata$","getMetadata$","runtimeContext$","result","metadata","checksumBuilder","dynamicBuilder","events","shareLatest","currentFinalized$","latestRuntimeCtx","toRemove","sub1","v","e","sub2","x","sub3","getRuntimeContext$","runtimeCandidates","bestBlocks$","getBestBlocks$","finalizedHeader$","concatMapEager","header","import_rxjs","terminalTxEvents","tx_default","baseTransaction","transaction","observer","event","error","getObservableClient","chainHead","transaction","destroy","chainHead_default","tx_default","import_rxjs","import_utils","getTxSuccessFromSystemEvents","systemEvents","txIdx","events","x","lastEvent","createTxEntry","descriptor","pallet","name","getRuntimeContext$","client","storage$","signer","getCallDataAndEventDec$","decodedArgs","checksumBuilder","dynamicBuilder","location","args","from","callData","tx","key","dec","result","import_rxjs","import_rxjs","createEventEntry","checksum","pallet","name","getRuntimeContext$","finalized","storage$","shared$","concatMapEager","block","context","key","dec","checksumBuilder","actualChecksum","x","e","shareLatest","f","d","events","import_utils","createNamespace","descriptors","createTxFromAddress","chainHead","client","query","pallet","stgEntries","name","createStorageEntry","tx","txEntries","createTxEntry","events","evEntries","createEventEntry","createClient","connect","createTx","rawClient","createRawClient","onMsg","result","getObservableClient","address","callData","accountId","des"]}