"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createClient: () => createClient,
  getObservableClient: () => getObservableClient
});
module.exports = __toCommonJS(src_exports);

// src/client.ts
var import_substrate_client3 = require("@polkadot-api/substrate-client");

// src/storage.ts
var import_rxjs7 = require("rxjs");

// src/utils/shareLatest.ts
var import_rxjs = require("rxjs");
var shareLatest = (0, import_rxjs.share)({
  connector: () => new import_rxjs.ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// src/utils/switchMapComplete.ts
var import_rxjs2 = require("rxjs");
function switchMapComplete(project) {
  return (source) => new import_rxjs2.Observable((observer) => {
    let innerSubscription = null;
    let outterSubscription = source.subscribe({
      next(v) {
        innerSubscription?.unsubscribe();
        innerSubscription = project(v).subscribe({
          next(iV) {
            observer.next(iV);
          },
          error(e) {
            observer.error(e);
          }
        });
      },
      complete() {
        observer.complete();
      },
      error(e) {
        observer.error(e);
      }
    });
    return () => {
      innerSubscription?.unsubscribe();
      outterSubscription.unsubscribe();
      innerSubscription = null;
    };
  });
}

// src/utils/firstValueFromWithSignal.ts
var import_rxjs3 = require("rxjs");
function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    const onAbort = signal ? () => {
      subscription.unsubscribe();
    } : import_rxjs3.noop;
    let isDone = false;
    const subscription = source.subscribe({
      next: (value) => {
        resolve(value);
        isDone = true;
        subscription?.unsubscribe();
      },
      error: (e) => {
        reject(e);
        signal?.removeEventListener("abort", onAbort);
      },
      complete: () => {
        reject(new Error("Observable completed without emitting"));
        signal?.removeEventListener("abort", onAbort);
      }
    });
    if (isDone) {
      subscription.unsubscribe();
    } else {
      signal?.addEventListener("abort", onAbort);
    }
  });
}

// src/utils/lazyScan.ts
var import_rxjs4 = require("rxjs");
var lazyScan = (reducer, getInit) => (base) => (0, import_rxjs4.defer)(() => base.pipe((0, import_rxjs4.scan)(reducer, getInit())));

// src/utils/concatMapEager.ts
var import_rxjs5 = require("rxjs");
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new import_rxjs5.Observable((observer) => {
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (topSubscription.closed && innerSubscriptions.size === 0) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    innerSubscriptions.set(
      idx,
      inner$.subscribe({
        next(x) {
          if (observerIdx === idx) {
            observer.next(x);
          } else {
            results.get(idx).push(x);
          }
        },
        complete() {
          innerSubscriptions.delete(idx);
          if (idx === observerIdx) {
            observerIdx++;
            while (results.has(observerIdx)) {
              results.get(observerIdx).forEach((x) => observer.next(x));
              results.delete(observerIdx);
              if (innerSubscriptions.has(observerIdx)) {
                break;
              }
              observerIdx++;
            }
          }
          nextSubscription();
        },
        error(e) {
          observer.error(e);
        }
      })
    );
  };
  const topSubscription = source$.subscribe({
    next(outterValue) {
      const idx = mapperIdx++;
      queues.set(
        idx,
        (0, import_rxjs5.defer)(() => mapper(outterValue, idx))
      );
      if (innerSubscriptions.size < concurrent) {
        nextSubscription();
      }
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (innerSubscriptions.size === 0) {
        observer.complete();
      }
    }
  });
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// src/utils/withoutComplete.ts
var import_rxjs6 = require("rxjs");
var withoutComplete = (source) => new import_rxjs6.Observable(
  (observer) => source.subscribe({
    next(x) {
      observer.next(x);
    },
    error(e) {
      observer.error(e);
    }
  })
);

// src/storage.ts
var isOptionalArg = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createStorageEntry = (checksum, pallet, name, getRuntimeContext$, storage$, finalized$) => {
  const storageCall = (at, mapper, signal) => {
    const request$ = getRuntimeContext$(at).pipe(
      (0, import_rxjs7.mergeMap)((descriptors) => {
        const actualChecksum = descriptors.checksumBuilder.buildStorage(
          pallet,
          name
        );
        const codecs = descriptors.dynamicBuilder.buildStorage(pallet, name);
        if (checksum !== actualChecksum)
          throw new Error(
            `Incompatible runtime entry Storage(${pallet}.${name})`
          );
        const [block, args, decoder] = mapper(codecs);
        return storage$(block, ...args).pipe((0, import_rxjs7.map)(decoder));
      })
    );
    return firstValueFromWithSignal(request$, signal);
  };
  const watchValue = (...args) => {
    const descriptors$ = finalized$.pipe(
      (0, import_rxjs7.mergeMap)(getRuntimeContext$),
      (0, import_rxjs7.distinctUntilChanged)(),
      (0, import_rxjs7.map)(
        (descriptors) => descriptors.dynamicBuilder.buildStorage(pallet, name)
      )
    );
    return finalized$.pipe(
      (0, import_rxjs7.debounceTime)(0),
      (0, import_rxjs7.withLatestFrom)(descriptors$),
      (0, import_rxjs7.exhaustMap)(
        ([latest, codecs]) => storage$(latest, "value", codecs.enc(...args), null).pipe(
          (0, import_rxjs7.map)((val) => ({ val, codecs }))
        )
      ),
      (0, import_rxjs7.distinctUntilChanged)((a, b) => a.val === b.val),
      (0, import_rxjs7.map)(
        ({ codecs, val }) => val === null ? codecs.fallback : codecs.dec(val)
      )
    );
  };
  const getValue = (...args) => {
    const invalidArgs = () => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    return storageCall(
      at ?? null,
      (codecs) => {
        const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
        if (args !== actualArgs && !isLastArgOptional)
          throw invalidArgs();
        const key = codecs.enc(...actualArgs);
        return [
          at,
          ["value", key, null],
          (response) => response === null ? codecs.fallback : codecs.dec(response)
        ];
      },
      signal
    );
  };
  const getEntries = (...args) => {
    const invalidArgs = () => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    return storageCall(
      at,
      (codecs) => {
        if (args.length > codecs.len)
          throw invalidArgs();
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs();
        return [
          at,
          ["descendantsValues", codecs.enc(...actualArgs), null],
          (x) => {
            return x.map(({ key, value }) => ({
              keyArgs: codecs.keyDecoder(key),
              value: codecs.dec(value)
            }));
          }
        ];
      },
      signal
    );
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  return { getValue, getValues, getEntries, watchValue };
};

// src/observableClient/chainHead/enhancers/operationLimitRecovery.ts
var import_substrate_client = require("@polkadot-api/substrate-client");
var import_rxjs8 = require("rxjs");
var PendingTaskQueue = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value) {
    const newNode = { value };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value) {
    this.first = { value, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    const result = this.first?.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        delete this.first.prev?.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
};
var getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable, cb) => {
    tearDownOperations.set(observable, () => {
      tearDownOperations.delete(observable);
      cb();
    });
  };
  const teardown = (observable) => {
    tearDownOperations.get(observable)?.();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data)
      return;
    tearDownOperations.delete(data.source$);
    process(data);
  };
  const process = (data) => {
    const { source$, observer } = data;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        teardown(source$);
        if (e instanceof import_substrate_client.OperationLimitError)
          return addTask(data, true);
        observer.error(e);
        onEmptySlot();
      },
      complete() {
        observer.complete();
        onEmptySlot();
      }
    });
    if (!observer.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
      });
    }
  };
  const withRecovery = (topPriority = false) => (source$) => new import_rxjs8.Observable((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery, withRecoveryFn };
};

// src/observableClient/chainHead/enhancers/unpin.ts
var import_rxjs9 = require("rxjs");
var getWithUnpinning$ = (finalized$, follow$, unpin) => {
  const userUsageInput$ = new import_rxjs9.Subject();
  const userUsage$ = new import_rxjs9.Observable((observer) => {
    const userSub = userUsageInput$.subscribe((value) => {
      observer.next({ ...value, isUser: true });
    });
    const finSub = finalized$.subscribe({
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    return () => {
      userSub.unsubscribe();
      finSub.unsubscribe();
    };
  });
  const internalUsage$ = finalized$.pipe(
    (0, import_rxjs9.startWith)(""),
    (0, import_rxjs9.pairwise)(),
    (0, import_rxjs9.mergeMap)(([prev, current]) => [
      { type: "release", hash: prev, isUser: false },
      { type: "hold", hash: current, isUser: false }
    ]),
    (0, import_rxjs9.skip)(1)
  );
  const unpinFromUsage$ = (0, import_rxjs9.merge)(internalUsage$, userUsage$).pipe(
    lazyScan(
      (acc, { isUser, type, hash }) => {
        const { counters, bestBlocks } = acc;
        for (const hash2 in counters)
          if (!counters[hash2])
            delete counters[hash2];
        if (isUser && type === "hold" && !counters[hash]) {
          bestBlocks[hash] || (bestBlocks[hash] = 0);
          bestBlocks[hash]++;
          return acc;
        }
        if (isUser && type === "release" && bestBlocks[hash]) {
          if (!--bestBlocks[hash])
            delete bestBlocks[hash];
          return acc;
        }
        if (type === "release") {
          counters[hash]--;
        } else {
          counters[hash] || (counters[hash] = 0);
          counters[hash]++;
          if (!isUser && bestBlocks[hash]) {
            counters[hash] += bestBlocks[hash];
            delete bestBlocks[hash];
          }
        }
        return acc;
      },
      () => ({
        counters: {},
        bestBlocks: {}
      })
    ),
    (0, import_rxjs9.map)(
      (acc) => Object.entries(acc.counters).filter(([, value]) => value === 0).map(([key]) => key)
    ),
    (0, import_rxjs9.filter)((x) => x.length > 0),
    (0, import_rxjs9.share)()
  );
  const unpinFromPrunned$ = follow$.pipe(
    (0, import_rxjs9.filter)((e) => e.type === "finalized"),
    (0, import_rxjs9.map)((e) => e.prunedBlockHashes)
  );
  (0, import_rxjs9.merge)(unpinFromUsage$, unpinFromPrunned$).pipe((0, import_rxjs9.filter)((x) => x.length > 0)).subscribe((hashes) => {
    unpin(hashes);
  });
  const onHold = (hash) => {
    userUsageInput$.next({ type: "hold", hash });
  };
  const onRelease = (hash) => {
    setTimeout(() => {
      userUsageInput$.next({ type: "release", hash });
    }, 0);
  };
  const withUnpinning$ = (fn) => (hash, ...args) => {
    const base$ = fn(hash, ...args);
    return new import_rxjs9.Observable((observer) => {
      onHold(hash);
      const subscription = base$.subscribe(observer);
      return () => {
        subscription.unsubscribe();
        onRelease(hash);
      };
    });
  };
  return { withUnpinning$, unpinFromUsage$ };
};

// src/observableClient/chainHead/enhancers/optionalHash.ts
var import_rxjs10 = require("rxjs");
var DONE = Symbol("DONE");
var delayUnsubscription = (source$) => new import_rxjs10.Observable((observer) => {
  const subscription = source$.subscribe(observer);
  return () => {
    setTimeout(() => {
      subscription.unsubscribe();
    }, 0);
  };
});
var getWithOptionalhash$ = (finalized$) => {
  const current$ = finalized$.pipe(
    (0, import_rxjs10.take)(1),
    withoutComplete,
    (0, import_rxjs10.share)({
      connector: () => new import_rxjs10.ReplaySubject(1),
      resetOnError: true,
      resetOnRefCountZero: true,
      resetOnComplete: false
    }),
    delayUnsubscription
  );
  return (fn) => (hash, ...args) => hash ? fn(hash, ...args) : current$.pipe(
    (0, import_rxjs10.mergeMap)((h) => (0, import_rxjs10.concat)(fn(h, ...args), (0, import_rxjs10.of)(DONE))),
    (0, import_rxjs10.takeWhile)((x) => x !== DONE)
  );
};

// src/observableClient/chainHead/enhancers/fromAbortControllerFn.ts
var import_rxjs11 = require("rxjs");
var fromAbortControllerFn = (fn) => (...args) => new import_rxjs11.Observable((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value) => {
      observer.next(value);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

// src/observableClient/chainHead/enhancers/lazyFollower.ts
var withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

// src/observableClient/chainHead/enhancers/operationInaccessibleRecovery.ts
var import_substrate_client2 = require("@polkadot-api/substrate-client");
var import_rxjs12 = require("rxjs");
var operable = (source$) => {
  const result = source$.pipe(
    (0, import_rxjs12.catchError)(
      (e) => e instanceof import_substrate_client2.OperationInaccessibleError ? (0, import_rxjs12.timer)(750).pipe((0, import_rxjs12.concatMap)(() => result)) : (0, import_rxjs12.throwError)(() => e)
    )
  );
  return result;
};
var withOperationInaccessibleRecovery = (fn) => (...args) => operable(fn(...args));

// src/observableClient/chainHead/streams/runtime.ts
var import_rxjs13 = require("rxjs");
var getRuntime$ = (follow$) => {
  const shared = follow$.pipe(
    (0, import_rxjs13.scan)(
      (acc, event) => {
        if (event.type === "initialized") {
          acc.candidates.clear();
          acc.current = event.finalizedBlockRuntime;
        }
        if (event.type === "newBlock" && event.newRuntime)
          acc.candidates.set(event.blockHash, event.newRuntime);
        if (event.type !== "finalized")
          return acc;
        const [newRuntimeHash] = event.finalizedBlockHashes.filter((h) => acc.candidates.has(h)).slice(-1);
        if (newRuntimeHash)
          acc.current = acc.candidates.get(newRuntimeHash);
        acc.candidates.clear();
        return acc;
      },
      {
        candidates: /* @__PURE__ */ new Map(),
        current: {}
      }
    ),
    shareLatest
  );
  const candidates$ = shared.pipe((0, import_rxjs13.map)((x) => x.candidates));
  const runtime$ = shared.pipe(
    (0, import_rxjs13.map)((x) => x.current),
    (0, import_rxjs13.distinctUntilChanged)(),
    shareLatest
  );
  return { runtime$, candidates$ };
};

// src/observableClient/chainHead/streams/follow.ts
var import_rxjs14 = require("rxjs");
var getFollow$ = (chainHead) => {
  let follower;
  let unfollow = import_rxjs14.noop;
  const follow$ = new import_rxjs14.Observable((observer) => {
    follower = chainHead(
      true,
      (e) => {
        observer.next(e);
      },
      (e) => {
        console.warn("chainHead crashed");
        console.error(e);
        observer.error(e);
      }
    );
    unfollow = () => {
      observer.complete();
      follower.unfollow();
    };
  }).pipe((0, import_rxjs14.share)());
  return {
    getFollower: () => {
      if (!follower)
        throw new Error("Missing chainHead subscription");
      return follower;
    },
    unfollow: () => {
      unfollow();
    },
    follow$
  };
};

// src/observableClient/chainHead/streams/finalized.ts
var import_rxjs15 = require("rxjs");
var getFinalized$ = (follow$) => follow$.pipe(
  (0, import_rxjs15.mergeMap)((e) => {
    if (e.type === "finalized")
      return e.finalizedBlockHashes;
    if (e.type !== "initialized")
      return [];
    return [e.finalizedBlockHash];
  }),
  shareLatest
);

// src/observableClient/chainHead/streams/metadata$.ts
var import_substrate_bindings = require("@polkadot-api/substrate-bindings");
var import_rxjs16 = require("rxjs");
var opaqueMeta = (0, import_substrate_bindings.Tuple)(import_substrate_bindings.compact, import_substrate_bindings.metadata);
var getMetadata$ = (call$, runtime$, finalized$) => {
  const _getMetadata$ = ([, hash]) => call$(hash, "Metadata_metadata", "").pipe(
    (0, import_rxjs16.map)((response) => {
      const metadata2 = opaqueMeta.dec(response)[1];
      if (metadata2.metadata.tag !== "v14")
        throw new Error("Wrong metadata version");
      return metadata2.metadata.value;
    }),
    (0, import_rxjs16.startWith)(null)
  );
  return runtime$.pipe(
    (0, import_rxjs16.withLatestFrom)(finalized$),
    switchMapComplete(_getMetadata$),
    shareLatest
  );
};

// src/observableClient/chainHead/chainHead.ts
var import_rxjs19 = require("rxjs");
var import_metadata_builders = require("@polkadot-api/metadata-builders");
var import_substrate_bindings2 = require("@polkadot-api/substrate-bindings");

// src/observableClient/chainHead/streams/best-block.ts
var import_rxjs17 = require("rxjs");
var import_rxjs18 = require("rxjs");
var getBestBlock$ = (follow$) => follow$.pipe(
  (0, import_rxjs18.filter)((e) => e.type === "bestBlockChanged"),
  (0, import_rxjs18.map)((e) => e.bestBlockHash),
  shareLatest
);
var getBestBlocks$ = (best$, finalized$, getHeader$) => {
  const _current$ = new import_rxjs17.Subject();
  const getBlocks$ = (best, finalized, current) => new import_rxjs17.Observable((observer) => {
    const result = /* @__PURE__ */ new Map();
    let sub;
    const process = (hash) => {
      if (hash === finalized) {
        observer.next(result);
        observer.complete();
        return;
      }
      const header = current.get(hash);
      if (header) {
        result.set(hash, header);
        process(header.parentHash);
        return;
      }
      sub = getHeader$(hash).subscribe({
        next(header2) {
          result.set(hash, header2);
          process(header2.parentHash);
        },
        error(e) {
          observer.error(e);
        }
      });
    };
    process(best);
    return () => {
      sub?.unsubscribe();
    };
  });
  return (0, import_rxjs18.combineLatest)({ best: best$, finalized: finalized$ }).pipe(
    (0, import_rxjs17.withLatestFrom)(_current$.pipe((0, import_rxjs17.startWith)(/* @__PURE__ */ new Map()))),
    (0, import_rxjs17.concatMap)(
      ([{ best, finalized }, current]) => getBlocks$(best, finalized, current).pipe(
        (0, import_rxjs17.tap)((x) => {
          _current$.next(x);
        }),
        (0, import_rxjs18.map)((state) => {
          const result = [];
          let hash = best;
          while (hash !== finalized) {
            const header = state.get(hash);
            result.push({ hash, header });
            hash = header.parentHash;
          }
          return result;
        })
      )
    ),
    shareLatest
  );
};

// src/observableClient/chainHead/chainHead.ts
var chainHead_default = (chainHead) => () => {
  const { getFollower, unfollow, follow$ } = getFollow$(chainHead);
  const lazyFollower = withLazyFollower(getFollower);
  const { runtime$, candidates$: runtimeCandidates$ } = getRuntime$(follow$);
  const _finalized$ = getFinalized$(follow$);
  const bestBlock$ = getBestBlock$(follow$);
  const { withUnpinning$, unpinFromUsage$ } = getWithUnpinning$(
    _finalized$,
    follow$,
    lazyFollower("unpin")
  );
  const withOptionalHash$ = getWithOptionalhash$(_finalized$);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const commonEnhancer = (fn) => withOptionalHash$(withUnpinning$(withRecoveryFn(fromAbortControllerFn(fn))));
  const call$ = commonEnhancer(lazyFollower("call"));
  const body$ = commonEnhancer(lazyFollower("body"));
  const storage$ = withOperationInaccessibleRecovery(
    commonEnhancer(lazyFollower("storage"))
  );
  const lazyHeader = lazyFollower("header");
  const header$ = (0, import_rxjs19.pipe)(
    withUnpinning$((hash) => (0, import_rxjs19.from)(lazyHeader(hash))),
    (0, import_rxjs19.map)(import_substrate_bindings2.blockHeader.dec)
  );
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new import_rxjs19.Observable(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        observer.next(
          recoveralStorage$(
            hash,
            queries.slice(-nDiscarded),
            childTrie,
            true
          )
        );
      }
    )
  ).pipe((0, import_rxjs19.mergeAll)(), withRecovery(isHighPriority));
  const storageQueries$ = withOperationInaccessibleRecovery(
    withOptionalHash$(
      withUnpinning$(
        (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false)
      )
    )
  );
  const metadata$ = getMetadata$(call$, runtime$, _finalized$);
  const runtimeContext$ = runtime$.pipe(
    (0, import_rxjs19.map)(() => {
      const result = metadata$.pipe(
        (0, import_rxjs19.filter)(Boolean),
        (0, import_rxjs19.map)((metadata2) => {
          const checksumBuilder = (0, import_metadata_builders.getChecksumBuilder)(metadata2);
          const dynamicBuilder = (0, import_metadata_builders.getDynamicBuilder)(metadata2);
          const events = dynamicBuilder.buildStorage("System", "Events");
          return {
            checksumBuilder,
            dynamicBuilder,
            events: {
              key: events.enc(),
              dec: events.dec
            },
            accountId: (0, import_substrate_bindings2.AccountId)(dynamicBuilder.ss58Prefix)
          };
        }),
        (0, import_rxjs19.take)(1),
        (0, import_rxjs19.shareReplay)(1)
      );
      result.subscribe();
      return result;
    }),
    shareLatest
  );
  metadata$.subscribe();
  const currentFinalized$ = new import_rxjs19.Observable((observer) => {
    let latestRuntimeCtx;
    const toRemove = /* @__PURE__ */ new Set();
    const result = {};
    const sub1 = runtimeContext$.subscribe({
      next(v) {
        latestRuntimeCtx = v;
      },
      error(e) {
        observer.error(e);
      }
    });
    const sub2 = unpinFromUsage$.subscribe({
      next(v) {
        v.forEach((x) => {
          if (result[x])
            delete result[x];
          else
            toRemove.add(x);
        });
      },
      error(e) {
        observer.error(e);
      }
    });
    const sub3 = _finalized$.pipe((0, import_rxjs19.observeOn)(import_rxjs19.asapScheduler)).subscribe({
      next(v) {
        if (toRemove.has(v))
          toRemove.delete(v);
        else
          result[v] = latestRuntimeCtx;
        observer.next(result);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    return () => {
      sub3.unsubscribe();
      sub2.unsubscribe();
      sub1.unsubscribe();
    };
  }).pipe(
    (0, import_rxjs19.map)((x) => ({ ...x })),
    shareLatest
  );
  const getRuntimeContext$ = withOptionalHash$(
    (hash) => currentFinalized$.pipe(
      (0, import_rxjs19.withLatestFrom)(runtimeCandidates$),
      (0, import_rxjs19.take)(1),
      (0, import_rxjs19.mergeMap)(
        ([x, runtimeCandidates]) => x[hash] ?? (runtimeCandidates.has(hash) ? import_rxjs19.EMPTY : Object.values(x).slice(-1)[0])
      )
    )
  );
  currentFinalized$.subscribe();
  const bestBlocks$ = getBestBlocks$(bestBlock$, _finalized$, header$);
  const finalizedHeader$ = _finalized$.pipe(
    concatMapEager(
      (hash) => header$(hash).pipe((0, import_rxjs19.map)((header) => ({ hash, header })))
    ),
    shareLatest
  );
  finalizedHeader$.subscribe();
  const finalized$ = finalizedHeader$.pipe((0, import_rxjs19.map)((x) => x.hash));
  return {
    finalized$,
    finalizedHeader$,
    bestBlock$,
    bestBlocks$,
    follow$,
    runtime$,
    metadata$,
    body$,
    call$,
    storage$,
    storageQueries$,
    unfollow,
    getRuntimeContext$
  };
};

// src/observableClient/tx.ts
var import_rxjs20 = require("rxjs");
var terminalTxEvents = /* @__PURE__ */ new Set(["error", "finalized", "invalid", "dropped"]);
var tx_default = (baseTransaction) => (transaction) => new import_rxjs20.Observable(
  (observer) => baseTransaction(
    transaction,
    (event) => {
      if (event.type === "error")
        return observer.error(new Error(event.error));
      observer.next(event);
      if (terminalTxEvents.has(event.type))
        observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  )
);

// src/observableClient/getObservableClient.ts
var getObservableClient = ({
  chainHead,
  transaction,
  destroy
}) => ({
  chainHead$: chainHead_default(chainHead),
  tx$: tx_default(transaction),
  destroy
});

// src/tx.ts
var import_rxjs21 = require("rxjs");
var import_utils9 = require("@polkadot-api/utils");
var getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.tag === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => x.event);
  const lastEvent = events[events.length - 1];
  const ok = lastEvent.tag === "System" && lastEvent.value.tag === "ExtrinsicSuccess";
  return { ok, events };
};
var createTxEntry = (descriptor, pallet, name, getRuntimeContext$, client, storage$, signer) => {
  const getCallDataAndEventDec$ = (...decodedArgs) => getRuntimeContext$(null).pipe(
    (0, import_rxjs21.map)(({ events, checksumBuilder, dynamicBuilder }) => {
      const checksum = checksumBuilder.buildCall(pallet, name);
      if (checksum !== descriptor)
        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
      const { location, args } = dynamicBuilder.buildCall(pallet, name);
      return {
        callData: (0, import_utils9.mergeUint8)(new Uint8Array(location), args.enc(decodedArgs)),
        events
      };
    })
  );
  const getCallData = (...args) => (0, import_rxjs21.firstValueFrom)(getCallDataAndEventDec$(...args)).then(
    (x) => (0, import_utils9.toHex)(x.callData)
  );
  const getTx = (from2, ...args) => (0, import_rxjs21.firstValueFrom)(
    getCallDataAndEventDec$(...args).pipe(
      (0, import_rxjs21.mergeMap)(({ callData }) => signer(from2, callData)),
      (0, import_rxjs21.map)(import_utils9.toHex)
    )
  );
  const submit = async (from2, ...args) => {
    const [tx, { key, dec }] = await (0, import_rxjs21.firstValueFrom)(
      getCallDataAndEventDec$(...args).pipe(
        (0, import_rxjs21.mergeMap)(
          ({ callData, events }) => signer(from2, callData).then((result2) => ({
            result: result2,
            events
          }))
        ),
        (0, import_rxjs21.map)((x) => [(0, import_utils9.toHex)(x.result), x.events])
      )
    );
    const result = await (0, import_rxjs21.lastValueFrom)(client.tx$(tx));
    switch (result.type) {
      case "invalid":
        throw new Error("Invalid");
      case "dropped":
        throw new Error("Dropped");
      case "finalized": {
        const systemEvents = await (0, import_rxjs21.firstValueFrom)(
          storage$(result.block.hash, "value", key, null).pipe(
            (0, import_rxjs21.map)((x) => dec(x))
          )
        );
        return getTxSuccessFromSystemEvents(
          systemEvents,
          Number(result.block.index)
        );
      }
      default:
        return { ok: true, events: [] };
    }
  };
  const submit$ = (from2, ...args) => getCallDataAndEventDec$(...args).pipe(
    (0, import_rxjs21.mergeMap)(
      ({ callData, events }) => signer(from2, callData).then((result) => ({
        result,
        events
      }))
    ),
    (0, import_rxjs21.take)(1),
    (0, import_rxjs21.mergeMap)(({ result, events: { key, dec } }) => {
      return client.tx$((0, import_utils9.toHex)(result)).pipe(
        (0, import_rxjs21.mergeMap)((result2) => {
          switch (result2.type) {
            case "invalid":
              throw new Error("Invalid");
            case "dropped":
              throw new Error("Dropped");
            case "finalized": {
              return storage$(result2.block.hash, "value", key, null).pipe(
                (0, import_rxjs21.map)((x) => dec(x)),
                (0, import_rxjs21.map)((events) => ({
                  ...result2,
                  ...getTxSuccessFromSystemEvents(
                    events,
                    Number(result2.block.index)
                  )
                }))
              );
            }
            default:
              return (0, import_rxjs21.of)(result2);
          }
        })
      );
    })
  );
  return { getCallData, getTx, submit, submit$ };
};

// src/client.ts
var import_rxjs23 = require("rxjs");

// src/event.ts
var import_rxjs22 = require("rxjs");
var createEventEntry = (checksum, pallet, name, getRuntimeContext$, finalized, storage$) => {
  const shared$ = finalized.pipe(
    concatMapEager(
      (block) => getRuntimeContext$(block).pipe((0, import_rxjs22.map)((context) => ({ context, block })))
    ),
    concatMapEager(
      ({
        block,
        context: {
          events: { key, dec },
          checksumBuilder
        }
      }) => {
        const actualChecksum = checksumBuilder.buildEvent(pallet, name);
        if (checksum !== actualChecksum)
          throw new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
        return storage$(block, "value", key, null).pipe(
          (0, import_rxjs22.map)((x) => {
            const events = dec(x);
            const winners = events.filter(
              (e) => e.event.tag === pallet && e.event.value.tag === name
            );
            return winners.map((x2) => {
              return {
                meta: {
                  phase: x2.phase,
                  blockHash: block
                },
                payload: x2.event.value.value
              };
            });
          })
        );
      }
    ),
    shareLatest
  );
  const watch = (f) => shared$.pipe((0, import_rxjs22.mergeMap)((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => (0, import_rxjs22.firstValueFrom)(shared$);
  const filter4 = (events) => events.filter((e) => e.tag === pallet && e.value.tag === name).map((x) => x.value.value);
  return { watch, pull, filter: filter4 };
};

// src/client.ts
var import_utils11 = require("@polkadot-api/utils");
var createNamespace = (descriptors, createTxFromAddress, chainHead, client) => {
  const query = {};
  for (const pallet in descriptors) {
    query[pallet] || (query[pallet] = {});
    const [stgEntries] = descriptors[pallet];
    for (const name in stgEntries) {
      query[pallet][name] = createStorageEntry(
        stgEntries[name],
        pallet,
        name,
        chainHead.getRuntimeContext$,
        chainHead.storage$,
        chainHead.finalized$
      );
    }
  }
  const tx = {};
  for (const pallet in descriptors) {
    tx[pallet] || (tx[pallet] = {});
    const [, txEntries] = descriptors[pallet];
    for (const name in txEntries) {
      tx[pallet][name] = createTxEntry(
        txEntries[name],
        pallet,
        name,
        chainHead.getRuntimeContext$,
        client,
        chainHead.storage$,
        createTxFromAddress
      );
    }
  }
  const events = {};
  for (const pallet in descriptors) {
    events[pallet] || (events[pallet] = {});
    const [, , evEntries] = descriptors[pallet];
    for (const name in evEntries) {
      events[pallet][name] = createEventEntry(
        evEntries[name],
        pallet,
        name,
        chainHead.getRuntimeContext$,
        chainHead.finalized$,
        chainHead.storage$
      );
    }
  }
  return {
    query,
    tx,
    event: events
  };
};
var createClient = (connect, descriptors) => {
  let createTx;
  const rawClient = (0, import_substrate_client3.createClient)((onMsg) => {
    const result = connect(onMsg);
    createTx = result.createTx;
    return result;
  });
  const client = getObservableClient(rawClient);
  const chainHead = client.chainHead$();
  const createTxFromAddress = async (address, callData) => {
    const { accountId } = await (0, import_rxjs23.firstValueFrom)(
      chainHead.getRuntimeContext$(null)
    );
    return createTx(accountId.enc(address), callData);
  };
  return {
    finalized$: chainHead.finalized$,
    bestBlock$: chainHead.bestBlock$,
    bestBlocks$: chainHead.bestBlocks$,
    ...(0, import_utils11.mapObject)(
      descriptors,
      (des) => createNamespace(des, createTxFromAddress, chainHead, client)
    )
  };
};
//# sourceMappingURL=index.js.map