var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/internal-utils/abortablePromiseFn.ts
var AbortError = class extends Error {
  constructor() {
    super("Aborted by AbortSignal");
    this.name = "AbortError";
  }
};
var abortablePromiseFn = (fn) => (...args) => new Promise((res, rej) => {
  const [actualArgs, abortSignal] = args[args.length - 1] instanceof AbortSignal ? [args.slice(0, args.length - 1), args[args.length - 1]] : [args];
  const onAbort = () => {
    cancel();
    rej(new AbortError());
  };
  abortSignal?.addEventListener("abort", onAbort, { once: true });
  const removeAbortListener = (fn2) => (x) => {
    abortSignal?.removeEventListener("abort", onAbort);
    fn2(x);
  };
  const cancel = fn(
    ...[removeAbortListener(res), removeAbortListener(rej), ...actualArgs]
  );
});

// src/internal-utils/deferred-promise.ts
function deferred() {
  let res = () => {
  };
  let rej = () => {
  };
  const promise = new Promise((_res, _rej) => {
    res = _res;
    rej = _rej;
  });
  return { promise, res, rej };
}

// src/internal-utils/noop.ts
var noop = () => {
};

// src/internal-utils/subscriptions-manager.ts
var getSubscriptionsManager = () => {
  const subscriptions = /* @__PURE__ */ new Map();
  return {
    has: subscriptions.has.bind(subscriptions),
    subscribe(id, subscriber) {
      subscriptions.set(id, subscriber);
    },
    unsubscribe(id) {
      subscriptions.delete(id);
    },
    next(id, data) {
      subscriptions.get(id)?.next(data);
    },
    error(id, e) {
      const subscriber = subscriptions.get(id);
      if (subscriber) {
        subscriptions.delete(id);
        subscriber.error(e);
      }
    },
    errorAll(e) {
      const subscribers = [...subscriptions.values()];
      subscriptions.clear();
      subscribers.forEach((s) => {
        s.error(e);
      });
    }
  };
};

// src/transaction/transaction.ts
var eventToType = (input) => {
  const { event: type, ...rest } = input;
  return { type, ...rest };
};
var terminalEvents = /* @__PURE__ */ new Set([
  "dropped",
  "invalid",
  "finalized",
  "error"
]);
function isTerminalEvent(event) {
  return terminalEvents.has(event.event);
}
var TransactionError = class extends Error {
  constructor(e) {
    super(`TxError: ${e.event} - ${e.error}`);
    __publicField(this, "type");
    __publicField(this, "error");
    this.type = e.event;
    this.error = e.error;
    this.name = "TransactionError";
  }
};
var getTransaction = (request) => (tx, next, error) => {
  let cancel = request("transaction_unstable_submitAndWatch", [tx], {
    onSuccess: (subscriptionId, follow) => {
      const done = follow(subscriptionId, {
        next: (event) => {
          if (isTerminalEvent(event)) {
            done();
            cancel = noop;
            if (event.event !== "finalized")
              return error(new TransactionError(event));
          }
          next(eventToType(event));
        },
        error(e) {
          cancel();
          cancel = noop;
          error(e);
        }
      });
      cancel = () => {
        done();
        request("transaction_unstable_unwatch", [subscriptionId]);
      };
    },
    onError: error
  });
  return () => {
    cancel();
  };
};

// src/chainhead/errors.ts
var StopError = class extends Error {
  constructor() {
    super("ChainHead stopped");
    this.name = "StopError";
  }
};
var DisjointError = class extends Error {
  constructor() {
    super("ChainHead disjointed");
    this.name = "DisjointError";
  }
};
var OperationLimitError = class extends Error {
  constructor() {
    super("ChainHead operations limit reached");
    this.name = "OperationLimitError";
  }
};
var OperationError = class extends Error {
  constructor(error) {
    super(error);
    this.name = "OperationError";
  }
};
var OperationInaccessibleError = class extends Error {
  constructor() {
    super("ChainHead operation inaccessible");
    this.name = "OperationInaccessibleError";
  }
};

// src/chainhead/operation-promise.ts
var createOperationPromise = (operationName, factory) => (request) => abortablePromiseFn((res, rej, ...args) => {
  const [requestArgs, logicCb] = factory(...args);
  let cancel = request(operationName, requestArgs, {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached") {
        cancel = noop;
        return rej(new OperationLimitError());
      }
      let isOperationGoing = true;
      let done = noop;
      const _res = (x) => {
        isOperationGoing = false;
        done();
        res(x);
      };
      const _rej = (x) => {
        isOperationGoing = false;
        done();
        rej(x);
      };
      done = followSubscription(response.operationId, {
        next: (e) => {
          const _e = e;
          if (_e.event === "operationError") {
            rej(new OperationError(_e.error));
          } else if (_e.event === "operationInaccessible") {
            rej(new OperationInaccessibleError());
          } else {
            logicCb(e, _res, _rej);
          }
        },
        error: _rej
      });
      cancel = () => {
        if (!isOperationGoing)
          return;
        done();
        request("chainHead_unstable_stopOperation", [response.operationId]);
      };
    },
    onError: rej
  });
  return () => {
    cancel();
  };
});

// src/chainhead/body.ts
var createBodyFn = createOperationPromise(
  "chainHead_unstable_body",
  (hash) => [
    [hash],
    (e, res) => {
      res(e.value);
    }
  ]
);

// src/chainhead/call.ts
var createCallFn = createOperationPromise(
  "chainHead_unstable_call",
  (hash, fnName, callParameters) => [
    [hash, fnName, callParameters],
    (e, res) => {
      res(e.output);
    }
  ]
);

// src/chainhead/header.ts
var createHeaderFn = (request) => (hash) => new Promise((res, rej) => {
  request("chainHead_unstable_header", [hash], {
    onSuccess: res,
    onError: rej
  });
});

// src/chainhead/storage-subscription.ts
import { noop as noop2 } from "@polkadot-api/utils";
var createStorageCb = (request) => (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {
  if (inputs.length === 0) {
    onDone();
    return noop2;
  }
  let cancel = request(
    "chainHead_unstable_storage",
    [hash, inputs, childTrie],
    {
      onSuccess: (response, followSubscription) => {
        if (response.result === "limitReached" || response.discardedItems === inputs.length)
          return onError(new OperationLimitError());
        const doneListening = followSubscription(response.operationId, {
          next: (event) => {
            switch (event.event) {
              case "operationStorageItems": {
                onItems(event.items);
                break;
              }
              case "operationStorageDone": {
                _onDone();
                break;
              }
              case "operationError": {
                _onError(new OperationError(event.error));
                break;
              }
              case "operationInaccessible": {
                _onError(new OperationInaccessibleError());
                break;
              }
              default:
                request("chainHead_unstable_continue", []);
            }
          },
          error: onError
        });
        cancel = () => {
          doneListening();
          request("chainHead_unstable_stopOperation", [response.operationId]);
        };
        const _onError = (e) => {
          cancel = noop2;
          doneListening();
          onError(e);
        };
        const _onDone = () => {
          cancel = noop2;
          doneListening();
          onDone();
        };
        onDiscardedItems(response.discardedItems);
      },
      onError
    }
  );
  return () => {
    cancel();
  };
};

// src/chainhead/storage.ts
var createStorageFn = (request) => {
  const cbStore = createStorageCb(request);
  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {
    const isDescendants = type.startsWith("descendants");
    let result = isDescendants ? [] : null;
    const onItems = isDescendants ? (items) => {
      result.push(...items);
    } : (items) => {
      result = items[0]?.[type];
    };
    const cancel = cbStore(
      hash,
      [{ key, type }],
      childTrie ?? null,
      onItems,
      reject,
      () => {
        resolve(result);
      },
      (nDiscarded) => {
        if (nDiscarded > 0) {
          cancel();
          reject(new OperationLimitError());
        }
      }
    );
    return cancel;
  });
};

// src/chainhead/unpin.ts
var createUnpinFn = (request) => (hashes) => new Promise((res, rej) => {
  request("chainHead_unstable_unpin", [hashes], {
    onSuccess() {
      res();
    },
    onError: rej
  });
});

// src/chainhead/chainhead.ts
function isOperationEvent(event) {
  return event.operationId !== void 0;
}
function getChainHead(request) {
  return (withRuntime, onFollowEvent, onFollowError) => {
    const subscriptions = getSubscriptionsManager();
    const ongoingRequests = /* @__PURE__ */ new Set();
    const deferredFollow = deferred();
    let followSubscription = deferredFollow.promise;
    const onAllFollowEventsNext = (event) => {
      if (isOperationEvent(event))
        return subscriptions.next(event.operationId, event);
      if (event.event !== "stop") {
        const { event: type, ...rest } = event;
        return onFollowEvent({ type, ...rest });
      }
      onFollowError(new StopError());
      unfollow(false);
    };
    const onAllFollowEventsError = (error) => {
      onFollowError(error);
      unfollow();
    };
    const onFollowRequestSuccess = (subscriptionId, follow) => {
      const done = follow(subscriptionId, {
        next: onAllFollowEventsNext,
        error: onAllFollowEventsError
      });
      unfollow = (sendUnfollow = true) => {
        followSubscription = null;
        unfollow = noop;
        done();
        sendUnfollow && request("chainHead_unstable_unfollow", [subscriptionId]);
        subscriptions.errorAll(new DisjointError());
        ongoingRequests.forEach((cb) => {
          cb();
        });
        ongoingRequests.clear();
      };
      followSubscription = subscriptionId;
      deferredFollow.res(subscriptionId);
    };
    const onFollowRequestError = (e) => {
      onFollowError(e);
      followSubscription = null;
      deferredFollow.res(e);
    };
    let unfollow = request(
      "chainHead_unstable_follow",
      [withRuntime],
      { onSuccess: onFollowRequestSuccess, onError: onFollowRequestError }
    );
    const fRequest = (method, params, cb) => {
      const disjoint = () => {
        cb?.onError(new DisjointError());
      };
      if (followSubscription === null) {
        disjoint();
        return noop;
      }
      const onSubscription = (subscription) => {
        if (!cb)
          return request(method, [subscription, ...params]);
        ongoingRequests.add(disjoint);
        const onSubscribeOperation = (operationId, subscriber) => {
          if (followSubscription === null) {
            subscriber.error(new DisjointError());
            return noop;
          }
          subscriptions.subscribe(operationId, subscriber);
          return () => {
            subscriptions.unsubscribe(operationId);
          };
        };
        const cleanup = request(method, [subscription, ...params], {
          onSuccess: (response) => {
            ongoingRequests.delete(disjoint);
            cb.onSuccess(response, onSubscribeOperation);
          },
          onError: (e) => {
            ongoingRequests.delete(disjoint);
            cb.onError(e);
          }
        });
        return () => {
          ongoingRequests.delete(disjoint);
          cleanup();
        };
      };
      if (typeof followSubscription === "string")
        return onSubscription(followSubscription);
      let onCancel = noop;
      followSubscription.then((x) => {
        if (x instanceof Error)
          return disjoint();
        if (followSubscription)
          onCancel = onSubscription(x);
      });
      return () => {
        onCancel();
      };
    };
    return {
      unfollow() {
        unfollow();
        followSubscription = null;
      },
      body: createBodyFn(fRequest),
      call: createCallFn(fRequest),
      header: createHeaderFn(fRequest),
      storage: createStorageFn(fRequest),
      storageSubscription: createStorageCb(fRequest),
      unpin: createUnpinFn(fRequest),
      _request: fRequest
    };
  };
}

// src/client/RpcError.ts
var RpcError = class extends Error {
  constructor(e) {
    super(e.message);
    __publicField(this, "code");
    __publicField(this, "data");
    this.code = e.code;
    this.data = e.data;
    this.name = "RpcError";
  }
};

// src/client/createClient.ts
var createClient = (gProvider) => {
  const responses = /* @__PURE__ */ new Map();
  const subscriptions = getSubscriptionsManager();
  let provider = null;
  const send = (id, method, params) => {
    provider.send(
      JSON.stringify({
        jsonrpc: "2.0",
        id,
        method,
        params
      })
    );
  };
  function onMessage(message) {
    try {
      let id, result, error, params, subscription;
      ({ id, result, error, params } = JSON.parse(message));
      if (id) {
        const cb = responses.get(id);
        if (!cb)
          return;
        responses.delete(id);
        return error ? cb.onError(new RpcError(error)) : cb.onSuccess(result, (subscriptionId, subscriber) => {
          subscriptions.subscribe(subscriptionId, subscriber);
          return () => {
            subscriptions.unsubscribe(subscriptionId);
          };
        });
      }
      ;
      ({ subscription, result, error } = params);
      if (!subscription || !error && !Object.hasOwn(params, "result"))
        throw 0;
      if (error) {
        subscriptions.error(subscription, new RpcError(error));
      } else {
        subscriptions.next(subscription, result);
      }
    } catch (e) {
      console.warn("Error parsing incomming message: " + message);
      console.error(e);
    }
  }
  provider = gProvider(onMessage);
  const disconnect = () => {
    provider?.disconnect();
    provider = null;
  };
  let nextId = 1;
  const request = (method, params, cb) => {
    if (!provider)
      throw new Error("Not connected");
    const id = nextId++;
    if (cb)
      responses.set(id, cb);
    send(id, method, params);
    return () => {
      responses.delete(id);
    };
  };
  return {
    request,
    disconnect
  };
};

// src/index.ts
var createClient2 = (provider) => {
  const client = createClient(provider);
  return {
    chainHead: getChainHead(client.request),
    transaction: getTransaction(client.request),
    destroy: () => {
      client.disconnect();
    },
    _request: client.request
  };
};
export {
  DisjointError,
  OperationError,
  OperationInaccessibleError,
  OperationLimitError,
  RpcError,
  StopError,
  TransactionError,
  createClient2 as createClient
};
//# sourceMappingURL=index.mjs.map