"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AccountId: () => AccountId,
  Blake2128: () => Blake2128,
  Blake2128Concat: () => Blake2128Concat,
  Blake2256: () => Blake2256,
  Hex: () => Hex,
  Identity: () => Identity,
  OpaqueCodec: () => OpaqueCodec,
  Self: () => Self,
  Storage: () => Storage,
  Twox128: () => Twox128,
  Twox256: () => Twox256,
  Twox64Concat: () => Twox64Concat,
  bitSequence: () => bitSequence2,
  blockHeader: () => blockHeader,
  char: () => char,
  compactBn: () => compactBn,
  compactNumber: () => compactNumber,
  fixedStr: () => fixedStr,
  h64: () => h64,
  metadata: () => metadata,
  selfDecoder: () => selfDecoder,
  selfEncoder: () => selfEncoder,
  v14: () => v14
});
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, require("scale-ts"), module.exports);

// src/codecs/index.ts
var codecs_exports = {};
__export(codecs_exports, {
  AccountId: () => AccountId,
  Hex: () => Hex,
  OpaqueCodec: () => OpaqueCodec,
  Self: () => Self,
  bitSequence: () => bitSequence2,
  blockHeader: () => blockHeader,
  char: () => char,
  compactBn: () => compactBn,
  compactNumber: () => compactNumber,
  fixedStr: () => fixedStr,
  metadata: () => metadata,
  selfDecoder: () => selfDecoder,
  selfEncoder: () => selfEncoder,
  v14: () => v14
});
__reExport(codecs_exports, require("scale-ts"));

// src/codecs/AccountId.ts
var import_scale_ts = require("scale-ts");
var import_blake2b = require("@noble/hashes/blake2b");
var import_base = require("@scure/base");
var SS58_PREFIX = new TextEncoder().encode("SS58PRE");
var CHECKSUM_LENGTH = 2;
var fromBufferToBase58 = (ss58Format) => {
  const prefixBytes = ss58Format < 64 ? Uint8Array.of(ss58Format) : Uint8Array.of(
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  );
  return (publicKey) => {
    const checksum = (0, import_blake2b.blake2b)(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    return import_base.base58.encode(
      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum)
    );
  };
};
function fromBase58ToBuffer(nBytes, ss58Format) {
  return (address) => {
    const decoded = import_base.base58.decode(address);
    const prefixBytes = decoded.subarray(0, decoded[0] & 64 ? 2 : 1);
    const publicKey = decoded.subarray(
      prefixBytes.length,
      decoded.length - CHECKSUM_LENGTH
    );
    if (publicKey.length !== nBytes)
      throw new Error("Invalid public key length");
    const checksum = decoded.subarray(prefixBytes.length + publicKey.length);
    const expectedChecksum = (0, import_blake2b.blake2b)(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    if (checksum[0] !== expectedChecksum[0] || checksum[1] !== expectedChecksum[1])
      throw new Error("Invalid checksum");
    if (prefixBytesToNumber(prefixBytes) != ss58Format)
      throw new Error("Invalid SS58 prefix");
    return publicKey.slice();
  };
}
var AccountId = (ss58Format = 42, nBytes = 32) => (0, import_scale_ts.enhanceCodec)(
  (0, import_scale_ts.Bytes)(nBytes),
  fromBase58ToBuffer(nBytes, ss58Format),
  fromBufferToBase58(ss58Format)
);
var prefixBytesToNumber = (bytes) => {
  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0);
};

// src/codecs/compact.ts
var import_scale_ts2 = require("scale-ts");
var compactNumber = import_scale_ts2.compact;
var compactBn = import_scale_ts2.compact;

// src/codecs/Self.ts
var import_scale_ts3 = require("scale-ts");
var selfEncoder = (value) => {
  let cache = (x) => {
    const encoder = value();
    cache = encoder;
    return encoder(x);
  };
  return (x) => cache(x);
};
var selfDecoder = (value) => {
  let cache = (x) => {
    const decoder = value();
    const result = decoder;
    cache = decoder;
    return result(x);
  };
  return (x) => cache(x);
};
var Self = (value) => (0, import_scale_ts3.createCodec)(
  selfEncoder(() => value().enc),
  selfDecoder(() => value().dec)
);

// src/codecs/Opaque.ts
var import_scale_ts4 = require("scale-ts");
var OpaqueDecoder = (inner, len = compactNumber.dec) => (0, import_scale_ts4.createDecoder)((bytes) => {
  const length = len(bytes);
  const innerBytes = (0, import_scale_ts4.Bytes)(length).dec(bytes);
  let _cachedValue;
  return {
    length,
    inner: () => _cachedValue = _cachedValue || inner(innerBytes)
  };
});
var OpaqueEncoder = (inner, len = compactNumber.enc) => (input) => {
  const lenBytes = len(input.length);
  const result = new Uint8Array(lenBytes.length + input.length);
  result.set(lenBytes, 0);
  result.set(inner(input.inner()), lenBytes.length);
  return result;
};
var OpaqueCodec = (inner, len = compactNumber) => (0, import_scale_ts4.createCodec)(
  OpaqueEncoder(inner.enc, len.enc),
  OpaqueDecoder(inner.dec, len.dec)
);
OpaqueCodec.enc = OpaqueEncoder;
OpaqueCodec.dec = OpaqueDecoder;

// src/codecs/metadata/v14/v14.ts
var import_scale_ts8 = require("scale-ts");

// src/codecs/metadata/v14/lookup.ts
var import_scale_ts5 = require("scale-ts");
var oStr = (0, import_scale_ts5.Option)(import_scale_ts5.str);
var strs = (0, import_scale_ts5.Vector)(import_scale_ts5.str);
var primitive = (0, import_scale_ts5.Enum)({
  bool: import_scale_ts5._void,
  char: import_scale_ts5._void,
  str: import_scale_ts5._void,
  u8: import_scale_ts5._void,
  u16: import_scale_ts5._void,
  u32: import_scale_ts5._void,
  u64: import_scale_ts5._void,
  u128: import_scale_ts5._void,
  u256: import_scale_ts5._void,
  i8: import_scale_ts5._void,
  i16: import_scale_ts5._void,
  i32: import_scale_ts5._void,
  i64: import_scale_ts5._void,
  i128: import_scale_ts5._void,
  i256: import_scale_ts5._void
});
var fields = (0, import_scale_ts5.Vector)(
  (0, import_scale_ts5.Struct)({
    name: oStr,
    type: compactNumber,
    typeName: oStr,
    docs: strs
  })
);
var arr = (0, import_scale_ts5.Struct)({
  len: import_scale_ts5.u32,
  type: compactNumber
});
var bitSequence = (0, import_scale_ts5.Struct)({
  bitStoreType: compactNumber,
  bitOrderType: compactNumber
});
var variant = (0, import_scale_ts5.Vector)(
  (0, import_scale_ts5.Struct)({
    name: import_scale_ts5.str,
    fields,
    index: import_scale_ts5.u8,
    docs: strs
  })
);
var def = (0, import_scale_ts5.Enum)({
  composite: fields,
  variant,
  sequence: compactNumber,
  array: arr,
  tuple: (0, import_scale_ts5.Vector)(compactNumber),
  primitive,
  compact: compactNumber,
  bitSequence,
  historicMetaCompat: import_scale_ts5.str
});
var param = (0, import_scale_ts5.Struct)({
  name: import_scale_ts5.str,
  type: (0, import_scale_ts5.Option)(compactNumber)
});
var params = (0, import_scale_ts5.Vector)(param);
var entry = (0, import_scale_ts5.Struct)({
  id: compactNumber,
  path: strs,
  params,
  def,
  docs: strs
});
var lookup = (0, import_scale_ts5.Vector)(entry);

// src/codecs/Hex.ts
var import_utils = require("@polkadot-api/utils");
var import_scale_ts6 = require("scale-ts");
var enc = (nBytes) => {
  const _enc = import_scale_ts6.Bytes.enc(nBytes);
  return (value) => _enc((0, import_utils.fromHex)(value));
};
var dec = (nBytes) => {
  const _dec = import_scale_ts6.Bytes.dec(nBytes);
  return (value) => (0, import_utils.toHex)(_dec(value));
};
var Hex = (nBytes) => (0, import_scale_ts6.createCodec)(enc(nBytes), dec(nBytes));
Hex.enc = enc;
Hex.dec = dec;

// src/codecs/metadata/v14/pallets.ts
var import_scale_ts7 = require("scale-ts");
var hashType = (0, import_scale_ts7.Enum)({
  Blake2128: import_scale_ts7._void,
  Blake2256: import_scale_ts7._void,
  Blake2128Concat: import_scale_ts7._void,
  Twox128: import_scale_ts7._void,
  Twox256: import_scale_ts7._void,
  Twox64Concat: import_scale_ts7._void,
  Identity: import_scale_ts7._void
});
var hashers = (0, import_scale_ts7.Vector)(hashType);
var storageMap = (0, import_scale_ts7.Struct)({
  hashers,
  key: compactNumber,
  value: compactNumber
});
var storageItem = (0, import_scale_ts7.Struct)({
  name: import_scale_ts7.str,
  modifier: import_scale_ts7.u8,
  type: (0, import_scale_ts7.Enum)({
    plain: compactNumber,
    map: storageMap
  }),
  fallback: Hex(),
  docs: (0, import_scale_ts7.Vector)(import_scale_ts7.str)
});
var storage = (0, import_scale_ts7.Option)(
  (0, import_scale_ts7.Struct)({
    prefix: import_scale_ts7.str,
    items: (0, import_scale_ts7.Vector)(storageItem)
  })
);
var pallets = (0, import_scale_ts7.Vector)(
  (0, import_scale_ts7.Struct)({
    name: import_scale_ts7.str,
    storage,
    calls: (0, import_scale_ts7.Option)(compactNumber),
    events: (0, import_scale_ts7.Option)(compactNumber),
    constants: (0, import_scale_ts7.Vector)(
      (0, import_scale_ts7.Struct)({
        name: import_scale_ts7.str,
        type: compactNumber,
        value: Hex(),
        docs: (0, import_scale_ts7.Vector)(import_scale_ts7.str)
      })
    ),
    errors: (0, import_scale_ts7.Option)(compactNumber),
    index: import_scale_ts7.u8
  })
);

// src/codecs/metadata/v14/v14.ts
var extrinsic = (0, import_scale_ts8.Struct)({
  type: compactNumber,
  version: import_scale_ts8.u8,
  signedExtensions: (0, import_scale_ts8.Vector)(
    (0, import_scale_ts8.Struct)({
      identifier: import_scale_ts8.str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v14 = (0, import_scale_ts8.Struct)({
  lookup,
  pallets,
  extrinsic,
  type: compactNumber
});

// src/codecs/metadata/metadata.ts
var import_scale_ts9 = require("scale-ts");
var unsupportedFn = () => {
  throw new Error("Unsupported metadata version!");
};
var unsupported = (0, import_scale_ts9.createCodec)(
  unsupportedFn,
  unsupportedFn
);
var metadata = (0, import_scale_ts9.Struct)({
  magicNumber: import_scale_ts9.u32,
  metadata: (0, import_scale_ts9.Enum)({
    v0: unsupported,
    v1: unsupported,
    v2: unsupported,
    v3: unsupported,
    v4: unsupported,
    v5: unsupported,
    v6: unsupported,
    v7: unsupported,
    v8: unsupported,
    v9: unsupported,
    v10: unsupported,
    v11: unsupported,
    v12: unsupported,
    v13: unsupported,
    v14
  })
});

// src/codecs/bitSequence.ts
var import_scale_ts10 = require("scale-ts");
var bitSequenceDecoder = (0, import_scale_ts10.createDecoder)((data) => {
  const bitsLen = compactNumber.dec(data);
  const bytesLen = Math.ceil(bitsLen / 8);
  const bytes = (0, import_scale_ts10.Bytes)(bytesLen).dec(data);
  return { bytes, bitsLen };
});
var bitSequenceEncoder = (input) => {
  if (input.bitsLen > input.bytes.length * 8)
    throw new Error(
      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`
    );
  const lenEncoded = compactNumber.enc(input.bitsLen);
  const result = new Uint8Array(input.bytes.length + lenEncoded.length);
  result.set(lenEncoded, 0);
  result.set(input.bytes, lenEncoded.length);
  return result;
};
var bitSequence2 = (0, import_scale_ts10.createCodec)(bitSequenceEncoder, bitSequenceDecoder);

// src/codecs/char.ts
var import_scale_ts11 = require("scale-ts");
var char = (0, import_scale_ts11.enhanceCodec)(
  import_scale_ts11.u8,
  (str4) => str4.charCodeAt(0),
  String.fromCharCode
);

// src/codecs/fixed-str.ts
var import_scale_ts12 = require("scale-ts");
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var fixedStr = (nBytes) => (0, import_scale_ts12.enhanceCodec)(
  (0, import_scale_ts12.Bytes)(nBytes),
  (str4) => textEncoder.encode(str4),
  (bytes) => textDecoder.decode(bytes)
);

// src/codecs/blockHeader.ts
var import_scale_ts13 = require("scale-ts");
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();
var fourChars = (0, import_scale_ts13.enhanceCodec)(
  (0, import_scale_ts13.Bytes)(4),
  textEncoder2.encode.bind(textEncoder2),
  textDecoder2.decode.bind(textDecoder2)
);
var diggestVal = (0, import_scale_ts13.Struct)({
  engine: fourChars,
  payload: Hex()
});
var diggest = (0, import_scale_ts13.Enum)(
  {
    consensus: diggestVal,
    seal: diggestVal,
    preRuntime: diggestVal,
    runtimeUpdated: import_scale_ts13._void
  },
  [4, 5, 6, 8]
);
var hex32 = Hex(32);
var blockHeader = (0, import_scale_ts13.Struct)({
  parentHash: hex32,
  number: compactNumber,
  stateRoot: hex32,
  extrinsicRoot: hex32,
  digests: (0, import_scale_ts13.Vector)(diggest)
});

// src/index.ts
__reExport(src_exports, codecs_exports, module.exports);

// src/hashes/blake2.ts
var import_utils2 = require("@polkadot-api/utils");
var import_blake2b2 = require("@noble/hashes/blake2b");
var len32 = { dkLen: 32 };
var Blake2256 = (encoded) => (0, import_blake2b2.blake2b)(encoded, len32);
var len16 = { dkLen: 16 };
var Blake2128 = (encoded) => (0, import_blake2b2.blake2b)(encoded, len16);
var Blake2128Concat = (encoded) => (0, import_utils2.mergeUint8)(Blake2128(encoded), encoded);

// src/hashes/identity.ts
var Identity = (encoded) => encoded;

// src/hashes/twoX.ts
var import_utils3 = require("@polkadot-api/utils");
var import_scale_ts14 = require("scale-ts");

// src/hashes/h64.ts
var bigintFromU16 = (v0, v1, v2, v3) => new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true);
var MASK_64 = 2n ** 64n - 1n;
var rotl = (input, nBits) => input << nBits & MASK_64 | input >> 64n - nBits;
var multiply = (a, b) => a * b & MASK_64;
var add = (a, b) => a + b & MASK_64;
var PRIME64_1 = 11400714785074694791n;
var PRIME64_2 = 14029467366897019727n;
var PRIME64_3 = 1609587929392839161n;
var PRIME64_4 = 9650029242287828579n;
var PRIME64_5 = 2870177450012600261n;
function h64(input, seed = 0n) {
  let v1 = add(add(seed, PRIME64_1), PRIME64_2);
  let v2 = add(seed, PRIME64_2);
  let v3 = seed;
  let v4 = seed - PRIME64_1;
  let totalLen = input.length;
  let memsize = 0;
  let memory = null;
  (function update() {
    let p2 = 0;
    let bEnd = p2 + totalLen;
    if (!totalLen)
      return;
    memory = new Uint8Array(32);
    if (totalLen < 32) {
      memory.set(input.subarray(0, totalLen), memsize);
      memsize += totalLen;
      return;
    }
    if (p2 <= bEnd - 32) {
      const limit = bEnd - 32;
      do {
        let other;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
      } while (p2 <= limit);
    }
    if (p2 < bEnd) {
      memory.set(input.subarray(p2, bEnd), memsize);
      memsize = bEnd - p2;
    }
  })();
  input = memory || input;
  let result;
  let p = 0;
  if (totalLen >= 32) {
    result = rotl(v1, 1n);
    result = add(result, rotl(v2, 7n));
    result = add(result, rotl(v3, 12n));
    result = add(result, rotl(v4, 18n));
    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v1;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v2;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v3;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v4;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
  } else {
    result = add(seed, PRIME64_5);
  }
  result = add(result, BigInt(totalLen));
  while (p <= memsize - 8) {
    let temp2 = bigintFromU16(
      input[p + 1] << 8 | input[p],
      input[p + 3] << 8 | input[p + 2],
      input[p + 5] << 8 | input[p + 4],
      input[p + 7] << 8 | input[p + 6]
    );
    temp2 = multiply(rotl(multiply(temp2, PRIME64_2), 31n), PRIME64_1);
    result = add(multiply(rotl(result ^ temp2, 27n), PRIME64_1), PRIME64_4);
    p += 8;
  }
  if (p + 4 <= memsize) {
    let temp2 = multiply(
      bigintFromU16(
        input[p + 1] << 8 | input[p],
        input[p + 3] << 8 | input[p + 2],
        0,
        0
      ),
      PRIME64_1
    );
    result = add(multiply(rotl(result ^ temp2, 23n), PRIME64_2), PRIME64_3);
    p += 4;
  }
  while (p < memsize) {
    const temp2 = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5);
    result = multiply(rotl(result ^ temp2, 11n), PRIME64_1);
  }
  let temp = result >> 33n;
  result = multiply(result ^ temp, PRIME64_2);
  temp = result >> 29n;
  result = multiply(result ^ temp, PRIME64_3);
  temp = result >> 32n;
  result ^= temp;
  return result;
}

// src/hashes/twoX.ts
var Twox128 = (input) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  return result;
};
var Twox256 = (input) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  dv.setBigUint64(16, h64(input, 2n), true);
  dv.setBigUint64(24, h64(input, 3n), true);
  return result;
};
var Twox64Concat = (encoded) => (0, import_utils3.mergeUint8)(import_scale_ts14.u64.enc(h64(encoded)), encoded);

// src/storage.ts
var import_utils4 = require("@polkadot-api/utils");
var textEncoder3 = new TextEncoder();
var Storage = (pallet) => {
  const palledEncoded = Twox128(textEncoder3.encode(pallet));
  return (name, dec2, ...encoders) => {
    const palletItemEncoded = (0, import_utils4.mergeUint8)(
      palledEncoded,
      Twox128(textEncoder3.encode(name))
    );
    const palletItemEncodedHex = (0, import_utils4.toHex)(palletItemEncoded);
    const bytesToSkip = encoders.map((e) => e[1]).map((x) => {
      if (x === Identity)
        return 0;
      if (x === Twox64Concat)
        return 8;
      if (x === Blake2128Concat)
        return 16;
      return null;
    }).filter(Boolean);
    const keyDecoder = (key) => {
      if (!key.startsWith(palletItemEncodedHex))
        throw new Error(`key does not match this storage (${pallet}.${name})`);
      if (bytesToSkip.length !== encoders.length)
        throw new Error("Impossible to decode this key");
      if (encoders.length === 0)
        return [];
      const argsKey = key.slice(palletItemEncodedHex.length);
      const result = new Array(encoders.length);
      for (let i = 0, cur = 0; i < bytesToSkip.length; i++) {
        const codec = encoders[i][0];
        cur += bytesToSkip[i];
        result[i] = codec.dec(argsKey.slice(cur * 2));
        cur += codec.enc(result[i]).length;
      }
      return result;
    };
    const fns = encoders.map(
      ([{ enc: enc3 }, hash]) => (val) => hash(enc3(val))
    );
    const enc2 = (...args) => (0, import_utils4.toHex)(
      (0, import_utils4.mergeUint8)(palletItemEncoded, ...args.map((val, idx) => fns[idx](val)))
    );
    return {
      enc: enc2,
      dec: dec2,
      keyDecoder
    };
  };
};
//# sourceMappingURL=index.js.map