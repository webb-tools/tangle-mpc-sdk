{"version":3,"sources":["../src/index.ts","../src/codecs/index.ts","../src/codecs/AccountId.ts","../src/codecs/compact.ts","../src/codecs/Self.ts","../src/codecs/Opaque.ts","../src/codecs/metadata/v14/v14.ts","../src/codecs/metadata/v14/lookup.ts","../src/codecs/Hex.ts","../src/codecs/metadata/v14/pallets.ts","../src/codecs/metadata/metadata.ts","../src/codecs/bitSequence.ts","../src/codecs/char.ts","../src/codecs/fixed-str.ts","../src/codecs/blockHeader.ts","../src/hashes/blake2.ts","../src/hashes/identity.ts","../src/hashes/twoX.ts","../src/hashes/h64.ts","../src/storage.ts"],"sourcesContent":["export * from \"scale-ts\"\nexport * from \"./codecs\"\nexport * from \"./hashes\"\nexport * from \"./storage\"\nexport * from \"./descriptors\"\n","export * from \"scale-ts\"\nexport * from \"./AccountId\"\nexport * from \"./compact\"\nexport * from \"./Self\"\nexport * from \"./Opaque\"\nexport * from \"./metadata\"\nexport * from \"./bitSequence\"\nexport * from \"./char\"\nexport * from \"./fixed-str\"\nexport * from \"./Hex\"\nexport * from \"./blockHeader\"\n","import { Bytes, enhanceCodec } from \"scale-ts\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\nimport { base58 } from \"@scure/base\"\n\nconst SS58_PREFIX = new TextEncoder().encode(\"SS58PRE\")\n\nconst CHECKSUM_LENGTH = 2\n\nexport type SS58String = string & { __SS58String?: unknown }\n\nconst fromBufferToBase58 = (ss58Format: number) => {\n  const prefixBytes =\n    ss58Format < 64\n      ? Uint8Array.of(ss58Format)\n      : Uint8Array.of(\n          ((ss58Format & 0b0000_0000_1111_1100) >> 2) | 0b0100_0000,\n          (ss58Format >> 8) | ((ss58Format & 0b0000_0000_0000_0011) << 6),\n        )\n  return (publicKey: Uint8Array): SS58String => {\n    const checksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n    return base58.encode(\n      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum),\n    )\n  }\n}\n\nfunction fromBase58ToBuffer(nBytes: number, ss58Format: number) {\n  return (address: SS58String) => {\n    const decoded = base58.decode(address)\n    const prefixBytes = decoded.subarray(0, decoded[0] & 0b0100_0000 ? 2 : 1)\n    const publicKey = decoded.subarray(\n      prefixBytes.length,\n      decoded.length - CHECKSUM_LENGTH,\n    )\n    if (publicKey.length !== nBytes)\n      throw new Error(\"Invalid public key length\")\n    const checksum = decoded.subarray(prefixBytes.length + publicKey.length)\n    const expectedChecksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n    if (\n      checksum[0] !== expectedChecksum[0] ||\n      checksum[1] !== expectedChecksum[1]\n    )\n      throw new Error(\"Invalid checksum\")\n\n    if (prefixBytesToNumber(prefixBytes) != ss58Format)\n      throw new Error(\"Invalid SS58 prefix\")\n\n    return publicKey.slice()\n  }\n}\n\nexport const AccountId = (ss58Format: number = 42, nBytes: 32 | 33 = 32) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    fromBase58ToBuffer(nBytes, ss58Format),\n    fromBufferToBase58(ss58Format),\n  )\n\nconst prefixBytesToNumber = (bytes: Uint8Array) => {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0)\n}\n","import { Codec, compact } from \"scale-ts\"\n\nexport const compactNumber = compact as Codec<number>\nexport const compactBn = compact as Codec<bigint>\n","import { Codec, Decoder, Encoder, createCodec, _void } from \"scale-ts\"\n\nexport const selfEncoder = <T>(value: () => Encoder<T>): Encoder<T> => {\n  let cache: Encoder<T> = (x) => {\n    const encoder = value()\n    cache = encoder\n    return encoder(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const selfDecoder = <T>(value: () => Decoder<T>): Decoder<T> => {\n  let cache: Decoder<T> = (x) => {\n    const decoder = value()\n    const result = decoder\n    cache = decoder\n    return result(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const Self = <T>(value: () => Codec<T>): Codec<T> =>\n  createCodec(\n    selfEncoder(() => value().enc),\n    selfDecoder(() => value().dec),\n  )\n","import {\n  Bytes,\n  Codec,\n  createCodec,\n  createDecoder,\n  Decoder,\n  Encoder,\n} from \"scale-ts\"\nimport { compactNumber } from \"./compact\"\n\nexport type OpaqueValue<T> = {\n  length: number\n  inner: () => T\n}\n\nconst OpaqueDecoder = <T>(\n  inner: Decoder<T>,\n  len: Decoder<number> = compactNumber.dec,\n): Decoder<OpaqueValue<T>> =>\n  createDecoder((bytes) => {\n    const length = len(bytes)\n    const innerBytes = Bytes(length).dec(bytes)\n    let _cachedValue: T | undefined\n\n    return {\n      length,\n      inner: () => (_cachedValue = _cachedValue || inner(innerBytes)),\n    }\n  })\n\nconst OpaqueEncoder =\n  <T>(\n    inner: Encoder<T>,\n    len: Encoder<number> = compactNumber.enc,\n  ): Encoder<OpaqueValue<T>> =>\n  (input) => {\n    const lenBytes = len(input.length)\n\n    const result = new Uint8Array(lenBytes.length + input.length)\n    result.set(lenBytes, 0)\n    result.set(inner(input.inner()), lenBytes.length)\n\n    return result\n  }\n\nexport const OpaqueCodec = <T>(\n  inner: Codec<T>,\n  len: Codec<number> = compactNumber,\n): Codec<OpaqueValue<T>> =>\n  createCodec(\n    OpaqueEncoder(inner.enc, len.enc),\n    OpaqueDecoder(inner.dec, len.dec),\n  )\n\nOpaqueCodec.enc = OpaqueEncoder\nOpaqueCodec.dec = OpaqueDecoder\n","import { CodecType, Struct, Vector, str, u8 } from \"scale-ts\"\nimport { lookup } from \"./lookup\"\nimport { pallets } from \"./pallets\"\nimport { compactNumber } from \"../../compact\"\nexport type { V14Lookup } from \"./lookup\"\nexport type { V14Pallets } from \"./pallets\"\n\nconst extrinsic = Struct({\n  type: compactNumber,\n  version: u8,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      type: compactNumber,\n      additionalSigned: compactNumber,\n    }),\n  ),\n})\nexport type V14Extrinsic = CodecType<typeof extrinsic>\n\nexport const v14 = Struct({\n  lookup,\n  pallets,\n  extrinsic,\n  type: compactNumber,\n})\nexport type V14 = CodecType<typeof v14>\n","import { compactNumber } from \"../../compact\"\nimport {\n  CodecType,\n  Enum,\n  Option,\n  Struct,\n  Vector,\n  _void,\n  str,\n  u32,\n  u8,\n} from \"scale-ts\"\n\nconst oStr = Option(str)\nconst strs = Vector(str)\n\nconst primitive = Enum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\n\nconst fields = Vector(\n  Struct({\n    name: oStr,\n    type: compactNumber,\n    typeName: oStr,\n    docs: strs,\n  }),\n)\n\nconst arr = Struct({\n  len: u32,\n  type: compactNumber,\n})\n\nconst bitSequence = Struct({\n  bitStoreType: compactNumber,\n  bitOrderType: compactNumber,\n})\n\nconst variant = Vector(\n  Struct({\n    name: str,\n    fields,\n    index: u8,\n    docs: strs,\n  }),\n)\n\nconst def = Enum({\n  composite: fields,\n  variant,\n  sequence: compactNumber,\n  array: arr,\n  tuple: Vector(compactNumber),\n  primitive,\n  compact: compactNumber,\n  bitSequence,\n  historicMetaCompat: str,\n})\n\nconst param = Struct({\n  name: str,\n  type: Option(compactNumber),\n})\nconst params = Vector(param)\n\nconst entry = Struct({\n  id: compactNumber,\n  path: strs,\n  params,\n  def,\n  docs: strs,\n})\n\nexport const lookup = Vector(entry)\nexport type V14Lookup = CodecType<typeof lookup>\n","import { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { Bytes, Codec, Decoder, Encoder, createCodec } from \"scale-ts\"\n\nexport type HexString = string & { __hexString?: unknown }\n\nconst enc = (nBytes?: number): Encoder<HexString> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value: string) => _enc(fromHex(value))\n}\n\nconst dec = (nBytes?: number): Decoder<HexString> => {\n  const _dec = Bytes.dec(nBytes)\n  return (value) => toHex(_dec(value)) as HexString\n}\n\nexport const Hex = (nBytes?: number): Codec<HexString> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nHex.enc = enc\nHex.dec = dec\n","import { Hex } from \"../../Hex\"\nimport { compactNumber } from \"../../compact\"\nimport {\n  Struct,\n  Option,\n  Vector,\n  u8,\n  str,\n  Enum,\n  _void,\n  CodecType,\n} from \"scale-ts\"\n\nconst hashType = Enum({\n  Blake2128: _void,\n  Blake2256: _void,\n  Blake2128Concat: _void,\n  Twox128: _void,\n  Twox256: _void,\n  Twox64Concat: _void,\n  Identity: _void,\n})\n\nconst hashers = Vector(hashType)\n\nconst storageMap = Struct({\n  hashers,\n  key: compactNumber,\n  value: compactNumber,\n})\n\nconst storageItem = Struct({\n  name: str,\n  modifier: u8,\n  type: Enum({\n    plain: compactNumber,\n    map: storageMap,\n  }),\n  fallback: Hex(),\n  docs: Vector(str),\n})\n\nconst storage = Option(\n  Struct({\n    prefix: str,\n    items: Vector(storageItem),\n  }),\n)\n\nexport const pallets = Vector(\n  Struct({\n    name: str,\n    storage,\n    calls: Option(compactNumber),\n    events: Option(compactNumber),\n    constants: Vector(\n      Struct({\n        name: str,\n        type: compactNumber,\n        value: Hex(),\n        docs: Vector(str),\n      }),\n    ),\n    errors: Option(compactNumber),\n    index: u8,\n  }),\n)\n\nexport type V14Pallets = CodecType<typeof pallets>\n","import { Enum, Struct, u32, Codec, createCodec } from \"scale-ts\"\nimport { v14 } from \"./v14\"\n\nconst unsupportedFn = () => {\n  throw new Error(\"Unsupported metadata version!\")\n}\n\nconst unsupported = createCodec(\n  unsupportedFn,\n  unsupportedFn,\n) as unknown as Codec<unknown>\n\nexport const metadata = Struct({\n  magicNumber: u32,\n  metadata: Enum({\n    v0: unsupported,\n    v1: unsupported,\n    v2: unsupported,\n    v3: unsupported,\n    v4: unsupported,\n    v5: unsupported,\n    v6: unsupported,\n    v7: unsupported,\n    v8: unsupported,\n    v9: unsupported,\n    v10: unsupported,\n    v11: unsupported,\n    v12: unsupported,\n    v13: unsupported,\n    v14,\n  }),\n})\n","import { Bytes, Decoder, Encoder, createCodec, createDecoder } from \"scale-ts\"\nimport { compactNumber } from \"./compact\"\n\nexport interface BitSequence {\n  bitsLen: number\n  bytes: Uint8Array\n}\n\nconst bitSequenceDecoder: Decoder<BitSequence> = createDecoder((data) => {\n  const bitsLen = compactNumber.dec(data)\n  const bytesLen = Math.ceil(bitsLen / 8)\n  const bytes = Bytes(bytesLen).dec(data)\n  return { bytes, bitsLen }\n})\n\nconst bitSequenceEncoder: Encoder<BitSequence> = (input) => {\n  if (input.bitsLen > input.bytes.length * 8)\n    throw new Error(\n      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`,\n    )\n\n  const lenEncoded = compactNumber.enc(input.bitsLen)\n  const result = new Uint8Array(input.bytes.length + lenEncoded.length)\n  result.set(lenEncoded, 0)\n  result.set(input.bytes, lenEncoded.length)\n  return result\n}\n\nexport const bitSequence = createCodec(bitSequenceEncoder, bitSequenceDecoder)\n","import { enhanceCodec, u8 } from \"scale-ts\"\n\nexport const char = enhanceCodec(\n  u8,\n  (str: string) => str.charCodeAt(0),\n  String.fromCharCode,\n)\n","import { Bytes, enhanceCodec } from \"scale-ts\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const fixedStr = (nBytes: number) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    (str: string) => textEncoder.encode(str),\n    (bytes) => textDecoder.decode(bytes),\n  )\n","import {\n  Bytes,\n  CodecType,\n  Enum,\n  Struct,\n  Vector,\n  _void,\n  enhanceCodec,\n} from \"scale-ts\"\nimport { Hex } from \"./Hex\"\nimport { compactNumber } from \"./compact\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst fourChars = enhanceCodec(\n  Bytes(4),\n  textEncoder.encode.bind(textEncoder),\n  textDecoder.decode.bind(textDecoder),\n)\n\nconst diggestVal = Struct({\n  engine: fourChars,\n  payload: Hex(),\n})\n\nconst diggest = Enum(\n  {\n    consensus: diggestVal,\n    seal: diggestVal,\n    preRuntime: diggestVal,\n    runtimeUpdated: _void,\n  },\n  [4, 5, 6, 8],\n)\n\nconst hex32 = Hex(32)\nexport const blockHeader = Struct({\n  parentHash: hex32,\n  number: compactNumber,\n  stateRoot: hex32,\n  extrinsicRoot: hex32,\n  digests: Vector(diggest),\n})\n\nexport type BlockHeader = CodecType<typeof blockHeader>\n","import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\n\nconst len32 = { dkLen: 32 }\nexport const Blake2256 = (encoded: Uint8Array) => blake2b(encoded, len32)\n\nconst len16 = { dkLen: 16 }\nexport const Blake2128 = (encoded: Uint8Array) => blake2b(encoded, len16)\n\nexport const Blake2128Concat = (encoded: Uint8Array) =>\n  mergeUint8(Blake2128(encoded), encoded)\n","export const Identity = (encoded: Uint8Array): Uint8Array => encoded\n","import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { u64 } from \"scale-ts\"\nimport { h64 } from \"./h64\"\n\nexport const Twox128 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(16)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n\n  return result\n}\n\nexport const Twox256 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(32)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n  dv.setBigUint64(16, h64(input, 2n), true)\n  dv.setBigUint64(24, h64(input, 3n), true)\n\n  return result\n}\n\nexport const Twox64Concat = (encoded: Uint8Array): Uint8Array =>\n  mergeUint8(u64.enc(h64(encoded)), encoded)\n","// Adapted implementation based on: https://github.com/pierrec/js-xxhash/blob/7ff5ced282f97dba121109d7013e0fa80360398c/lib/xxhash64.js\n\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n\n// helper functions\nconst bigintFromU16 = (\n  v0: number,\n  v1: number,\n  v2: number,\n  v3: number,\n): bigint =>\n  new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true)\n\nconst MASK_64 = 2n ** 64n - 1n\n\nconst rotl = (input: bigint, nBits: bigint) =>\n  ((input << nBits) & MASK_64) | (input >> (64n - nBits))\n\nconst multiply = (a: bigint, b: bigint) => (a * b) & MASK_64\n\nconst add = (a: bigint, b: bigint) => (a + b) & MASK_64\n\n// constants\nconst PRIME64_1 = 11400714785074694791n\nconst PRIME64_2 = 14029467366897019727n\nconst PRIME64_3 = 1609587929392839161n\nconst PRIME64_4 = 9650029242287828579n\nconst PRIME64_5 = 2870177450012600261n\n\nexport function h64(input: Uint8Array, seed: bigint = 0n) {\n  let v1 = add(add(seed, PRIME64_1), PRIME64_2)\n  let v2 = add(seed, PRIME64_2)\n  let v3 = seed\n  let v4 = seed - PRIME64_1\n  let totalLen = input.length\n  let memsize = 0\n  let memory: Uint8Array | null = null\n\n  ;(function update() {\n    let p = 0\n    let bEnd = p + totalLen\n\n    if (!totalLen) return\n\n    memory = new Uint8Array(32)\n\n    if (totalLen < 32) {\n      memory.set(input.subarray(0, totalLen), memsize)\n\n      memsize += totalLen\n      return\n    }\n\n    if (p <= bEnd - 32) {\n      const limit = bEnd - 32\n\n      do {\n        let other\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n      } while (p <= limit)\n    }\n\n    if (p < bEnd) {\n      memory.set(input.subarray(p, bEnd), memsize)\n      memsize = bEnd - p\n    }\n  })()\n\n  input = memory || input\n\n  let result: bigint\n  let p = 0\n\n  if (totalLen >= 32) {\n    result = rotl(v1, 1n)\n    result = add(result, rotl(v2, 7n))\n    result = add(result, rotl(v3, 12n))\n    result = add(result, rotl(v4, 18n))\n\n    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v1\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v2\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v3\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v4\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n  } else {\n    result = add(seed, PRIME64_5)\n  }\n\n  result = add(result, BigInt(totalLen))\n\n  while (p <= memsize - 8) {\n    let temp = bigintFromU16(\n      (input[p + 1] << 8) | input[p],\n      (input[p + 3] << 8) | input[p + 2],\n      (input[p + 5] << 8) | input[p + 4],\n      (input[p + 7] << 8) | input[p + 6],\n    )\n    temp = multiply(rotl(multiply(temp, PRIME64_2), 31n), PRIME64_1)\n    result = add(multiply(rotl(result ^ temp, 27n), PRIME64_1), PRIME64_4)\n    p += 8\n  }\n\n  if (p + 4 <= memsize) {\n    let temp = multiply(\n      bigintFromU16(\n        (input[p + 1] << 8) | input[p],\n        (input[p + 3] << 8) | input[p + 2],\n        0,\n        0,\n      ),\n      PRIME64_1,\n    )\n\n    result = add(multiply(rotl(result ^ temp, 23n), PRIME64_2), PRIME64_3)\n    p += 4\n  }\n\n  while (p < memsize) {\n    const temp = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5)\n    result = multiply(rotl(result ^ temp, 11n), PRIME64_1)\n  }\n\n  let temp = result >> 33n\n  result = multiply(result ^ temp, PRIME64_2)\n\n  temp = result >> 29n\n  result = multiply(result ^ temp, PRIME64_3)\n\n  temp = result >> 32n\n  result ^= temp\n\n  return result\n}\n","import { mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { Codec, Decoder } from \"scale-ts\"\nimport { Blake2128Concat, Identity, Twox128, Twox64Concat } from \"./hashes\"\n\nexport type EncoderWithHash<T> = [Codec<T>, (input: Uint8Array) => Uint8Array]\n\nconst textEncoder = new TextEncoder()\n\nexport const Storage = (pallet: string) => {\n  const palledEncoded = Twox128(textEncoder.encode(pallet))\n  return <T, A extends Array<EncoderWithHash<any>>>(\n    name: string,\n    dec: Decoder<T>,\n    ...encoders: [...A]\n  ): {\n    enc: (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ) => string\n    dec: Decoder<T>\n    keyDecoder: (value: string) => {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    }\n  } => {\n    const palletItemEncoded = mergeUint8(\n      palledEncoded,\n      Twox128(textEncoder.encode(name)),\n    )\n\n    const palletItemEncodedHex = toHex(palletItemEncoded)\n    const bytesToSkip = encoders\n      .map((e) => e[1])\n      .map((x) => {\n        if (x === Identity) return 0\n        if (x === Twox64Concat) return 8\n        if (x === Blake2128Concat) return 16\n        return null\n      })\n      .filter(Boolean) as Array<number>\n\n    const keyDecoder = (\n      key: string,\n    ): {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    } => {\n      if (!key.startsWith(palletItemEncodedHex))\n        throw new Error(`key does not match this storage (${pallet}.${name})`)\n\n      if (bytesToSkip.length !== encoders.length)\n        throw new Error(\"Impossible to decode this key\")\n\n      if (encoders.length === 0) return [] as any\n\n      const argsKey = key.slice(palletItemEncodedHex.length)\n      const result = new Array<any>(encoders.length)\n      for (let i = 0, cur = 0; i < bytesToSkip.length; i++) {\n        const codec = encoders[i][0]\n        cur += bytesToSkip[i]\n        result[i] = codec.dec(argsKey.slice(cur * 2))\n        cur += codec.enc(result[i]).length\n      }\n      return result as any\n    }\n\n    const fns = encoders.map(\n      ([{ enc }, hash]) =>\n        (val: any) =>\n          hash(enc(val)),\n    )\n\n    const enc = (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ): string =>\n      toHex(\n        mergeUint8(palletItemEncoded, ...args.map((val, idx) => fns[idx](val))),\n      )\n\n    return {\n      enc,\n      dec,\n      keyDecoder,\n    }\n  }\n}\n"],"mappings":"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","names":["bitSequence","bitSequence","import_scale_ts","import_scale_ts","import_scale_ts","import_scale_ts","import_scale_ts","import_scale_ts","import_scale_ts","import_scale_ts","import_scale_ts","bitSequence","import_scale_ts","str","import_scale_ts","str","import_scale_ts","textEncoder","textDecoder","import_utils","import_blake2b","import_utils","import_scale_ts","p","temp","import_utils","textEncoder","dec","enc"]}