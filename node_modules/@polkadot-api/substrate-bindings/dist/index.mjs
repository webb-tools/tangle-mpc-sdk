var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AccountId: () => AccountId,
  Blake2128: () => Blake2128,
  Blake2128Concat: () => Blake2128Concat,
  Blake2256: () => Blake2256,
  Hex: () => Hex,
  Identity: () => Identity,
  OpaqueCodec: () => OpaqueCodec,
  Self: () => Self,
  Storage: () => Storage,
  Twox128: () => Twox128,
  Twox256: () => Twox256,
  Twox64Concat: () => Twox64Concat,
  bitSequence: () => bitSequence2,
  blockHeader: () => blockHeader,
  char: () => char,
  compactBn: () => compactBn,
  compactNumber: () => compactNumber,
  fixedStr: () => fixedStr,
  h64: () => h64,
  metadata: () => metadata,
  selfDecoder: () => selfDecoder,
  selfEncoder: () => selfEncoder,
  v14: () => v14
});
export * from "scale-ts";

// src/codecs/index.ts
var codecs_exports = {};
__export(codecs_exports, {
  AccountId: () => AccountId,
  Hex: () => Hex,
  OpaqueCodec: () => OpaqueCodec,
  Self: () => Self,
  bitSequence: () => bitSequence2,
  blockHeader: () => blockHeader,
  char: () => char,
  compactBn: () => compactBn,
  compactNumber: () => compactNumber,
  fixedStr: () => fixedStr,
  metadata: () => metadata,
  selfDecoder: () => selfDecoder,
  selfEncoder: () => selfEncoder,
  v14: () => v14
});
__reExport(codecs_exports, scale_ts_star);
import * as scale_ts_star from "scale-ts";

// src/codecs/AccountId.ts
import { Bytes, enhanceCodec } from "scale-ts";
import { blake2b } from "@noble/hashes/blake2b";
import { base58 } from "@scure/base";
var SS58_PREFIX = new TextEncoder().encode("SS58PRE");
var CHECKSUM_LENGTH = 2;
var fromBufferToBase58 = (ss58Format) => {
  const prefixBytes = ss58Format < 64 ? Uint8Array.of(ss58Format) : Uint8Array.of(
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  );
  return (publicKey) => {
    const checksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    return base58.encode(
      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum)
    );
  };
};
function fromBase58ToBuffer(nBytes, ss58Format) {
  return (address) => {
    const decoded = base58.decode(address);
    const prefixBytes = decoded.subarray(0, decoded[0] & 64 ? 2 : 1);
    const publicKey = decoded.subarray(
      prefixBytes.length,
      decoded.length - CHECKSUM_LENGTH
    );
    if (publicKey.length !== nBytes)
      throw new Error("Invalid public key length");
    const checksum = decoded.subarray(prefixBytes.length + publicKey.length);
    const expectedChecksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    if (checksum[0] !== expectedChecksum[0] || checksum[1] !== expectedChecksum[1])
      throw new Error("Invalid checksum");
    if (prefixBytesToNumber(prefixBytes) != ss58Format)
      throw new Error("Invalid SS58 prefix");
    return publicKey.slice();
  };
}
var AccountId = (ss58Format = 42, nBytes = 32) => enhanceCodec(
  Bytes(nBytes),
  fromBase58ToBuffer(nBytes, ss58Format),
  fromBufferToBase58(ss58Format)
);
var prefixBytesToNumber = (bytes) => {
  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0);
};

// src/codecs/compact.ts
import { compact } from "scale-ts";
var compactNumber = compact;
var compactBn = compact;

// src/codecs/Self.ts
import { createCodec } from "scale-ts";
var selfEncoder = (value) => {
  let cache = (x) => {
    const encoder = value();
    cache = encoder;
    return encoder(x);
  };
  return (x) => cache(x);
};
var selfDecoder = (value) => {
  let cache = (x) => {
    const decoder = value();
    const result = decoder;
    cache = decoder;
    return result(x);
  };
  return (x) => cache(x);
};
var Self = (value) => createCodec(
  selfEncoder(() => value().enc),
  selfDecoder(() => value().dec)
);

// src/codecs/Opaque.ts
import {
  Bytes as Bytes2,
  createCodec as createCodec2,
  createDecoder
} from "scale-ts";
var OpaqueDecoder = (inner, len = compactNumber.dec) => createDecoder((bytes) => {
  const length = len(bytes);
  const innerBytes = Bytes2(length).dec(bytes);
  let _cachedValue;
  return {
    length,
    inner: () => _cachedValue = _cachedValue || inner(innerBytes)
  };
});
var OpaqueEncoder = (inner, len = compactNumber.enc) => (input) => {
  const lenBytes = len(input.length);
  const result = new Uint8Array(lenBytes.length + input.length);
  result.set(lenBytes, 0);
  result.set(inner(input.inner()), lenBytes.length);
  return result;
};
var OpaqueCodec = (inner, len = compactNumber) => createCodec2(
  OpaqueEncoder(inner.enc, len.enc),
  OpaqueDecoder(inner.dec, len.dec)
);
OpaqueCodec.enc = OpaqueEncoder;
OpaqueCodec.dec = OpaqueDecoder;

// src/codecs/metadata/v14/v14.ts
import { Struct as Struct3, Vector as Vector3, str as str3, u8 as u83 } from "scale-ts";

// src/codecs/metadata/v14/lookup.ts
import {
  Enum,
  Option,
  Struct,
  Vector,
  _void as _void2,
  str,
  u32,
  u8
} from "scale-ts";
var oStr = Option(str);
var strs = Vector(str);
var primitive = Enum({
  bool: _void2,
  char: _void2,
  str: _void2,
  u8: _void2,
  u16: _void2,
  u32: _void2,
  u64: _void2,
  u128: _void2,
  u256: _void2,
  i8: _void2,
  i16: _void2,
  i32: _void2,
  i64: _void2,
  i128: _void2,
  i256: _void2
});
var fields = Vector(
  Struct({
    name: oStr,
    type: compactNumber,
    typeName: oStr,
    docs: strs
  })
);
var arr = Struct({
  len: u32,
  type: compactNumber
});
var bitSequence = Struct({
  bitStoreType: compactNumber,
  bitOrderType: compactNumber
});
var variant = Vector(
  Struct({
    name: str,
    fields,
    index: u8,
    docs: strs
  })
);
var def = Enum({
  composite: fields,
  variant,
  sequence: compactNumber,
  array: arr,
  tuple: Vector(compactNumber),
  primitive,
  compact: compactNumber,
  bitSequence,
  historicMetaCompat: str
});
var param = Struct({
  name: str,
  type: Option(compactNumber)
});
var params = Vector(param);
var entry = Struct({
  id: compactNumber,
  path: strs,
  params,
  def,
  docs: strs
});
var lookup = Vector(entry);

// src/codecs/Hex.ts
import { fromHex, toHex } from "@polkadot-api/utils";
import { Bytes as Bytes3, createCodec as createCodec3 } from "scale-ts";
var enc = (nBytes) => {
  const _enc = Bytes3.enc(nBytes);
  return (value) => _enc(fromHex(value));
};
var dec = (nBytes) => {
  const _dec = Bytes3.dec(nBytes);
  return (value) => toHex(_dec(value));
};
var Hex = (nBytes) => createCodec3(enc(nBytes), dec(nBytes));
Hex.enc = enc;
Hex.dec = dec;

// src/codecs/metadata/v14/pallets.ts
import {
  Struct as Struct2,
  Option as Option2,
  Vector as Vector2,
  u8 as u82,
  str as str2,
  Enum as Enum2,
  _void as _void3
} from "scale-ts";
var hashType = Enum2({
  Blake2128: _void3,
  Blake2256: _void3,
  Blake2128Concat: _void3,
  Twox128: _void3,
  Twox256: _void3,
  Twox64Concat: _void3,
  Identity: _void3
});
var hashers = Vector2(hashType);
var storageMap = Struct2({
  hashers,
  key: compactNumber,
  value: compactNumber
});
var storageItem = Struct2({
  name: str2,
  modifier: u82,
  type: Enum2({
    plain: compactNumber,
    map: storageMap
  }),
  fallback: Hex(),
  docs: Vector2(str2)
});
var storage = Option2(
  Struct2({
    prefix: str2,
    items: Vector2(storageItem)
  })
);
var pallets = Vector2(
  Struct2({
    name: str2,
    storage,
    calls: Option2(compactNumber),
    events: Option2(compactNumber),
    constants: Vector2(
      Struct2({
        name: str2,
        type: compactNumber,
        value: Hex(),
        docs: Vector2(str2)
      })
    ),
    errors: Option2(compactNumber),
    index: u82
  })
);

// src/codecs/metadata/v14/v14.ts
var extrinsic = Struct3({
  type: compactNumber,
  version: u83,
  signedExtensions: Vector3(
    Struct3({
      identifier: str3,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v14 = Struct3({
  lookup,
  pallets,
  extrinsic,
  type: compactNumber
});

// src/codecs/metadata/metadata.ts
import { Enum as Enum3, Struct as Struct4, u32 as u322, createCodec as createCodec4 } from "scale-ts";
var unsupportedFn = () => {
  throw new Error("Unsupported metadata version!");
};
var unsupported = createCodec4(
  unsupportedFn,
  unsupportedFn
);
var metadata = Struct4({
  magicNumber: u322,
  metadata: Enum3({
    v0: unsupported,
    v1: unsupported,
    v2: unsupported,
    v3: unsupported,
    v4: unsupported,
    v5: unsupported,
    v6: unsupported,
    v7: unsupported,
    v8: unsupported,
    v9: unsupported,
    v10: unsupported,
    v11: unsupported,
    v12: unsupported,
    v13: unsupported,
    v14
  })
});

// src/codecs/bitSequence.ts
import { Bytes as Bytes4, createCodec as createCodec5, createDecoder as createDecoder2 } from "scale-ts";
var bitSequenceDecoder = createDecoder2((data) => {
  const bitsLen = compactNumber.dec(data);
  const bytesLen = Math.ceil(bitsLen / 8);
  const bytes = Bytes4(bytesLen).dec(data);
  return { bytes, bitsLen };
});
var bitSequenceEncoder = (input) => {
  if (input.bitsLen > input.bytes.length * 8)
    throw new Error(
      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`
    );
  const lenEncoded = compactNumber.enc(input.bitsLen);
  const result = new Uint8Array(input.bytes.length + lenEncoded.length);
  result.set(lenEncoded, 0);
  result.set(input.bytes, lenEncoded.length);
  return result;
};
var bitSequence2 = createCodec5(bitSequenceEncoder, bitSequenceDecoder);

// src/codecs/char.ts
import { enhanceCodec as enhanceCodec2, u8 as u84 } from "scale-ts";
var char = enhanceCodec2(
  u84,
  (str4) => str4.charCodeAt(0),
  String.fromCharCode
);

// src/codecs/fixed-str.ts
import { Bytes as Bytes5, enhanceCodec as enhanceCodec3 } from "scale-ts";
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var fixedStr = (nBytes) => enhanceCodec3(
  Bytes5(nBytes),
  (str4) => textEncoder.encode(str4),
  (bytes) => textDecoder.decode(bytes)
);

// src/codecs/blockHeader.ts
import {
  Bytes as Bytes6,
  Enum as Enum4,
  Struct as Struct5,
  Vector as Vector4,
  _void as _void4,
  enhanceCodec as enhanceCodec4
} from "scale-ts";
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();
var fourChars = enhanceCodec4(
  Bytes6(4),
  textEncoder2.encode.bind(textEncoder2),
  textDecoder2.decode.bind(textDecoder2)
);
var diggestVal = Struct5({
  engine: fourChars,
  payload: Hex()
});
var diggest = Enum4(
  {
    consensus: diggestVal,
    seal: diggestVal,
    preRuntime: diggestVal,
    runtimeUpdated: _void4
  },
  [4, 5, 6, 8]
);
var hex32 = Hex(32);
var blockHeader = Struct5({
  parentHash: hex32,
  number: compactNumber,
  stateRoot: hex32,
  extrinsicRoot: hex32,
  digests: Vector4(diggest)
});

// src/index.ts
__reExport(src_exports, codecs_exports);

// src/hashes/blake2.ts
import { mergeUint8 } from "@polkadot-api/utils";
import { blake2b as blake2b2 } from "@noble/hashes/blake2b";
var len32 = { dkLen: 32 };
var Blake2256 = (encoded) => blake2b2(encoded, len32);
var len16 = { dkLen: 16 };
var Blake2128 = (encoded) => blake2b2(encoded, len16);
var Blake2128Concat = (encoded) => mergeUint8(Blake2128(encoded), encoded);

// src/hashes/identity.ts
var Identity = (encoded) => encoded;

// src/hashes/twoX.ts
import { mergeUint8 as mergeUint82 } from "@polkadot-api/utils";
import { u64 } from "scale-ts";

// src/hashes/h64.ts
var bigintFromU16 = (v0, v1, v2, v3) => new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true);
var MASK_64 = 2n ** 64n - 1n;
var rotl = (input, nBits) => input << nBits & MASK_64 | input >> 64n - nBits;
var multiply = (a, b) => a * b & MASK_64;
var add = (a, b) => a + b & MASK_64;
var PRIME64_1 = 11400714785074694791n;
var PRIME64_2 = 14029467366897019727n;
var PRIME64_3 = 1609587929392839161n;
var PRIME64_4 = 9650029242287828579n;
var PRIME64_5 = 2870177450012600261n;
function h64(input, seed = 0n) {
  let v1 = add(add(seed, PRIME64_1), PRIME64_2);
  let v2 = add(seed, PRIME64_2);
  let v3 = seed;
  let v4 = seed - PRIME64_1;
  let totalLen = input.length;
  let memsize = 0;
  let memory = null;
  (function update() {
    let p2 = 0;
    let bEnd = p2 + totalLen;
    if (!totalLen)
      return;
    memory = new Uint8Array(32);
    if (totalLen < 32) {
      memory.set(input.subarray(0, totalLen), memsize);
      memsize += totalLen;
      return;
    }
    if (p2 <= bEnd - 32) {
      const limit = bEnd - 32;
      do {
        let other;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
      } while (p2 <= limit);
    }
    if (p2 < bEnd) {
      memory.set(input.subarray(p2, bEnd), memsize);
      memsize = bEnd - p2;
    }
  })();
  input = memory || input;
  let result;
  let p = 0;
  if (totalLen >= 32) {
    result = rotl(v1, 1n);
    result = add(result, rotl(v2, 7n));
    result = add(result, rotl(v3, 12n));
    result = add(result, rotl(v4, 18n));
    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v1;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v2;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v3;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v4;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
  } else {
    result = add(seed, PRIME64_5);
  }
  result = add(result, BigInt(totalLen));
  while (p <= memsize - 8) {
    let temp2 = bigintFromU16(
      input[p + 1] << 8 | input[p],
      input[p + 3] << 8 | input[p + 2],
      input[p + 5] << 8 | input[p + 4],
      input[p + 7] << 8 | input[p + 6]
    );
    temp2 = multiply(rotl(multiply(temp2, PRIME64_2), 31n), PRIME64_1);
    result = add(multiply(rotl(result ^ temp2, 27n), PRIME64_1), PRIME64_4);
    p += 8;
  }
  if (p + 4 <= memsize) {
    let temp2 = multiply(
      bigintFromU16(
        input[p + 1] << 8 | input[p],
        input[p + 3] << 8 | input[p + 2],
        0,
        0
      ),
      PRIME64_1
    );
    result = add(multiply(rotl(result ^ temp2, 23n), PRIME64_2), PRIME64_3);
    p += 4;
  }
  while (p < memsize) {
    const temp2 = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5);
    result = multiply(rotl(result ^ temp2, 11n), PRIME64_1);
  }
  let temp = result >> 33n;
  result = multiply(result ^ temp, PRIME64_2);
  temp = result >> 29n;
  result = multiply(result ^ temp, PRIME64_3);
  temp = result >> 32n;
  result ^= temp;
  return result;
}

// src/hashes/twoX.ts
var Twox128 = (input) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  return result;
};
var Twox256 = (input) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  dv.setBigUint64(16, h64(input, 2n), true);
  dv.setBigUint64(24, h64(input, 3n), true);
  return result;
};
var Twox64Concat = (encoded) => mergeUint82(u64.enc(h64(encoded)), encoded);

// src/storage.ts
import { mergeUint8 as mergeUint83, toHex as toHex2 } from "@polkadot-api/utils";
var textEncoder3 = new TextEncoder();
var Storage = (pallet) => {
  const palledEncoded = Twox128(textEncoder3.encode(pallet));
  return (name, dec2, ...encoders) => {
    const palletItemEncoded = mergeUint83(
      palledEncoded,
      Twox128(textEncoder3.encode(name))
    );
    const palletItemEncodedHex = toHex2(palletItemEncoded);
    const bytesToSkip = encoders.map((e) => e[1]).map((x) => {
      if (x === Identity)
        return 0;
      if (x === Twox64Concat)
        return 8;
      if (x === Blake2128Concat)
        return 16;
      return null;
    }).filter(Boolean);
    const keyDecoder = (key) => {
      if (!key.startsWith(palletItemEncodedHex))
        throw new Error(`key does not match this storage (${pallet}.${name})`);
      if (bytesToSkip.length !== encoders.length)
        throw new Error("Impossible to decode this key");
      if (encoders.length === 0)
        return [];
      const argsKey = key.slice(palletItemEncodedHex.length);
      const result = new Array(encoders.length);
      for (let i = 0, cur = 0; i < bytesToSkip.length; i++) {
        const codec = encoders[i][0];
        cur += bytesToSkip[i];
        result[i] = codec.dec(argsKey.slice(cur * 2));
        cur += codec.enc(result[i]).length;
      }
      return result;
    };
    const fns = encoders.map(
      ([{ enc: enc3 }, hash]) => (val) => hash(enc3(val))
    );
    const enc2 = (...args) => toHex2(
      mergeUint83(palletItemEncoded, ...args.map((val, idx) => fns[idx](val)))
    );
    return {
      enc: enc2,
      dec: dec2,
      keyDecoder
    };
  };
};
export {
  AccountId,
  Blake2128,
  Blake2128Concat,
  Blake2256,
  Hex,
  Identity,
  OpaqueCodec,
  Self,
  Storage,
  Twox128,
  Twox256,
  Twox64Concat,
  bitSequence2 as bitSequence,
  blockHeader,
  char,
  compactBn,
  compactNumber,
  fixedStr,
  h64,
  metadata,
  selfDecoder,
  selfEncoder,
  v14
};
//# sourceMappingURL=index.mjs.map